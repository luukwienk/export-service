"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }// src/helpers.ts
function getTokenFromOptionsOrEnv(options) {
  if (options == null ? void 0 : options.token) {
    return options.token;
  }
  if (process.env.BLOB_READ_WRITE_TOKEN) {
    return process.env.BLOB_READ_WRITE_TOKEN;
  }
  throw new BlobError(
    "No token found. Either configure the `BLOB_READ_WRITE_TOKEN` environment variable, or pass a `token` option to your calls."
  );
}
var BlobError = class extends Error {
  constructor(message) {
    super(`Vercel Blob: ${message}`);
  }
};

// src/api.ts
var _undici = require('undici');
var _asyncretry = require('async-retry'); var _asyncretry2 = _interopRequireDefault(_asyncretry);

// src/debug.ts
var debugIsActive = false;
var _a, _b;
try {
  if (((_a = process.env.DEBUG) == null ? void 0 : _a.includes("blob")) || ((_b = process.env.NEXT_PUBLIC_DEBUG) == null ? void 0 : _b.includes("blob"))) {
    debugIsActive = true;
  }
} catch (error) {
}
function debug(message, ...args) {
  if (debugIsActive) {
    console.debug(`vercel-blob: ${message}`, ...args);
  }
}

// src/api.ts
var BlobAccessError = class extends BlobError {
  constructor() {
    super("Access denied, please provide a valid token for this resource.");
  }
};
var BlobStoreNotFoundError = class extends BlobError {
  constructor() {
    super("This store does not exist.");
  }
};
var BlobStoreSuspendedError = class extends BlobError {
  constructor() {
    super("This store has been suspended.");
  }
};
var BlobUnknownError = class extends BlobError {
  constructor() {
    super("Unknown error, please visit https://vercel.com/help.");
  }
};
var BlobNotFoundError = class extends BlobError {
  constructor() {
    super("The requested blob does not exist");
  }
};
var BlobServiceNotAvailable = class extends BlobError {
  constructor() {
    super("The blob service is currently not available. Please try again.");
  }
};
var BLOB_API_VERSION = 6;
function getApiVersion() {
  let versionOverride = null;
  try {
    versionOverride = process.env.VERCEL_BLOB_API_VERSION_OVERRIDE || process.env.NEXT_PUBLIC_VERCEL_BLOB_API_VERSION_OVERRIDE;
  } catch (e) {
  }
  return `${versionOverride != null ? versionOverride : BLOB_API_VERSION}`;
}
function getApiUrl(pathname = "") {
  let baseUrl = null;
  try {
    baseUrl = process.env.VERCEL_BLOB_API_URL || process.env.NEXT_PUBLIC_VERCEL_BLOB_API_URL;
  } catch (e2) {
  }
  return `${baseUrl || "https://blob.vercel-storage.com"}${pathname}`;
}
function getRetries() {
  try {
    const retries = process.env.VERCEL_BLOB_RETRIES || "10";
    return parseInt(retries, 10);
  } catch (e3) {
    return 10;
  }
}
async function getBlobApiError(response) {
  try {
    const data = await response.json();
    return data.error;
  } catch (e4) {
    return { code: "unknown_error" };
  }
}
function getBlobError(error) {
  var _a2;
  switch (error == null ? void 0 : error.code) {
    case "store_suspended":
      return new BlobStoreSuspendedError();
    case "forbidden":
      return new BlobAccessError();
    case "not_found":
      return new BlobNotFoundError();
    case "store_not_found":
      return new BlobStoreNotFoundError();
    case "bad_request":
      return new BlobError((_a2 = error.message) != null ? _a2 : "Bad request");
    case "service_unavailable":
      return new BlobServiceNotAvailable();
    case "unknown_error":
    case "not_allowed":
    default:
      return new BlobUnknownError();
  }
}
async function requestApi(pathname, init, commandOptions) {
  const apiVersion = getApiVersion();
  const token = getTokenFromOptionsOrEnv(commandOptions);
  const apiResponse = await _asyncretry2.default.call(void 0, 
    async (bail) => {
      const res = await _undici.fetch.call(void 0, getApiUrl(pathname), {
        ...init,
        headers: {
          "x-api-version": apiVersion,
          authorization: `Bearer ${token}`,
          ...init.headers
        }
      });
      if (res.ok) {
        return res;
      }
      const apiError = await getBlobApiError(res);
      const { code } = apiError != null ? apiError : {};
      const error = getBlobError(apiError);
      if (code === "unknown_error" || code === "service_unavailable") {
        throw error;
      } else {
        bail(error);
      }
    },
    {
      retries: getRetries(),
      onRetry: (error) => {
        debug(`retrying API request to ${pathname}`, error.message);
      }
    }
  );
  if (!apiResponse) {
    throw new BlobUnknownError();
  }
  return await apiResponse.json();
}

// src/put-multipart.ts
var _stream = require('stream');
var _bytes = require('bytes'); var _bytes2 = _interopRequireDefault(_bytes);
var maxConcurrentUploads = typeof window !== "undefined" ? 6 : 8;
var partSizeInBytes = 8 * 1024 * 1024;
var maxBytesInMemory = maxConcurrentUploads * partSizeInBytes * 2;
async function multipartPut(pathname, body, headers, options) {
  debug("mpu: init", "pathname:", pathname, "headers:", headers);
  const stream = toReadableStream(body);
  const createMultipartUploadResponse = await createMultiPartUpload(
    pathname,
    headers,
    options
  );
  const parts = await uploadParts(
    createMultipartUploadResponse.uploadId,
    createMultipartUploadResponse.key,
    pathname,
    stream,
    headers,
    options
  );
  const blob = await completeMultiPartUpload(
    createMultipartUploadResponse.uploadId,
    createMultipartUploadResponse.key,
    pathname,
    parts,
    headers,
    options
  );
  return blob;
}
async function completeMultiPartUpload(uploadId, key, pathname, parts, headers, options) {
  try {
    const response = await requestApi(
      `/mpu/${pathname}`,
      {
        method: "POST",
        headers: {
          ...headers,
          "content-type": "application/json",
          "x-mpu-action": "complete",
          "x-mpu-upload-id": uploadId,
          // key can be any utf8 character so we need to encode it as HTTP headers can only be us-ascii
          // https://www.rfc-editor.org/rfc/rfc7230#section-3.2.4
          "x-mpu-key": encodeURI(key)
        },
        body: JSON.stringify(parts)
      },
      options
    );
    debug("mpu: complete", response);
    return response;
  } catch (error) {
    if (error instanceof TypeError && (error.message === "Failed to fetch" || error.message === "fetch failed")) {
      throw new BlobServiceNotAvailable();
    } else {
      throw error;
    }
  }
}
async function createMultiPartUpload(pathname, headers, options) {
  debug("mpu: create", "pathname:", pathname);
  try {
    const response = await requestApi(
      `/mpu/${pathname}`,
      {
        method: "POST",
        headers: {
          ...headers,
          "x-mpu-action": "create"
        }
      },
      options
    );
    debug("mpu: create", response);
    return response;
  } catch (error) {
    if (error instanceof TypeError && (error.message === "Failed to fetch" || error.message === "fetch failed")) {
      throw new BlobServiceNotAvailable();
    } else {
      throw error;
    }
  }
}
function uploadParts(uploadId, key, pathname, stream, headers, options) {
  debug("mpu: upload init", "key:", key);
  const internalAbortController = new AbortController();
  return new Promise((resolve, reject) => {
    const partsToUpload = [];
    const completedParts = [];
    const reader = stream.getReader();
    let activeUploads = 0;
    let reading = false;
    let currentPartNumber = 1;
    let rejected = false;
    let currentBytesInMemory = 0;
    let doneReading = false;
    let bytesSent = 0;
    let arrayBuffers = [];
    let currentPartBytesRead = 0;
    read().catch(cancel);
    async function read() {
      debug(
        "mpu: upload read start",
        "activeUploads:",
        activeUploads,
        "currentBytesInMemory:",
        `${_bytes2.default.call(void 0, currentBytesInMemory)}/${_bytes2.default.call(void 0, maxBytesInMemory)}`,
        "bytesSent:",
        _bytes2.default.call(void 0, bytesSent)
      );
      reading = true;
      while (currentBytesInMemory < maxBytesInMemory && !rejected) {
        try {
          const { value, done } = await reader.read();
          if (done) {
            doneReading = true;
            debug("mpu: upload read consumed the whole stream");
            if (arrayBuffers.length > 0) {
              partsToUpload.push({
                partNumber: currentPartNumber++,
                blob: new Blob(arrayBuffers, {
                  type: "application/octet-stream"
                })
              });
              sendParts();
            }
            reading = false;
            return;
          }
          currentBytesInMemory += value.byteLength;
          let valueOffset = 0;
          while (valueOffset < value.byteLength) {
            const remainingPartSize = partSizeInBytes - currentPartBytesRead;
            const endOffset = Math.min(
              valueOffset + remainingPartSize,
              value.byteLength
            );
            const chunk = value.slice(valueOffset, endOffset);
            arrayBuffers.push(chunk);
            currentPartBytesRead += chunk.byteLength;
            valueOffset = endOffset;
            if (currentPartBytesRead === partSizeInBytes) {
              partsToUpload.push({
                partNumber: currentPartNumber++,
                blob: new Blob(arrayBuffers, {
                  type: "application/octet-stream"
                })
              });
              arrayBuffers = [];
              currentPartBytesRead = 0;
              sendParts();
            }
          }
        } catch (error) {
          cancel(error);
        }
      }
      debug(
        "mpu: upload read end",
        "activeUploads:",
        activeUploads,
        "currentBytesInMemory:",
        `${_bytes2.default.call(void 0, currentBytesInMemory)}/${_bytes2.default.call(void 0, maxBytesInMemory)}`,
        "bytesSent:",
        _bytes2.default.call(void 0, bytesSent)
      );
      reading = false;
    }
    async function sendPart(part) {
      activeUploads++;
      debug(
        "mpu: upload send part start",
        "partNumber:",
        part.partNumber,
        "size:",
        part.blob.size,
        "activeUploads:",
        activeUploads,
        "currentBytesInMemory:",
        `${_bytes2.default.call(void 0, currentBytesInMemory)}/${_bytes2.default.call(void 0, maxBytesInMemory)}`,
        "bytesSent:",
        _bytes2.default.call(void 0, bytesSent)
      );
      try {
        const completedPart = await requestApi(
          `/mpu/${pathname}`,
          {
            signal: internalAbortController.signal,
            method: "POST",
            headers: {
              ...headers,
              "x-mpu-action": "upload",
              "x-mpu-key": encodeURI(key),
              "x-mpu-upload-id": uploadId,
              "x-mpu-part-number": part.partNumber.toString()
            },
            // weird things between undici types and native fetch types
            body: part.blob
          },
          options
        );
        debug(
          "mpu: upload send part end",
          "partNumber:",
          part.partNumber,
          "activeUploads",
          activeUploads,
          "currentBytesInMemory:",
          `${_bytes2.default.call(void 0, currentBytesInMemory)}/${_bytes2.default.call(void 0, maxBytesInMemory)}`,
          "bytesSent:",
          _bytes2.default.call(void 0, bytesSent)
        );
        if (rejected) {
          return;
        }
        completedParts.push({
          partNumber: part.partNumber,
          etag: completedPart.etag
        });
        currentBytesInMemory -= part.blob.size;
        activeUploads--;
        bytesSent += part.blob.size;
        if (partsToUpload.length > 0) {
          sendParts();
        }
        if (doneReading) {
          if (activeUploads === 0) {
            reader.releaseLock();
            resolve(completedParts);
          }
          return;
        }
        if (!reading) {
          read().catch(cancel);
        }
      } catch (error) {
        cancel(error);
      }
    }
    function sendParts() {
      if (rejected) {
        return;
      }
      debug(
        "send parts",
        "activeUploads",
        activeUploads,
        "partsToUpload",
        partsToUpload.length
      );
      while (activeUploads < maxConcurrentUploads && partsToUpload.length > 0) {
        const partToSend = partsToUpload.shift();
        if (partToSend) {
          void sendPart(partToSend);
        }
      }
    }
    function cancel(error) {
      if (rejected) {
        return;
      }
      rejected = true;
      internalAbortController.abort();
      reader.releaseLock();
      if (error instanceof TypeError && (error.message === "Failed to fetch" || error.message === "fetch failed")) {
        reject(new BlobServiceNotAvailable());
      } else {
        reject(error);
      }
    }
  });
}
function toReadableStream(value) {
  if (value instanceof ReadableStream) {
    return value;
  }
  if (value instanceof Blob) {
    return value.stream();
  }
  if (isNodeJsReadableStream(value)) {
    return _stream.Readable.toWeb(value);
  }
  const streamValue = value instanceof ArrayBuffer ? value : stringToUint8Array(value);
  return new ReadableStream({
    start(controller) {
      controller.enqueue(streamValue);
      controller.close();
    }
  });
}
function isNodeJsReadableStream(value) {
  return typeof value === "object" && typeof value.pipe === "function" && value.readable && typeof value._read === "function" && // @ts-expect-error _readableState does exists on Readable
  typeof value._readableState === "object";
}
function stringToUint8Array(s) {
  const enc = new TextEncoder();
  return enc.encode(s);
}

// src/put.ts
function createPutMethod({
  allowedOptions,
  getToken,
  extraChecks
}) {
  return async function put(pathname, bodyOrOptions, optionsInput) {
    if (!pathname) {
      throw new BlobError("pathname is required");
    }
    const isFolderCreation = pathname.endsWith("/");
    if (!bodyOrOptions && !isFolderCreation) {
      throw new BlobError("body is required");
    }
    if (bodyOrOptions && optionsInput && isFolderCreation) {
      throw new BlobError("body is not allowed for creating empty folders");
    }
    const body = isFolderCreation ? void 0 : bodyOrOptions;
    const options = isFolderCreation ? bodyOrOptions : optionsInput;
    if (!options) {
      throw new BlobError("missing options, see usage");
    }
    if (options.access !== "public") {
      throw new BlobError('access must be "public"');
    }
    if (extraChecks) {
      extraChecks(options);
    }
    if (getToken) {
      options.token = await getToken(pathname, options);
    }
    const headers = {};
    if (allowedOptions.includes("contentType") && options.contentType) {
      headers["x-content-type"] = options.contentType;
    }
    if (allowedOptions.includes("addRandomSuffix") && options.addRandomSuffix !== void 0) {
      headers["x-add-random-suffix"] = options.addRandomSuffix ? "1" : "0";
    }
    if (allowedOptions.includes("cacheControlMaxAge") && options.cacheControlMaxAge !== void 0) {
      headers["x-cache-control-max-age"] = options.cacheControlMaxAge.toString();
    }
    if (options.multipart === true && body) {
      return multipartPut(pathname, body, headers, options);
    }
    return requestApi(
      `/${pathname}`,
      {
        method: "PUT",
        body,
        headers,
        // required in order to stream some body types to Cloudflare
        // currently only supported in Node.js, we may have to feature detect this
        duplex: "half"
      },
      options
    );
  };
}












exports.getTokenFromOptionsOrEnv = getTokenFromOptionsOrEnv; exports.BlobError = BlobError; exports.BlobAccessError = BlobAccessError; exports.BlobStoreNotFoundError = BlobStoreNotFoundError; exports.BlobStoreSuspendedError = BlobStoreSuspendedError; exports.BlobUnknownError = BlobUnknownError; exports.BlobNotFoundError = BlobNotFoundError; exports.BlobServiceNotAvailable = BlobServiceNotAvailable; exports.requestApi = requestApi; exports.createPutMethod = createPutMethod;
//# sourceMappingURL=chunk-E34P7WHI.cjs.map