{"version":3,"sources":["../src/helpers.ts","../src/api.ts","../src/debug.ts","../src/put-multipart.ts","../src/put.ts"],"sourcesContent":["// common util interface for blob raw commands, not meant to be used directly\n// this is why it's not exported from index/client\n\nexport interface BlobCommandOptions {\n  /**\n   * Define your blob API token.\n   * @defaultvalue process.env.BLOB_READ_WRITE_TOKEN\n   */\n  token?: string;\n}\n\n// shared interface for put and copy\nexport interface CreateBlobCommandOptions extends BlobCommandOptions {\n  /**\n   * Whether the blob should be publicly accessible. Support for private blobs is planned.\n   */\n  access: 'public';\n  /**\n   * Adds a random suffix to the filename.\n   * @defaultvalue true\n   */\n  addRandomSuffix?: boolean;\n  /**\n   * Defines the content type of the blob. By default, this value is inferred from the pathname. Sent as the 'content-type' header when downloading a blob.\n   */\n  contentType?: string;\n  /**\n   * Number in seconds to configure the edge and browser cache. The maximum values are 5 minutes for the edge cache and unlimited for the browser cache.\n   * Detailed documentation can be found here: https://vercel.com/docs/storage/vercel-blob#caching\n   * @defaultvalue 365 * 24 * 60 * 60 (1 Year)\n   */\n  cacheControlMaxAge?: number;\n  /**\n   * Whether to use multipart upload. Use this when uploading large files. It will split the file into multiple parts, upload them in parallel and retry failed parts.\n   * @defaultvalue false\n   */\n  multipart?: boolean;\n}\n\nexport function getTokenFromOptionsOrEnv(options?: BlobCommandOptions): string {\n  if (options?.token) {\n    return options.token;\n  }\n\n  if (process.env.BLOB_READ_WRITE_TOKEN) {\n    return process.env.BLOB_READ_WRITE_TOKEN;\n  }\n\n  throw new BlobError(\n    'No token found. Either configure the `BLOB_READ_WRITE_TOKEN` environment variable, or pass a `token` option to your calls.',\n  );\n}\n\nexport class BlobError extends Error {\n  constructor(message: string) {\n    super(`Vercel Blob: ${message}`);\n  }\n}\n","import type { RequestInit, Response } from 'undici';\nimport { fetch } from 'undici';\nimport retry from 'async-retry';\nimport { debug } from './debug';\nimport type { BlobCommandOptions } from './helpers';\nimport { BlobError, getTokenFromOptionsOrEnv } from './helpers';\n\nexport class BlobAccessError extends BlobError {\n  constructor() {\n    super('Access denied, please provide a valid token for this resource.');\n  }\n}\n\nexport class BlobStoreNotFoundError extends BlobError {\n  constructor() {\n    super('This store does not exist.');\n  }\n}\n\nexport class BlobStoreSuspendedError extends BlobError {\n  constructor() {\n    super('This store has been suspended.');\n  }\n}\n\nexport class BlobUnknownError extends BlobError {\n  constructor() {\n    super('Unknown error, please visit https://vercel.com/help.');\n  }\n}\n\nexport class BlobNotFoundError extends BlobError {\n  constructor() {\n    super('The requested blob does not exist');\n  }\n}\n\nexport class BlobServiceNotAvailable extends BlobError {\n  constructor() {\n    super('The blob service is currently not available. Please try again.');\n  }\n}\n\ntype BlobApiErrorCodes =\n  | 'store_suspended'\n  | 'forbidden'\n  | 'not_found'\n  | 'unknown_error'\n  | 'bad_request'\n  | 'store_not_found'\n  | 'not_allowed'\n  | 'service_unavailable';\n\nexport interface BlobApiError {\n  error?: { code?: BlobApiErrorCodes; message?: string };\n}\n\n// This version is used to ensure that the client and server are compatible\n// The server (Vercel Blob API) uses this information to change its behavior like the\n// response format\nconst BLOB_API_VERSION = 6;\n\nfunction getApiVersion(): string {\n  let versionOverride = null;\n  try {\n    // wrapping this code in a try/catch as this function is used in the browser and Vite doesn't define the process.env.\n    // As this varaible is NOT used in production, it will always default to the BLOB_API_VERSION\n    versionOverride =\n      process.env.VERCEL_BLOB_API_VERSION_OVERRIDE ||\n      process.env.NEXT_PUBLIC_VERCEL_BLOB_API_VERSION_OVERRIDE;\n  } catch {\n    // noop\n  }\n\n  return `${versionOverride ?? BLOB_API_VERSION}`;\n}\n\nfunction getApiUrl(pathname = ''): string {\n  let baseUrl = null;\n  try {\n    // wrapping this code in a try/catch as this function is used in the browser and Vite doesn't define the process.env.\n    // As this varaible is NOT used in production, it will always default to production endpoint\n    baseUrl =\n      process.env.VERCEL_BLOB_API_URL ||\n      process.env.NEXT_PUBLIC_VERCEL_BLOB_API_URL;\n  } catch {\n    // noop\n  }\n  return `${baseUrl || 'https://blob.vercel-storage.com'}${pathname}`;\n}\n\nfunction getRetries(): number {\n  try {\n    const retries = process.env.VERCEL_BLOB_RETRIES || '10';\n\n    return parseInt(retries, 10);\n  } catch {\n    return 10;\n  }\n}\n\n// reads the body of a error response\nasync function getBlobApiError(\n  response: Response,\n): Promise<BlobApiError['error'] | undefined> {\n  try {\n    const data = await response.json();\n\n    return (data as BlobApiError).error;\n  } catch {\n    return { code: 'unknown_error' };\n  }\n}\n\n// converts BlobApiError object into BlobError class\nfunction getBlobError(error: BlobApiError['error']): BlobError {\n  switch (error?.code) {\n    case 'store_suspended':\n      return new BlobStoreSuspendedError();\n    case 'forbidden':\n      return new BlobAccessError();\n    case 'not_found':\n      return new BlobNotFoundError();\n    case 'store_not_found':\n      return new BlobStoreNotFoundError();\n    case 'bad_request':\n      return new BlobError(error.message ?? 'Bad request');\n    case 'service_unavailable':\n      return new BlobServiceNotAvailable();\n    case 'unknown_error':\n    case 'not_allowed':\n    default:\n      return new BlobUnknownError();\n  }\n}\n\nexport async function requestApi<TResponse>(\n  pathname: string,\n  init: RequestInit,\n  commandOptions: BlobCommandOptions | undefined,\n): Promise<TResponse> {\n  const apiVersion = getApiVersion();\n  const token = getTokenFromOptionsOrEnv(commandOptions);\n\n  const apiResponse = await retry(\n    async (bail) => {\n      const res = await fetch(getApiUrl(pathname), {\n        ...init,\n        headers: {\n          'x-api-version': apiVersion,\n          authorization: `Bearer ${token}`,\n\n          ...init.headers,\n        },\n      });\n\n      if (res.ok) {\n        return res;\n      }\n\n      const apiError = await getBlobApiError(res);\n      const { code } = apiError ?? {};\n      const error = getBlobError(apiError);\n\n      if (code === 'unknown_error' || code === 'service_unavailable') {\n        // only retry for certain errors\n        throw error;\n      } else {\n        // don't retry for e.g. suspended stores\n        bail(error);\n      }\n    },\n    {\n      retries: getRetries(),\n      onRetry: (error) => {\n        debug(`retrying API request to ${pathname}`, error.message);\n      },\n    },\n  );\n\n  if (!apiResponse) {\n    throw new BlobUnknownError();\n  }\n\n  return (await apiResponse.json()) as TResponse;\n}\n","let debugIsActive = false;\n\n// wrapping this code in a try/catch in case some env doesn't support process.env (vite by default)\ntry {\n  if (\n    process.env.DEBUG?.includes('blob') ||\n    process.env.NEXT_PUBLIC_DEBUG?.includes('blob')\n  ) {\n    debugIsActive = true;\n  }\n} catch (error) {\n  // noop\n}\n\n// Set process.env.DEBUG = 'blob' to enable debug logging\nexport function debug(message: string, ...args: unknown[]): void {\n  if (debugIsActive) {\n    // eslint-disable-next-line no-console -- Ok for debugging\n    console.debug(`vercel-blob: ${message}`, ...args);\n  }\n}\n","// eslint-disable-next-line unicorn/prefer-node-protocol -- node:stream does not resolve correctly in browser and edge\nimport { Readable } from 'stream';\nimport bytes from 'bytes';\nimport type { BodyInit } from 'undici';\nimport { BlobServiceNotAvailable, requestApi } from './api';\nimport { debug } from './debug';\nimport type { PutBlobApiResponse, PutBlobResult, PutBody } from './put';\nimport type { BlobCommandOptions } from './helpers';\n\n// Most browsers will cap requests at 6 concurrent uploads per domain (Vercel Blob API domain)\n// In other environments, we can afford to be more aggressive\nconst maxConcurrentUploads = typeof window !== 'undefined' ? 6 : 8;\n\n// 5MB is the minimum part size accepted by Vercel Blob, but we set our default part size to 8mb like the aws cli\nconst partSizeInBytes = 8 * 1024 * 1024;\n\nconst maxBytesInMemory = maxConcurrentUploads * partSizeInBytes * 2;\n\ninterface CreateMultiPartUploadApiResponse {\n  uploadId: string;\n  key: string;\n}\n\ninterface UploadPartApiResponse {\n  etag: string;\n}\n\nexport async function multipartPut(\n  pathname: string,\n  body: PutBody,\n  headers: Record<string, string>,\n  options: BlobCommandOptions,\n): Promise<PutBlobResult> {\n  debug('mpu: init', 'pathname:', pathname, 'headers:', headers);\n\n  const stream = toReadableStream(body);\n\n  // Step 1: Start multipart upload\n  const createMultipartUploadResponse = await createMultiPartUpload(\n    pathname,\n    headers,\n    options,\n  );\n\n  // Step 2: Upload parts one by one\n  const parts = await uploadParts(\n    createMultipartUploadResponse.uploadId,\n    createMultipartUploadResponse.key,\n    pathname,\n    stream,\n    headers,\n    options,\n  );\n\n  // Step 3: Complete multipart upload\n  const blob = await completeMultiPartUpload(\n    createMultipartUploadResponse.uploadId,\n    createMultipartUploadResponse.key,\n    pathname,\n    parts,\n    headers,\n    options,\n  );\n\n  return blob;\n}\n\nasync function completeMultiPartUpload(\n  uploadId: string,\n  key: string,\n  pathname: string,\n  parts: CompletedPart[],\n  headers: Record<string, string>,\n  options: BlobCommandOptions,\n): Promise<PutBlobResult> {\n  try {\n    const response = await requestApi<PutBlobApiResponse>(\n      `/mpu/${pathname}`,\n      {\n        method: 'POST',\n        headers: {\n          ...headers,\n          'content-type': 'application/json',\n          'x-mpu-action': 'complete',\n          'x-mpu-upload-id': uploadId,\n          // key can be any utf8 character so we need to encode it as HTTP headers can only be us-ascii\n          // https://www.rfc-editor.org/rfc/rfc7230#section-3.2.4\n          'x-mpu-key': encodeURI(key),\n        },\n        body: JSON.stringify(parts),\n      },\n      options,\n    );\n\n    debug('mpu: complete', response);\n\n    return response;\n  } catch (error: unknown) {\n    if (\n      error instanceof TypeError &&\n      (error.message === 'Failed to fetch' || error.message === 'fetch failed')\n    ) {\n      throw new BlobServiceNotAvailable();\n    } else {\n      throw error;\n    }\n  }\n}\n\nasync function createMultiPartUpload(\n  pathname: string,\n  headers: Record<string, string>,\n  options: BlobCommandOptions,\n): Promise<CreateMultiPartUploadApiResponse> {\n  debug('mpu: create', 'pathname:', pathname);\n\n  try {\n    const response = await requestApi<CreateMultiPartUploadApiResponse>(\n      `/mpu/${pathname}`,\n      {\n        method: 'POST',\n        headers: {\n          ...headers,\n          'x-mpu-action': 'create',\n        },\n      },\n      options,\n    );\n\n    debug('mpu: create', response);\n\n    return response;\n  } catch (error: unknown) {\n    if (\n      error instanceof TypeError &&\n      (error.message === 'Failed to fetch' || error.message === 'fetch failed')\n    ) {\n      throw new BlobServiceNotAvailable();\n    } else {\n      throw error;\n    }\n  }\n}\n\ninterface UploadPart {\n  partNumber: number;\n  blob: Blob;\n}\n\ninterface CompletedPart {\n  partNumber: number;\n  etag: string;\n}\n\n// Can we rewrite this function without new Promise?\nfunction uploadParts(\n  uploadId: string,\n  key: string,\n  pathname: string,\n  stream: ReadableStream<ArrayBuffer>,\n  headers: Record<string, string>,\n  options: BlobCommandOptions,\n): Promise<CompletedPart[]> {\n  debug('mpu: upload init', 'key:', key);\n  const internalAbortController = new AbortController();\n\n  return new Promise((resolve, reject) => {\n    const partsToUpload: UploadPart[] = [];\n    const completedParts: CompletedPart[] = [];\n    const reader = stream.getReader();\n    let activeUploads = 0;\n    let reading = false;\n    let currentPartNumber = 1;\n    // this next variable is used to escape the read loop when an error occurs\n    let rejected = false;\n    let currentBytesInMemory = 0;\n    let doneReading = false;\n    let bytesSent = 0;\n\n    // This must be outside the read loop, in case we reach the maxBytesInMemory and\n    // we exit the loop but some bytes are still to be sent on the next read invocation.\n    let arrayBuffers: ArrayBuffer[] = [];\n    let currentPartBytesRead = 0;\n\n    read().catch(cancel);\n\n    async function read(): Promise<void> {\n      debug(\n        'mpu: upload read start',\n        'activeUploads:',\n        activeUploads,\n        'currentBytesInMemory:',\n        `${bytes(currentBytesInMemory)}/${bytes(maxBytesInMemory)}`,\n        'bytesSent:',\n        bytes(bytesSent),\n      );\n\n      reading = true;\n\n      while (currentBytesInMemory < maxBytesInMemory && !rejected) {\n        try {\n          // eslint-disable-next-line no-await-in-loop -- A for loop is fine here.\n          const { value, done } = await reader.read();\n\n          if (done) {\n            doneReading = true;\n            debug('mpu: upload read consumed the whole stream');\n            // done is sent when the stream is fully consumed. That's why we're not using the value here.\n            if (arrayBuffers.length > 0) {\n              partsToUpload.push({\n                partNumber: currentPartNumber++,\n                blob: new Blob(arrayBuffers, {\n                  type: 'application/octet-stream',\n                }),\n              });\n\n              sendParts();\n            }\n            reading = false;\n            return;\n          }\n\n          currentBytesInMemory += value.byteLength;\n\n          // This code ensures that each part will be exactly of `partSizeInBytes` size\n          // Otherwise R2 will refuse it. AWS S3 is fine with parts of different sizes.\n          let valueOffset = 0;\n          while (valueOffset < value.byteLength) {\n            const remainingPartSize = partSizeInBytes - currentPartBytesRead;\n            const endOffset = Math.min(\n              valueOffset + remainingPartSize,\n              value.byteLength,\n            );\n\n            const chunk = value.slice(valueOffset, endOffset);\n\n            arrayBuffers.push(chunk);\n            currentPartBytesRead += chunk.byteLength;\n            valueOffset = endOffset;\n\n            if (currentPartBytesRead === partSizeInBytes) {\n              partsToUpload.push({\n                partNumber: currentPartNumber++,\n                blob: new Blob(arrayBuffers, {\n                  type: 'application/octet-stream',\n                }),\n              });\n\n              arrayBuffers = [];\n              currentPartBytesRead = 0;\n              sendParts();\n            }\n          }\n        } catch (error) {\n          cancel(error);\n        }\n      }\n\n      debug(\n        'mpu: upload read end',\n        'activeUploads:',\n        activeUploads,\n        'currentBytesInMemory:',\n        `${bytes(currentBytesInMemory)}/${bytes(maxBytesInMemory)}`,\n        'bytesSent:',\n        bytes(bytesSent),\n      );\n\n      reading = false;\n    }\n\n    async function sendPart(part: UploadPart): Promise<void> {\n      activeUploads++;\n\n      debug(\n        'mpu: upload send part start',\n        'partNumber:',\n        part.partNumber,\n        'size:',\n        part.blob.size,\n        'activeUploads:',\n        activeUploads,\n        'currentBytesInMemory:',\n        `${bytes(currentBytesInMemory)}/${bytes(maxBytesInMemory)}`,\n        'bytesSent:',\n        bytes(bytesSent),\n      );\n\n      try {\n        const completedPart = await requestApi<UploadPartApiResponse>(\n          `/mpu/${pathname}`,\n          {\n            signal: internalAbortController.signal,\n            method: 'POST',\n            headers: {\n              ...headers,\n              'x-mpu-action': 'upload',\n              'x-mpu-key': encodeURI(key),\n              'x-mpu-upload-id': uploadId,\n              'x-mpu-part-number': part.partNumber.toString(),\n            },\n            // weird things between undici types and native fetch types\n            body: part.blob as BodyInit,\n          },\n          options,\n        );\n\n        debug(\n          'mpu: upload send part end',\n          'partNumber:',\n          part.partNumber,\n          'activeUploads',\n          activeUploads,\n          'currentBytesInMemory:',\n          `${bytes(currentBytesInMemory)}/${bytes(maxBytesInMemory)}`,\n          'bytesSent:',\n          bytes(bytesSent),\n        );\n\n        if (rejected) {\n          return;\n        }\n\n        completedParts.push({\n          partNumber: part.partNumber,\n          etag: completedPart.etag,\n        });\n\n        currentBytesInMemory -= part.blob.size;\n        activeUploads--;\n        bytesSent += part.blob.size;\n\n        if (partsToUpload.length > 0) {\n          sendParts();\n        }\n\n        if (doneReading) {\n          if (activeUploads === 0) {\n            reader.releaseLock();\n            resolve(completedParts);\n          }\n          return;\n        }\n\n        if (!reading) {\n          read().catch(cancel);\n        }\n      } catch (error) {\n        cancel(error);\n      }\n    }\n\n    function sendParts(): void {\n      if (rejected) {\n        return;\n      }\n\n      debug(\n        'send parts',\n        'activeUploads',\n        activeUploads,\n        'partsToUpload',\n        partsToUpload.length,\n      );\n      while (activeUploads < maxConcurrentUploads && partsToUpload.length > 0) {\n        const partToSend = partsToUpload.shift();\n        if (partToSend) {\n          void sendPart(partToSend);\n        }\n      }\n    }\n\n    function cancel(error: unknown): void {\n      // a previous call already rejected the whole call, ignore\n      if (rejected) {\n        return;\n      }\n      rejected = true;\n      internalAbortController.abort();\n      reader.releaseLock();\n      if (\n        error instanceof TypeError &&\n        (error.message === 'Failed to fetch' ||\n          error.message === 'fetch failed')\n      ) {\n        reject(new BlobServiceNotAvailable());\n      } else {\n        reject(error);\n      }\n    }\n  });\n}\n\nfunction toReadableStream(value: PutBody): ReadableStream<ArrayBuffer> {\n  // Already a ReadableStream, nothing to do\n  if (value instanceof ReadableStream) {\n    return value as ReadableStream<ArrayBuffer>;\n  }\n\n  // In the case of a Blob or File (which inherits from Blob), we could use .slice() to create pointers\n  // to the original data instead of loading data in memory gradually.\n  // Here's an explanation on this subject: https://stackoverflow.com/a/24834417\n  if (value instanceof Blob) {\n    return value.stream();\n  }\n\n  if (isNodeJsReadableStream(value)) {\n    return Readable.toWeb(value) as ReadableStream<ArrayBuffer>;\n  }\n\n  const streamValue =\n    value instanceof ArrayBuffer ? value : stringToUint8Array(value);\n\n  // from https://github.com/sindresorhus/to-readable-stream/blob/main/index.js\n  return new ReadableStream<ArrayBuffer>({\n    start(controller) {\n      controller.enqueue(streamValue);\n      controller.close();\n    },\n  });\n}\n\n// From https://github.com/sindresorhus/is-stream/\nfunction isNodeJsReadableStream(value: PutBody): value is Readable {\n  return (\n    typeof value === 'object' &&\n    typeof (value as Readable).pipe === 'function' &&\n    (value as Readable).readable &&\n    typeof (value as Readable)._read === 'function' &&\n    // @ts-expect-error _readableState does exists on Readable\n    typeof value._readableState === 'object'\n  );\n}\n\nfunction stringToUint8Array(s: string): Uint8Array {\n  const enc = new TextEncoder();\n  return enc.encode(s);\n}\n","// eslint-disable-next-line unicorn/prefer-node-protocol -- node:stream does not resolve correctly in browser and edge\nimport type { Readable } from 'stream';\nimport type { BodyInit } from 'undici';\nimport { requestApi } from './api';\nimport type { ClientPutCommandOptions } from './client';\nimport type { CreateBlobCommandOptions } from './helpers';\nimport { BlobError } from './helpers';\nimport { multipartPut } from './put-multipart';\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface -- expose option interface for each API method for better extensibility in the future\nexport interface PutCommandOptions extends CreateBlobCommandOptions {}\n\nconst putOptionHeaderMap = {\n  cacheControlMaxAge: 'x-cache-control-max-age',\n  addRandomSuffix: 'x-add-random-suffix',\n  contentType: 'x-content-type',\n};\n\nexport interface PutBlobResult {\n  url: string;\n  pathname: string;\n  contentType: string;\n  contentDisposition: string;\n}\n\nexport type PutBlobApiResponse = PutBlobResult;\n\nexport type PutBody =\n  | string\n  | Readable // Node.js streams\n  | Blob\n  | ArrayBuffer\n  | ReadableStream // Streams API (= Web streams in Node.js)\n  | File;\n\ntype PartialBy<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;\n\nexport function createPutMethod<\n  T extends PartialBy<PutCommandOptions & ClientPutCommandOptions, 'token'>,\n>({\n  allowedOptions,\n  getToken,\n  extraChecks,\n}: {\n  allowedOptions: (keyof typeof putOptionHeaderMap)[];\n  getToken?: (pathname: string, options: T) => Promise<string>;\n  extraChecks?: (options: T) => void;\n}) {\n  return async function put<TPath extends string>(\n    pathname: TPath,\n    bodyOrOptions: TPath extends `${string}/` ? T : PutBody,\n    optionsInput?: T,\n  ): Promise<PutBlobResult> {\n    if (!pathname) {\n      throw new BlobError('pathname is required');\n    }\n\n    const isFolderCreation = pathname.endsWith('/');\n\n    // prevent empty bodies for files\n    if (!bodyOrOptions && !isFolderCreation) {\n      throw new BlobError('body is required');\n    }\n\n    // runtime check for non TS users that provide all three args\n    if (bodyOrOptions && optionsInput && isFolderCreation) {\n      throw new BlobError('body is not allowed for creating empty folders');\n    }\n\n    // avoid using the options as body\n    const body = isFolderCreation ? undefined : bodyOrOptions;\n\n    // when no body is required options are the second argument\n    const options = isFolderCreation ? (bodyOrOptions as T) : optionsInput;\n\n    if (!options) {\n      throw new BlobError('missing options, see usage');\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- Runtime check for DX.\n    if (options.access !== 'public') {\n      throw new BlobError('access must be \"public\"');\n    }\n\n    if (extraChecks) {\n      extraChecks(options);\n    }\n\n    if (getToken) {\n      options.token = await getToken(pathname, options);\n    }\n\n    const headers: Record<string, string> = {};\n\n    if (allowedOptions.includes('contentType') && options.contentType) {\n      headers['x-content-type'] = options.contentType;\n    }\n\n    if (\n      allowedOptions.includes('addRandomSuffix') &&\n      options.addRandomSuffix !== undefined\n    ) {\n      headers['x-add-random-suffix'] = options.addRandomSuffix ? '1' : '0';\n    }\n\n    if (\n      allowedOptions.includes('cacheControlMaxAge') &&\n      options.cacheControlMaxAge !== undefined\n    ) {\n      headers['x-cache-control-max-age'] =\n        options.cacheControlMaxAge.toString();\n    }\n\n    if (options.multipart === true && body) {\n      return multipartPut(pathname, body, headers, options);\n    }\n\n    return requestApi<PutBlobApiResponse>(\n      `/${pathname}`,\n      {\n        method: 'PUT',\n        body: body as BodyInit,\n        headers,\n        // required in order to stream some body types to Cloudflare\n        // currently only supported in Node.js, we may have to feature detect this\n        duplex: 'half',\n      },\n      options,\n    );\n  };\n}\n"],"mappings":";AAuCO,SAAS,yBAAyB,SAAsC;AAC7E,MAAI,mCAAS,OAAO;AAClB,WAAO,QAAQ;AAAA,EACjB;AAEA,MAAI,QAAQ,IAAI,uBAAuB;AACrC,WAAO,QAAQ,IAAI;AAAA,EACrB;AAEA,QAAM,IAAI;AAAA,IACR;AAAA,EACF;AACF;AAEO,IAAM,YAAN,cAAwB,MAAM;AAAA,EACnC,YAAY,SAAiB;AAC3B,UAAM,gBAAgB,OAAO,EAAE;AAAA,EACjC;AACF;;;ACxDA,SAAS,aAAa;AACtB,OAAO,WAAW;;;ACFlB,IAAI,gBAAgB;AAApB;AAGA,IAAI;AACF,QACE,aAAQ,IAAI,UAAZ,mBAAmB,SAAS,cAC5B,aAAQ,IAAI,sBAAZ,mBAA+B,SAAS,UACxC;AACA,oBAAgB;AAAA,EAClB;AACF,SAAS,OAAO;AAEhB;AAGO,SAAS,MAAM,YAAoB,MAAuB;AAC/D,MAAI,eAAe;AAEjB,YAAQ,MAAM,gBAAgB,OAAO,IAAI,GAAG,IAAI;AAAA,EAClD;AACF;;;ADbO,IAAM,kBAAN,cAA8B,UAAU;AAAA,EAC7C,cAAc;AACZ,UAAM,gEAAgE;AAAA,EACxE;AACF;AAEO,IAAM,yBAAN,cAAqC,UAAU;AAAA,EACpD,cAAc;AACZ,UAAM,4BAA4B;AAAA,EACpC;AACF;AAEO,IAAM,0BAAN,cAAsC,UAAU;AAAA,EACrD,cAAc;AACZ,UAAM,gCAAgC;AAAA,EACxC;AACF;AAEO,IAAM,mBAAN,cAA+B,UAAU;AAAA,EAC9C,cAAc;AACZ,UAAM,sDAAsD;AAAA,EAC9D;AACF;AAEO,IAAM,oBAAN,cAAgC,UAAU;AAAA,EAC/C,cAAc;AACZ,UAAM,mCAAmC;AAAA,EAC3C;AACF;AAEO,IAAM,0BAAN,cAAsC,UAAU;AAAA,EACrD,cAAc;AACZ,UAAM,gEAAgE;AAAA,EACxE;AACF;AAmBA,IAAM,mBAAmB;AAEzB,SAAS,gBAAwB;AAC/B,MAAI,kBAAkB;AACtB,MAAI;AAGF,sBACE,QAAQ,IAAI,oCACZ,QAAQ,IAAI;AAAA,EAChB,QAAQ;AAAA,EAER;AAEA,SAAO,GAAG,4CAAmB,gBAAgB;AAC/C;AAEA,SAAS,UAAU,WAAW,IAAY;AACxC,MAAI,UAAU;AACd,MAAI;AAGF,cACE,QAAQ,IAAI,uBACZ,QAAQ,IAAI;AAAA,EAChB,QAAQ;AAAA,EAER;AACA,SAAO,GAAG,WAAW,iCAAiC,GAAG,QAAQ;AACnE;AAEA,SAAS,aAAqB;AAC5B,MAAI;AACF,UAAM,UAAU,QAAQ,IAAI,uBAAuB;AAEnD,WAAO,SAAS,SAAS,EAAE;AAAA,EAC7B,QAAQ;AACN,WAAO;AAAA,EACT;AACF;AAGA,eAAe,gBACb,UAC4C;AAC5C,MAAI;AACF,UAAM,OAAO,MAAM,SAAS,KAAK;AAEjC,WAAQ,KAAsB;AAAA,EAChC,QAAQ;AACN,WAAO,EAAE,MAAM,gBAAgB;AAAA,EACjC;AACF;AAGA,SAAS,aAAa,OAAyC;AAnH/D,MAAAA;AAoHE,UAAQ,+BAAO,MAAM;AAAA,IACnB,KAAK;AACH,aAAO,IAAI,wBAAwB;AAAA,IACrC,KAAK;AACH,aAAO,IAAI,gBAAgB;AAAA,IAC7B,KAAK;AACH,aAAO,IAAI,kBAAkB;AAAA,IAC/B,KAAK;AACH,aAAO,IAAI,uBAAuB;AAAA,IACpC,KAAK;AACH,aAAO,IAAI,WAAUA,MAAA,MAAM,YAAN,OAAAA,MAAiB,aAAa;AAAA,IACrD,KAAK;AACH,aAAO,IAAI,wBAAwB;AAAA,IACrC,KAAK;AAAA,IACL,KAAK;AAAA,IACL;AACE,aAAO,IAAI,iBAAiB;AAAA,EAChC;AACF;AAEA,eAAsB,WACpB,UACA,MACA,gBACoB;AACpB,QAAM,aAAa,cAAc;AACjC,QAAM,QAAQ,yBAAyB,cAAc;AAErD,QAAM,cAAc,MAAM;AAAA,IACxB,OAAO,SAAS;AACd,YAAM,MAAM,MAAM,MAAM,UAAU,QAAQ,GAAG;AAAA,QAC3C,GAAG;AAAA,QACH,SAAS;AAAA,UACP,iBAAiB;AAAA,UACjB,eAAe,UAAU,KAAK;AAAA,UAE9B,GAAG,KAAK;AAAA,QACV;AAAA,MACF,CAAC;AAED,UAAI,IAAI,IAAI;AACV,eAAO;AAAA,MACT;AAEA,YAAM,WAAW,MAAM,gBAAgB,GAAG;AAC1C,YAAM,EAAE,KAAK,IAAI,8BAAY,CAAC;AAC9B,YAAM,QAAQ,aAAa,QAAQ;AAEnC,UAAI,SAAS,mBAAmB,SAAS,uBAAuB;AAE9D,cAAM;AAAA,MACR,OAAO;AAEL,aAAK,KAAK;AAAA,MACZ;AAAA,IACF;AAAA,IACA;AAAA,MACE,SAAS,WAAW;AAAA,MACpB,SAAS,CAAC,UAAU;AAClB,cAAM,2BAA2B,QAAQ,IAAI,MAAM,OAAO;AAAA,MAC5D;AAAA,IACF;AAAA,EACF;AAEA,MAAI,CAAC,aAAa;AAChB,UAAM,IAAI,iBAAiB;AAAA,EAC7B;AAEA,SAAQ,MAAM,YAAY,KAAK;AACjC;;;AExLA,SAAS,gBAAgB;AACzB,OAAO,WAAW;AASlB,IAAM,uBAAuB,OAAO,WAAW,cAAc,IAAI;AAGjE,IAAM,kBAAkB,IAAI,OAAO;AAEnC,IAAM,mBAAmB,uBAAuB,kBAAkB;AAWlE,eAAsB,aACpB,UACA,MACA,SACA,SACwB;AACxB,QAAM,aAAa,aAAa,UAAU,YAAY,OAAO;AAE7D,QAAM,SAAS,iBAAiB,IAAI;AAGpC,QAAM,gCAAgC,MAAM;AAAA,IAC1C;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAGA,QAAM,QAAQ,MAAM;AAAA,IAClB,8BAA8B;AAAA,IAC9B,8BAA8B;AAAA,IAC9B;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAGA,QAAM,OAAO,MAAM;AAAA,IACjB,8BAA8B;AAAA,IAC9B,8BAA8B;AAAA,IAC9B;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAEA,SAAO;AACT;AAEA,eAAe,wBACb,UACA,KACA,UACA,OACA,SACA,SACwB;AACxB,MAAI;AACF,UAAM,WAAW,MAAM;AAAA,MACrB,QAAQ,QAAQ;AAAA,MAChB;AAAA,QACE,QAAQ;AAAA,QACR,SAAS;AAAA,UACP,GAAG;AAAA,UACH,gBAAgB;AAAA,UAChB,gBAAgB;AAAA,UAChB,mBAAmB;AAAA;AAAA;AAAA,UAGnB,aAAa,UAAU,GAAG;AAAA,QAC5B;AAAA,QACA,MAAM,KAAK,UAAU,KAAK;AAAA,MAC5B;AAAA,MACA;AAAA,IACF;AAEA,UAAM,iBAAiB,QAAQ;AAE/B,WAAO;AAAA,EACT,SAAS,OAAgB;AACvB,QACE,iBAAiB,cAChB,MAAM,YAAY,qBAAqB,MAAM,YAAY,iBAC1D;AACA,YAAM,IAAI,wBAAwB;AAAA,IACpC,OAAO;AACL,YAAM;AAAA,IACR;AAAA,EACF;AACF;AAEA,eAAe,sBACb,UACA,SACA,SAC2C;AAC3C,QAAM,eAAe,aAAa,QAAQ;AAE1C,MAAI;AACF,UAAM,WAAW,MAAM;AAAA,MACrB,QAAQ,QAAQ;AAAA,MAChB;AAAA,QACE,QAAQ;AAAA,QACR,SAAS;AAAA,UACP,GAAG;AAAA,UACH,gBAAgB;AAAA,QAClB;AAAA,MACF;AAAA,MACA;AAAA,IACF;AAEA,UAAM,eAAe,QAAQ;AAE7B,WAAO;AAAA,EACT,SAAS,OAAgB;AACvB,QACE,iBAAiB,cAChB,MAAM,YAAY,qBAAqB,MAAM,YAAY,iBAC1D;AACA,YAAM,IAAI,wBAAwB;AAAA,IACpC,OAAO;AACL,YAAM;AAAA,IACR;AAAA,EACF;AACF;AAaA,SAAS,YACP,UACA,KACA,UACA,QACA,SACA,SAC0B;AAC1B,QAAM,oBAAoB,QAAQ,GAAG;AACrC,QAAM,0BAA0B,IAAI,gBAAgB;AAEpD,SAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACtC,UAAM,gBAA8B,CAAC;AACrC,UAAM,iBAAkC,CAAC;AACzC,UAAM,SAAS,OAAO,UAAU;AAChC,QAAI,gBAAgB;AACpB,QAAI,UAAU;AACd,QAAI,oBAAoB;AAExB,QAAI,WAAW;AACf,QAAI,uBAAuB;AAC3B,QAAI,cAAc;AAClB,QAAI,YAAY;AAIhB,QAAI,eAA8B,CAAC;AACnC,QAAI,uBAAuB;AAE3B,SAAK,EAAE,MAAM,MAAM;AAEnB,mBAAe,OAAsB;AACnC;AAAA,QACE;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA,GAAG,MAAM,oBAAoB,CAAC,IAAI,MAAM,gBAAgB,CAAC;AAAA,QACzD;AAAA,QACA,MAAM,SAAS;AAAA,MACjB;AAEA,gBAAU;AAEV,aAAO,uBAAuB,oBAAoB,CAAC,UAAU;AAC3D,YAAI;AAEF,gBAAM,EAAE,OAAO,KAAK,IAAI,MAAM,OAAO,KAAK;AAE1C,cAAI,MAAM;AACR,0BAAc;AACd,kBAAM,4CAA4C;AAElD,gBAAI,aAAa,SAAS,GAAG;AAC3B,4BAAc,KAAK;AAAA,gBACjB,YAAY;AAAA,gBACZ,MAAM,IAAI,KAAK,cAAc;AAAA,kBAC3B,MAAM;AAAA,gBACR,CAAC;AAAA,cACH,CAAC;AAED,wBAAU;AAAA,YACZ;AACA,sBAAU;AACV;AAAA,UACF;AAEA,kCAAwB,MAAM;AAI9B,cAAI,cAAc;AAClB,iBAAO,cAAc,MAAM,YAAY;AACrC,kBAAM,oBAAoB,kBAAkB;AAC5C,kBAAM,YAAY,KAAK;AAAA,cACrB,cAAc;AAAA,cACd,MAAM;AAAA,YACR;AAEA,kBAAM,QAAQ,MAAM,MAAM,aAAa,SAAS;AAEhD,yBAAa,KAAK,KAAK;AACvB,oCAAwB,MAAM;AAC9B,0BAAc;AAEd,gBAAI,yBAAyB,iBAAiB;AAC5C,4BAAc,KAAK;AAAA,gBACjB,YAAY;AAAA,gBACZ,MAAM,IAAI,KAAK,cAAc;AAAA,kBAC3B,MAAM;AAAA,gBACR,CAAC;AAAA,cACH,CAAC;AAED,6BAAe,CAAC;AAChB,qCAAuB;AACvB,wBAAU;AAAA,YACZ;AAAA,UACF;AAAA,QACF,SAAS,OAAO;AACd,iBAAO,KAAK;AAAA,QACd;AAAA,MACF;AAEA;AAAA,QACE;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA,GAAG,MAAM,oBAAoB,CAAC,IAAI,MAAM,gBAAgB,CAAC;AAAA,QACzD;AAAA,QACA,MAAM,SAAS;AAAA,MACjB;AAEA,gBAAU;AAAA,IACZ;AAEA,mBAAe,SAAS,MAAiC;AACvD;AAEA;AAAA,QACE;AAAA,QACA;AAAA,QACA,KAAK;AAAA,QACL;AAAA,QACA,KAAK,KAAK;AAAA,QACV;AAAA,QACA;AAAA,QACA;AAAA,QACA,GAAG,MAAM,oBAAoB,CAAC,IAAI,MAAM,gBAAgB,CAAC;AAAA,QACzD;AAAA,QACA,MAAM,SAAS;AAAA,MACjB;AAEA,UAAI;AACF,cAAM,gBAAgB,MAAM;AAAA,UAC1B,QAAQ,QAAQ;AAAA,UAChB;AAAA,YACE,QAAQ,wBAAwB;AAAA,YAChC,QAAQ;AAAA,YACR,SAAS;AAAA,cACP,GAAG;AAAA,cACH,gBAAgB;AAAA,cAChB,aAAa,UAAU,GAAG;AAAA,cAC1B,mBAAmB;AAAA,cACnB,qBAAqB,KAAK,WAAW,SAAS;AAAA,YAChD;AAAA;AAAA,YAEA,MAAM,KAAK;AAAA,UACb;AAAA,UACA;AAAA,QACF;AAEA;AAAA,UACE;AAAA,UACA;AAAA,UACA,KAAK;AAAA,UACL;AAAA,UACA;AAAA,UACA;AAAA,UACA,GAAG,MAAM,oBAAoB,CAAC,IAAI,MAAM,gBAAgB,CAAC;AAAA,UACzD;AAAA,UACA,MAAM,SAAS;AAAA,QACjB;AAEA,YAAI,UAAU;AACZ;AAAA,QACF;AAEA,uBAAe,KAAK;AAAA,UAClB,YAAY,KAAK;AAAA,UACjB,MAAM,cAAc;AAAA,QACtB,CAAC;AAED,gCAAwB,KAAK,KAAK;AAClC;AACA,qBAAa,KAAK,KAAK;AAEvB,YAAI,cAAc,SAAS,GAAG;AAC5B,oBAAU;AAAA,QACZ;AAEA,YAAI,aAAa;AACf,cAAI,kBAAkB,GAAG;AACvB,mBAAO,YAAY;AACnB,oBAAQ,cAAc;AAAA,UACxB;AACA;AAAA,QACF;AAEA,YAAI,CAAC,SAAS;AACZ,eAAK,EAAE,MAAM,MAAM;AAAA,QACrB;AAAA,MACF,SAAS,OAAO;AACd,eAAO,KAAK;AAAA,MACd;AAAA,IACF;AAEA,aAAS,YAAkB;AACzB,UAAI,UAAU;AACZ;AAAA,MACF;AAEA;AAAA,QACE;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA,cAAc;AAAA,MAChB;AACA,aAAO,gBAAgB,wBAAwB,cAAc,SAAS,GAAG;AACvE,cAAM,aAAa,cAAc,MAAM;AACvC,YAAI,YAAY;AACd,eAAK,SAAS,UAAU;AAAA,QAC1B;AAAA,MACF;AAAA,IACF;AAEA,aAAS,OAAO,OAAsB;AAEpC,UAAI,UAAU;AACZ;AAAA,MACF;AACA,iBAAW;AACX,8BAAwB,MAAM;AAC9B,aAAO,YAAY;AACnB,UACE,iBAAiB,cAChB,MAAM,YAAY,qBACjB,MAAM,YAAY,iBACpB;AACA,eAAO,IAAI,wBAAwB,CAAC;AAAA,MACtC,OAAO;AACL,eAAO,KAAK;AAAA,MACd;AAAA,IACF;AAAA,EACF,CAAC;AACH;AAEA,SAAS,iBAAiB,OAA6C;AAErE,MAAI,iBAAiB,gBAAgB;AACnC,WAAO;AAAA,EACT;AAKA,MAAI,iBAAiB,MAAM;AACzB,WAAO,MAAM,OAAO;AAAA,EACtB;AAEA,MAAI,uBAAuB,KAAK,GAAG;AACjC,WAAO,SAAS,MAAM,KAAK;AAAA,EAC7B;AAEA,QAAM,cACJ,iBAAiB,cAAc,QAAQ,mBAAmB,KAAK;AAGjE,SAAO,IAAI,eAA4B;AAAA,IACrC,MAAM,YAAY;AAChB,iBAAW,QAAQ,WAAW;AAC9B,iBAAW,MAAM;AAAA,IACnB;AAAA,EACF,CAAC;AACH;AAGA,SAAS,uBAAuB,OAAmC;AACjE,SACE,OAAO,UAAU,YACjB,OAAQ,MAAmB,SAAS,cACnC,MAAmB,YACpB,OAAQ,MAAmB,UAAU;AAAA,EAErC,OAAO,MAAM,mBAAmB;AAEpC;AAEA,SAAS,mBAAmB,GAAuB;AACjD,QAAM,MAAM,IAAI,YAAY;AAC5B,SAAO,IAAI,OAAO,CAAC;AACrB;;;AChZO,SAAS,gBAEd;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,GAIG;AACD,SAAO,eAAe,IACpB,UACA,eACA,cACwB;AACxB,QAAI,CAAC,UAAU;AACb,YAAM,IAAI,UAAU,sBAAsB;AAAA,IAC5C;AAEA,UAAM,mBAAmB,SAAS,SAAS,GAAG;AAG9C,QAAI,CAAC,iBAAiB,CAAC,kBAAkB;AACvC,YAAM,IAAI,UAAU,kBAAkB;AAAA,IACxC;AAGA,QAAI,iBAAiB,gBAAgB,kBAAkB;AACrD,YAAM,IAAI,UAAU,gDAAgD;AAAA,IACtE;AAGA,UAAM,OAAO,mBAAmB,SAAY;AAG5C,UAAM,UAAU,mBAAoB,gBAAsB;AAE1D,QAAI,CAAC,SAAS;AACZ,YAAM,IAAI,UAAU,4BAA4B;AAAA,IAClD;AAGA,QAAI,QAAQ,WAAW,UAAU;AAC/B,YAAM,IAAI,UAAU,yBAAyB;AAAA,IAC/C;AAEA,QAAI,aAAa;AACf,kBAAY,OAAO;AAAA,IACrB;AAEA,QAAI,UAAU;AACZ,cAAQ,QAAQ,MAAM,SAAS,UAAU,OAAO;AAAA,IAClD;AAEA,UAAM,UAAkC,CAAC;AAEzC,QAAI,eAAe,SAAS,aAAa,KAAK,QAAQ,aAAa;AACjE,cAAQ,gBAAgB,IAAI,QAAQ;AAAA,IACtC;AAEA,QACE,eAAe,SAAS,iBAAiB,KACzC,QAAQ,oBAAoB,QAC5B;AACA,cAAQ,qBAAqB,IAAI,QAAQ,kBAAkB,MAAM;AAAA,IACnE;AAEA,QACE,eAAe,SAAS,oBAAoB,KAC5C,QAAQ,uBAAuB,QAC/B;AACA,cAAQ,yBAAyB,IAC/B,QAAQ,mBAAmB,SAAS;AAAA,IACxC;AAEA,QAAI,QAAQ,cAAc,QAAQ,MAAM;AACtC,aAAO,aAAa,UAAU,MAAM,SAAS,OAAO;AAAA,IACtD;AAEA,WAAO;AAAA,MACL,IAAI,QAAQ;AAAA,MACZ;AAAA,QACE,QAAQ;AAAA,QACR;AAAA,QACA;AAAA;AAAA;AAAA,QAGA,QAAQ;AAAA,MACV;AAAA,MACA;AAAA,IACF;AAAA,EACF;AACF;","names":["_a"]}