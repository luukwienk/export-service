
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Woonplaats
 * 
 */
export type Woonplaats = $Result.DefaultSelection<Prisma.$WoonplaatsPayload>
/**
 * Model OpenbareRuimte
 * 
 */
export type OpenbareRuimte = $Result.DefaultSelection<Prisma.$OpenbareRuimtePayload>
/**
 * Model Pand
 * 
 */
export type Pand = $Result.DefaultSelection<Prisma.$PandPayload>
/**
 * Model Nummeraanduiding
 * 
 */
export type Nummeraanduiding = $Result.DefaultSelection<Prisma.$NummeraanduidingPayload>
/**
 * Model Verblijfsobject
 * 
 */
export type Verblijfsobject = $Result.DefaultSelection<Prisma.$VerblijfsobjectPayload>
/**
 * Model spatial_ref_sys
 * 
 */
export type spatial_ref_sys = $Result.DefaultSelection<Prisma.$spatial_ref_sysPayload>
/**
 * Model ImportJob
 * 
 */
export type ImportJob = $Result.DefaultSelection<Prisma.$ImportJobPayload>
/**
 * Model NummeraanduidingStaging
 * 
 */
export type NummeraanduidingStaging = $Result.DefaultSelection<Prisma.$NummeraanduidingStagingPayload>
/**
 * Model Ligplaats
 * 
 */
export type Ligplaats = $Result.DefaultSelection<Prisma.$LigplaatsPayload>
/**
 * Model Standplaats
 * 
 */
export type Standplaats = $Result.DefaultSelection<Prisma.$StandplaatsPayload>
/**
 * Model StatisticsCache
 * 
 */
export type StatisticsCache = $Result.DefaultSelection<Prisma.$StatisticsCachePayload>
/**
 * Model AddressCache
 * 
 */
export type AddressCache = $Result.DefaultSelection<Prisma.$AddressCachePayload>
/**
 * Model ExportJob
 * 
 */
export type ExportJob = $Result.DefaultSelection<Prisma.$ExportJobPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Woonplaats
 * const woonplaats = await prisma.woonplaats.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Woonplaats
   * const woonplaats = await prisma.woonplaats.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.woonplaats`: Exposes CRUD operations for the **Woonplaats** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Woonplaats
    * const woonplaats = await prisma.woonplaats.findMany()
    * ```
    */
  get woonplaats(): Prisma.WoonplaatsDelegate<ExtArgs>;

  /**
   * `prisma.openbareRuimte`: Exposes CRUD operations for the **OpenbareRuimte** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OpenbareRuimtes
    * const openbareRuimtes = await prisma.openbareRuimte.findMany()
    * ```
    */
  get openbareRuimte(): Prisma.OpenbareRuimteDelegate<ExtArgs>;

  /**
   * `prisma.pand`: Exposes CRUD operations for the **Pand** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pands
    * const pands = await prisma.pand.findMany()
    * ```
    */
  get pand(): Prisma.PandDelegate<ExtArgs>;

  /**
   * `prisma.nummeraanduiding`: Exposes CRUD operations for the **Nummeraanduiding** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Nummeraanduidings
    * const nummeraanduidings = await prisma.nummeraanduiding.findMany()
    * ```
    */
  get nummeraanduiding(): Prisma.NummeraanduidingDelegate<ExtArgs>;

  /**
   * `prisma.verblijfsobject`: Exposes CRUD operations for the **Verblijfsobject** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Verblijfsobjects
    * const verblijfsobjects = await prisma.verblijfsobject.findMany()
    * ```
    */
  get verblijfsobject(): Prisma.VerblijfsobjectDelegate<ExtArgs>;

  /**
   * `prisma.spatial_ref_sys`: Exposes CRUD operations for the **spatial_ref_sys** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Spatial_ref_sys
    * const spatial_ref_sys = await prisma.spatial_ref_sys.findMany()
    * ```
    */
  get spatial_ref_sys(): Prisma.spatial_ref_sysDelegate<ExtArgs>;

  /**
   * `prisma.importJob`: Exposes CRUD operations for the **ImportJob** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ImportJobs
    * const importJobs = await prisma.importJob.findMany()
    * ```
    */
  get importJob(): Prisma.ImportJobDelegate<ExtArgs>;

  /**
   * `prisma.nummeraanduidingStaging`: Exposes CRUD operations for the **NummeraanduidingStaging** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NummeraanduidingStagings
    * const nummeraanduidingStagings = await prisma.nummeraanduidingStaging.findMany()
    * ```
    */
  get nummeraanduidingStaging(): Prisma.NummeraanduidingStagingDelegate<ExtArgs>;

  /**
   * `prisma.ligplaats`: Exposes CRUD operations for the **Ligplaats** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ligplaats
    * const ligplaats = await prisma.ligplaats.findMany()
    * ```
    */
  get ligplaats(): Prisma.LigplaatsDelegate<ExtArgs>;

  /**
   * `prisma.standplaats`: Exposes CRUD operations for the **Standplaats** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Standplaats
    * const standplaats = await prisma.standplaats.findMany()
    * ```
    */
  get standplaats(): Prisma.StandplaatsDelegate<ExtArgs>;

  /**
   * `prisma.statisticsCache`: Exposes CRUD operations for the **StatisticsCache** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StatisticsCaches
    * const statisticsCaches = await prisma.statisticsCache.findMany()
    * ```
    */
  get statisticsCache(): Prisma.StatisticsCacheDelegate<ExtArgs>;

  /**
   * `prisma.addressCache`: Exposes CRUD operations for the **AddressCache** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AddressCaches
    * const addressCaches = await prisma.addressCache.findMany()
    * ```
    */
  get addressCache(): Prisma.AddressCacheDelegate<ExtArgs>;

  /**
   * `prisma.exportJob`: Exposes CRUD operations for the **ExportJob** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExportJobs
    * const exportJobs = await prisma.exportJob.findMany()
    * ```
    */
  get exportJob(): Prisma.ExportJobDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Woonplaats: 'Woonplaats',
    OpenbareRuimte: 'OpenbareRuimte',
    Pand: 'Pand',
    Nummeraanduiding: 'Nummeraanduiding',
    Verblijfsobject: 'Verblijfsobject',
    spatial_ref_sys: 'spatial_ref_sys',
    ImportJob: 'ImportJob',
    NummeraanduidingStaging: 'NummeraanduidingStaging',
    Ligplaats: 'Ligplaats',
    Standplaats: 'Standplaats',
    StatisticsCache: 'StatisticsCache',
    AddressCache: 'AddressCache',
    ExportJob: 'ExportJob'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "woonplaats" | "openbareRuimte" | "pand" | "nummeraanduiding" | "verblijfsobject" | "spatial_ref_sys" | "importJob" | "nummeraanduidingStaging" | "ligplaats" | "standplaats" | "statisticsCache" | "addressCache" | "exportJob"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Woonplaats: {
        payload: Prisma.$WoonplaatsPayload<ExtArgs>
        fields: Prisma.WoonplaatsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WoonplaatsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WoonplaatsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WoonplaatsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WoonplaatsPayload>
          }
          findFirst: {
            args: Prisma.WoonplaatsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WoonplaatsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WoonplaatsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WoonplaatsPayload>
          }
          findMany: {
            args: Prisma.WoonplaatsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WoonplaatsPayload>[]
          }
          create: {
            args: Prisma.WoonplaatsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WoonplaatsPayload>
          }
          createMany: {
            args: Prisma.WoonplaatsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WoonplaatsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WoonplaatsPayload>[]
          }
          delete: {
            args: Prisma.WoonplaatsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WoonplaatsPayload>
          }
          update: {
            args: Prisma.WoonplaatsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WoonplaatsPayload>
          }
          deleteMany: {
            args: Prisma.WoonplaatsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WoonplaatsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WoonplaatsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WoonplaatsPayload>
          }
          aggregate: {
            args: Prisma.WoonplaatsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWoonplaats>
          }
          groupBy: {
            args: Prisma.WoonplaatsGroupByArgs<ExtArgs>
            result: $Utils.Optional<WoonplaatsGroupByOutputType>[]
          }
          count: {
            args: Prisma.WoonplaatsCountArgs<ExtArgs>
            result: $Utils.Optional<WoonplaatsCountAggregateOutputType> | number
          }
        }
      }
      OpenbareRuimte: {
        payload: Prisma.$OpenbareRuimtePayload<ExtArgs>
        fields: Prisma.OpenbareRuimteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OpenbareRuimteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenbareRuimtePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OpenbareRuimteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenbareRuimtePayload>
          }
          findFirst: {
            args: Prisma.OpenbareRuimteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenbareRuimtePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OpenbareRuimteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenbareRuimtePayload>
          }
          findMany: {
            args: Prisma.OpenbareRuimteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenbareRuimtePayload>[]
          }
          create: {
            args: Prisma.OpenbareRuimteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenbareRuimtePayload>
          }
          createMany: {
            args: Prisma.OpenbareRuimteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OpenbareRuimteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenbareRuimtePayload>[]
          }
          delete: {
            args: Prisma.OpenbareRuimteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenbareRuimtePayload>
          }
          update: {
            args: Prisma.OpenbareRuimteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenbareRuimtePayload>
          }
          deleteMany: {
            args: Prisma.OpenbareRuimteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OpenbareRuimteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OpenbareRuimteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenbareRuimtePayload>
          }
          aggregate: {
            args: Prisma.OpenbareRuimteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOpenbareRuimte>
          }
          groupBy: {
            args: Prisma.OpenbareRuimteGroupByArgs<ExtArgs>
            result: $Utils.Optional<OpenbareRuimteGroupByOutputType>[]
          }
          count: {
            args: Prisma.OpenbareRuimteCountArgs<ExtArgs>
            result: $Utils.Optional<OpenbareRuimteCountAggregateOutputType> | number
          }
        }
      }
      Pand: {
        payload: Prisma.$PandPayload<ExtArgs>
        fields: Prisma.PandFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PandFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PandPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PandFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PandPayload>
          }
          findFirst: {
            args: Prisma.PandFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PandPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PandFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PandPayload>
          }
          findMany: {
            args: Prisma.PandFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PandPayload>[]
          }
          create: {
            args: Prisma.PandCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PandPayload>
          }
          createMany: {
            args: Prisma.PandCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PandCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PandPayload>[]
          }
          delete: {
            args: Prisma.PandDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PandPayload>
          }
          update: {
            args: Prisma.PandUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PandPayload>
          }
          deleteMany: {
            args: Prisma.PandDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PandUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PandUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PandPayload>
          }
          aggregate: {
            args: Prisma.PandAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePand>
          }
          groupBy: {
            args: Prisma.PandGroupByArgs<ExtArgs>
            result: $Utils.Optional<PandGroupByOutputType>[]
          }
          count: {
            args: Prisma.PandCountArgs<ExtArgs>
            result: $Utils.Optional<PandCountAggregateOutputType> | number
          }
        }
      }
      Nummeraanduiding: {
        payload: Prisma.$NummeraanduidingPayload<ExtArgs>
        fields: Prisma.NummeraanduidingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NummeraanduidingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NummeraanduidingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NummeraanduidingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NummeraanduidingPayload>
          }
          findFirst: {
            args: Prisma.NummeraanduidingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NummeraanduidingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NummeraanduidingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NummeraanduidingPayload>
          }
          findMany: {
            args: Prisma.NummeraanduidingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NummeraanduidingPayload>[]
          }
          create: {
            args: Prisma.NummeraanduidingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NummeraanduidingPayload>
          }
          createMany: {
            args: Prisma.NummeraanduidingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NummeraanduidingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NummeraanduidingPayload>[]
          }
          delete: {
            args: Prisma.NummeraanduidingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NummeraanduidingPayload>
          }
          update: {
            args: Prisma.NummeraanduidingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NummeraanduidingPayload>
          }
          deleteMany: {
            args: Prisma.NummeraanduidingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NummeraanduidingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NummeraanduidingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NummeraanduidingPayload>
          }
          aggregate: {
            args: Prisma.NummeraanduidingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNummeraanduiding>
          }
          groupBy: {
            args: Prisma.NummeraanduidingGroupByArgs<ExtArgs>
            result: $Utils.Optional<NummeraanduidingGroupByOutputType>[]
          }
          count: {
            args: Prisma.NummeraanduidingCountArgs<ExtArgs>
            result: $Utils.Optional<NummeraanduidingCountAggregateOutputType> | number
          }
        }
      }
      Verblijfsobject: {
        payload: Prisma.$VerblijfsobjectPayload<ExtArgs>
        fields: Prisma.VerblijfsobjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerblijfsobjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerblijfsobjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerblijfsobjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerblijfsobjectPayload>
          }
          findFirst: {
            args: Prisma.VerblijfsobjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerblijfsobjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerblijfsobjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerblijfsobjectPayload>
          }
          findMany: {
            args: Prisma.VerblijfsobjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerblijfsobjectPayload>[]
          }
          create: {
            args: Prisma.VerblijfsobjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerblijfsobjectPayload>
          }
          createMany: {
            args: Prisma.VerblijfsobjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerblijfsobjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerblijfsobjectPayload>[]
          }
          delete: {
            args: Prisma.VerblijfsobjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerblijfsobjectPayload>
          }
          update: {
            args: Prisma.VerblijfsobjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerblijfsobjectPayload>
          }
          deleteMany: {
            args: Prisma.VerblijfsobjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerblijfsobjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VerblijfsobjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerblijfsobjectPayload>
          }
          aggregate: {
            args: Prisma.VerblijfsobjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerblijfsobject>
          }
          groupBy: {
            args: Prisma.VerblijfsobjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerblijfsobjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerblijfsobjectCountArgs<ExtArgs>
            result: $Utils.Optional<VerblijfsobjectCountAggregateOutputType> | number
          }
        }
      }
      spatial_ref_sys: {
        payload: Prisma.$spatial_ref_sysPayload<ExtArgs>
        fields: Prisma.spatial_ref_sysFieldRefs
        operations: {
          findUnique: {
            args: Prisma.spatial_ref_sysFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$spatial_ref_sysPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.spatial_ref_sysFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$spatial_ref_sysPayload>
          }
          findFirst: {
            args: Prisma.spatial_ref_sysFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$spatial_ref_sysPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.spatial_ref_sysFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$spatial_ref_sysPayload>
          }
          findMany: {
            args: Prisma.spatial_ref_sysFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$spatial_ref_sysPayload>[]
          }
          create: {
            args: Prisma.spatial_ref_sysCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$spatial_ref_sysPayload>
          }
          createMany: {
            args: Prisma.spatial_ref_sysCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.spatial_ref_sysCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$spatial_ref_sysPayload>[]
          }
          delete: {
            args: Prisma.spatial_ref_sysDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$spatial_ref_sysPayload>
          }
          update: {
            args: Prisma.spatial_ref_sysUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$spatial_ref_sysPayload>
          }
          deleteMany: {
            args: Prisma.spatial_ref_sysDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.spatial_ref_sysUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.spatial_ref_sysUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$spatial_ref_sysPayload>
          }
          aggregate: {
            args: Prisma.Spatial_ref_sysAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSpatial_ref_sys>
          }
          groupBy: {
            args: Prisma.spatial_ref_sysGroupByArgs<ExtArgs>
            result: $Utils.Optional<Spatial_ref_sysGroupByOutputType>[]
          }
          count: {
            args: Prisma.spatial_ref_sysCountArgs<ExtArgs>
            result: $Utils.Optional<Spatial_ref_sysCountAggregateOutputType> | number
          }
        }
      }
      ImportJob: {
        payload: Prisma.$ImportJobPayload<ExtArgs>
        fields: Prisma.ImportJobFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ImportJobFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportJobPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ImportJobFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportJobPayload>
          }
          findFirst: {
            args: Prisma.ImportJobFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportJobPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ImportJobFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportJobPayload>
          }
          findMany: {
            args: Prisma.ImportJobFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportJobPayload>[]
          }
          create: {
            args: Prisma.ImportJobCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportJobPayload>
          }
          createMany: {
            args: Prisma.ImportJobCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ImportJobCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportJobPayload>[]
          }
          delete: {
            args: Prisma.ImportJobDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportJobPayload>
          }
          update: {
            args: Prisma.ImportJobUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportJobPayload>
          }
          deleteMany: {
            args: Prisma.ImportJobDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ImportJobUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ImportJobUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportJobPayload>
          }
          aggregate: {
            args: Prisma.ImportJobAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateImportJob>
          }
          groupBy: {
            args: Prisma.ImportJobGroupByArgs<ExtArgs>
            result: $Utils.Optional<ImportJobGroupByOutputType>[]
          }
          count: {
            args: Prisma.ImportJobCountArgs<ExtArgs>
            result: $Utils.Optional<ImportJobCountAggregateOutputType> | number
          }
        }
      }
      NummeraanduidingStaging: {
        payload: Prisma.$NummeraanduidingStagingPayload<ExtArgs>
        fields: Prisma.NummeraanduidingStagingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NummeraanduidingStagingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NummeraanduidingStagingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NummeraanduidingStagingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NummeraanduidingStagingPayload>
          }
          findFirst: {
            args: Prisma.NummeraanduidingStagingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NummeraanduidingStagingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NummeraanduidingStagingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NummeraanduidingStagingPayload>
          }
          findMany: {
            args: Prisma.NummeraanduidingStagingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NummeraanduidingStagingPayload>[]
          }
          create: {
            args: Prisma.NummeraanduidingStagingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NummeraanduidingStagingPayload>
          }
          createMany: {
            args: Prisma.NummeraanduidingStagingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NummeraanduidingStagingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NummeraanduidingStagingPayload>[]
          }
          delete: {
            args: Prisma.NummeraanduidingStagingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NummeraanduidingStagingPayload>
          }
          update: {
            args: Prisma.NummeraanduidingStagingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NummeraanduidingStagingPayload>
          }
          deleteMany: {
            args: Prisma.NummeraanduidingStagingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NummeraanduidingStagingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NummeraanduidingStagingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NummeraanduidingStagingPayload>
          }
          aggregate: {
            args: Prisma.NummeraanduidingStagingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNummeraanduidingStaging>
          }
          groupBy: {
            args: Prisma.NummeraanduidingStagingGroupByArgs<ExtArgs>
            result: $Utils.Optional<NummeraanduidingStagingGroupByOutputType>[]
          }
          count: {
            args: Prisma.NummeraanduidingStagingCountArgs<ExtArgs>
            result: $Utils.Optional<NummeraanduidingStagingCountAggregateOutputType> | number
          }
        }
      }
      Ligplaats: {
        payload: Prisma.$LigplaatsPayload<ExtArgs>
        fields: Prisma.LigplaatsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LigplaatsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigplaatsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LigplaatsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigplaatsPayload>
          }
          findFirst: {
            args: Prisma.LigplaatsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigplaatsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LigplaatsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigplaatsPayload>
          }
          findMany: {
            args: Prisma.LigplaatsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigplaatsPayload>[]
          }
          create: {
            args: Prisma.LigplaatsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigplaatsPayload>
          }
          createMany: {
            args: Prisma.LigplaatsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LigplaatsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigplaatsPayload>[]
          }
          delete: {
            args: Prisma.LigplaatsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigplaatsPayload>
          }
          update: {
            args: Prisma.LigplaatsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigplaatsPayload>
          }
          deleteMany: {
            args: Prisma.LigplaatsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LigplaatsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LigplaatsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigplaatsPayload>
          }
          aggregate: {
            args: Prisma.LigplaatsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLigplaats>
          }
          groupBy: {
            args: Prisma.LigplaatsGroupByArgs<ExtArgs>
            result: $Utils.Optional<LigplaatsGroupByOutputType>[]
          }
          count: {
            args: Prisma.LigplaatsCountArgs<ExtArgs>
            result: $Utils.Optional<LigplaatsCountAggregateOutputType> | number
          }
        }
      }
      Standplaats: {
        payload: Prisma.$StandplaatsPayload<ExtArgs>
        fields: Prisma.StandplaatsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StandplaatsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandplaatsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StandplaatsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandplaatsPayload>
          }
          findFirst: {
            args: Prisma.StandplaatsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandplaatsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StandplaatsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandplaatsPayload>
          }
          findMany: {
            args: Prisma.StandplaatsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandplaatsPayload>[]
          }
          create: {
            args: Prisma.StandplaatsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandplaatsPayload>
          }
          createMany: {
            args: Prisma.StandplaatsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StandplaatsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandplaatsPayload>[]
          }
          delete: {
            args: Prisma.StandplaatsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandplaatsPayload>
          }
          update: {
            args: Prisma.StandplaatsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandplaatsPayload>
          }
          deleteMany: {
            args: Prisma.StandplaatsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StandplaatsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StandplaatsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandplaatsPayload>
          }
          aggregate: {
            args: Prisma.StandplaatsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStandplaats>
          }
          groupBy: {
            args: Prisma.StandplaatsGroupByArgs<ExtArgs>
            result: $Utils.Optional<StandplaatsGroupByOutputType>[]
          }
          count: {
            args: Prisma.StandplaatsCountArgs<ExtArgs>
            result: $Utils.Optional<StandplaatsCountAggregateOutputType> | number
          }
        }
      }
      StatisticsCache: {
        payload: Prisma.$StatisticsCachePayload<ExtArgs>
        fields: Prisma.StatisticsCacheFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StatisticsCacheFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatisticsCachePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StatisticsCacheFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatisticsCachePayload>
          }
          findFirst: {
            args: Prisma.StatisticsCacheFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatisticsCachePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StatisticsCacheFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatisticsCachePayload>
          }
          findMany: {
            args: Prisma.StatisticsCacheFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatisticsCachePayload>[]
          }
          create: {
            args: Prisma.StatisticsCacheCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatisticsCachePayload>
          }
          createMany: {
            args: Prisma.StatisticsCacheCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StatisticsCacheCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatisticsCachePayload>[]
          }
          delete: {
            args: Prisma.StatisticsCacheDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatisticsCachePayload>
          }
          update: {
            args: Prisma.StatisticsCacheUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatisticsCachePayload>
          }
          deleteMany: {
            args: Prisma.StatisticsCacheDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StatisticsCacheUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StatisticsCacheUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatisticsCachePayload>
          }
          aggregate: {
            args: Prisma.StatisticsCacheAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStatisticsCache>
          }
          groupBy: {
            args: Prisma.StatisticsCacheGroupByArgs<ExtArgs>
            result: $Utils.Optional<StatisticsCacheGroupByOutputType>[]
          }
          count: {
            args: Prisma.StatisticsCacheCountArgs<ExtArgs>
            result: $Utils.Optional<StatisticsCacheCountAggregateOutputType> | number
          }
        }
      }
      AddressCache: {
        payload: Prisma.$AddressCachePayload<ExtArgs>
        fields: Prisma.AddressCacheFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AddressCacheFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressCachePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AddressCacheFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressCachePayload>
          }
          findFirst: {
            args: Prisma.AddressCacheFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressCachePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AddressCacheFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressCachePayload>
          }
          findMany: {
            args: Prisma.AddressCacheFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressCachePayload>[]
          }
          create: {
            args: Prisma.AddressCacheCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressCachePayload>
          }
          createMany: {
            args: Prisma.AddressCacheCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AddressCacheCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressCachePayload>[]
          }
          delete: {
            args: Prisma.AddressCacheDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressCachePayload>
          }
          update: {
            args: Prisma.AddressCacheUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressCachePayload>
          }
          deleteMany: {
            args: Prisma.AddressCacheDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AddressCacheUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AddressCacheUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressCachePayload>
          }
          aggregate: {
            args: Prisma.AddressCacheAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAddressCache>
          }
          groupBy: {
            args: Prisma.AddressCacheGroupByArgs<ExtArgs>
            result: $Utils.Optional<AddressCacheGroupByOutputType>[]
          }
          count: {
            args: Prisma.AddressCacheCountArgs<ExtArgs>
            result: $Utils.Optional<AddressCacheCountAggregateOutputType> | number
          }
        }
      }
      ExportJob: {
        payload: Prisma.$ExportJobPayload<ExtArgs>
        fields: Prisma.ExportJobFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExportJobFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportJobPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExportJobFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportJobPayload>
          }
          findFirst: {
            args: Prisma.ExportJobFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportJobPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExportJobFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportJobPayload>
          }
          findMany: {
            args: Prisma.ExportJobFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportJobPayload>[]
          }
          create: {
            args: Prisma.ExportJobCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportJobPayload>
          }
          createMany: {
            args: Prisma.ExportJobCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExportJobCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportJobPayload>[]
          }
          delete: {
            args: Prisma.ExportJobDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportJobPayload>
          }
          update: {
            args: Prisma.ExportJobUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportJobPayload>
          }
          deleteMany: {
            args: Prisma.ExportJobDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExportJobUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExportJobUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExportJobPayload>
          }
          aggregate: {
            args: Prisma.ExportJobAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExportJob>
          }
          groupBy: {
            args: Prisma.ExportJobGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExportJobGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExportJobCountArgs<ExtArgs>
            result: $Utils.Optional<ExportJobCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type WoonplaatsCountOutputType
   */

  export type WoonplaatsCountOutputType = {
    openbareRuimtes: number
  }

  export type WoonplaatsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    openbareRuimtes?: boolean | WoonplaatsCountOutputTypeCountOpenbareRuimtesArgs
  }

  // Custom InputTypes
  /**
   * WoonplaatsCountOutputType without action
   */
  export type WoonplaatsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WoonplaatsCountOutputType
     */
    select?: WoonplaatsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WoonplaatsCountOutputType without action
   */
  export type WoonplaatsCountOutputTypeCountOpenbareRuimtesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OpenbareRuimteWhereInput
  }


  /**
   * Count Type OpenbareRuimteCountOutputType
   */

  export type OpenbareRuimteCountOutputType = {
    nummeraanduidingen: number
  }

  export type OpenbareRuimteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nummeraanduidingen?: boolean | OpenbareRuimteCountOutputTypeCountNummeraanduidingenArgs
  }

  // Custom InputTypes
  /**
   * OpenbareRuimteCountOutputType without action
   */
  export type OpenbareRuimteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenbareRuimteCountOutputType
     */
    select?: OpenbareRuimteCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OpenbareRuimteCountOutputType without action
   */
  export type OpenbareRuimteCountOutputTypeCountNummeraanduidingenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NummeraanduidingWhereInput
  }


  /**
   * Count Type PandCountOutputType
   */

  export type PandCountOutputType = {
    verblijfsobjecten: number
  }

  export type PandCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    verblijfsobjecten?: boolean | PandCountOutputTypeCountVerblijfsobjectenArgs
  }

  // Custom InputTypes
  /**
   * PandCountOutputType without action
   */
  export type PandCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PandCountOutputType
     */
    select?: PandCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PandCountOutputType without action
   */
  export type PandCountOutputTypeCountVerblijfsobjectenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerblijfsobjectWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Woonplaats
   */

  export type AggregateWoonplaats = {
    _count: WoonplaatsCountAggregateOutputType | null
    _min: WoonplaatsMinAggregateOutputType | null
    _max: WoonplaatsMaxAggregateOutputType | null
  }

  export type WoonplaatsMinAggregateOutputType = {
    identificatie: string | null
    beginGeldigheid: Date | null
    eindGeldigheid: Date | null
    geconstateerd: boolean | null
    documentDatum: Date | null
    documentNummer: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    naam: string | null
  }

  export type WoonplaatsMaxAggregateOutputType = {
    identificatie: string | null
    beginGeldigheid: Date | null
    eindGeldigheid: Date | null
    geconstateerd: boolean | null
    documentDatum: Date | null
    documentNummer: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    naam: string | null
  }

  export type WoonplaatsCountAggregateOutputType = {
    identificatie: number
    beginGeldigheid: number
    eindGeldigheid: number
    geconstateerd: number
    documentDatum: number
    documentNummer: number
    geometry: number
    status: number
    createdAt: number
    updatedAt: number
    naam: number
    _all: number
  }


  export type WoonplaatsMinAggregateInputType = {
    identificatie?: true
    beginGeldigheid?: true
    eindGeldigheid?: true
    geconstateerd?: true
    documentDatum?: true
    documentNummer?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    naam?: true
  }

  export type WoonplaatsMaxAggregateInputType = {
    identificatie?: true
    beginGeldigheid?: true
    eindGeldigheid?: true
    geconstateerd?: true
    documentDatum?: true
    documentNummer?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    naam?: true
  }

  export type WoonplaatsCountAggregateInputType = {
    identificatie?: true
    beginGeldigheid?: true
    eindGeldigheid?: true
    geconstateerd?: true
    documentDatum?: true
    documentNummer?: true
    geometry?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    naam?: true
    _all?: true
  }

  export type WoonplaatsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Woonplaats to aggregate.
     */
    where?: WoonplaatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Woonplaats to fetch.
     */
    orderBy?: WoonplaatsOrderByWithRelationInput | WoonplaatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WoonplaatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Woonplaats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Woonplaats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Woonplaats
    **/
    _count?: true | WoonplaatsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WoonplaatsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WoonplaatsMaxAggregateInputType
  }

  export type GetWoonplaatsAggregateType<T extends WoonplaatsAggregateArgs> = {
        [P in keyof T & keyof AggregateWoonplaats]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWoonplaats[P]>
      : GetScalarType<T[P], AggregateWoonplaats[P]>
  }




  export type WoonplaatsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WoonplaatsWhereInput
    orderBy?: WoonplaatsOrderByWithAggregationInput | WoonplaatsOrderByWithAggregationInput[]
    by: WoonplaatsScalarFieldEnum[] | WoonplaatsScalarFieldEnum
    having?: WoonplaatsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WoonplaatsCountAggregateInputType | true
    _min?: WoonplaatsMinAggregateInputType
    _max?: WoonplaatsMaxAggregateInputType
  }

  export type WoonplaatsGroupByOutputType = {
    identificatie: string
    beginGeldigheid: Date
    eindGeldigheid: Date | null
    geconstateerd: boolean
    documentDatum: Date
    documentNummer: string
    geometry: JsonValue | null
    status: string
    createdAt: Date
    updatedAt: Date
    naam: string
    _count: WoonplaatsCountAggregateOutputType | null
    _min: WoonplaatsMinAggregateOutputType | null
    _max: WoonplaatsMaxAggregateOutputType | null
  }

  type GetWoonplaatsGroupByPayload<T extends WoonplaatsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WoonplaatsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WoonplaatsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WoonplaatsGroupByOutputType[P]>
            : GetScalarType<T[P], WoonplaatsGroupByOutputType[P]>
        }
      >
    >


  export type WoonplaatsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identificatie?: boolean
    beginGeldigheid?: boolean
    eindGeldigheid?: boolean
    geconstateerd?: boolean
    documentDatum?: boolean
    documentNummer?: boolean
    geometry?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    naam?: boolean
    openbareRuimtes?: boolean | Woonplaats$openbareRuimtesArgs<ExtArgs>
    _count?: boolean | WoonplaatsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["woonplaats"]>

  export type WoonplaatsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identificatie?: boolean
    beginGeldigheid?: boolean
    eindGeldigheid?: boolean
    geconstateerd?: boolean
    documentDatum?: boolean
    documentNummer?: boolean
    geometry?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    naam?: boolean
  }, ExtArgs["result"]["woonplaats"]>

  export type WoonplaatsSelectScalar = {
    identificatie?: boolean
    beginGeldigheid?: boolean
    eindGeldigheid?: boolean
    geconstateerd?: boolean
    documentDatum?: boolean
    documentNummer?: boolean
    geometry?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    naam?: boolean
  }

  export type WoonplaatsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    openbareRuimtes?: boolean | Woonplaats$openbareRuimtesArgs<ExtArgs>
    _count?: boolean | WoonplaatsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WoonplaatsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $WoonplaatsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Woonplaats"
    objects: {
      openbareRuimtes: Prisma.$OpenbareRuimtePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      identificatie: string
      beginGeldigheid: Date
      eindGeldigheid: Date | null
      geconstateerd: boolean
      documentDatum: Date
      documentNummer: string
      geometry: Prisma.JsonValue | null
      status: string
      createdAt: Date
      updatedAt: Date
      naam: string
    }, ExtArgs["result"]["woonplaats"]>
    composites: {}
  }

  type WoonplaatsGetPayload<S extends boolean | null | undefined | WoonplaatsDefaultArgs> = $Result.GetResult<Prisma.$WoonplaatsPayload, S>

  type WoonplaatsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WoonplaatsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WoonplaatsCountAggregateInputType | true
    }

  export interface WoonplaatsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Woonplaats'], meta: { name: 'Woonplaats' } }
    /**
     * Find zero or one Woonplaats that matches the filter.
     * @param {WoonplaatsFindUniqueArgs} args - Arguments to find a Woonplaats
     * @example
     * // Get one Woonplaats
     * const woonplaats = await prisma.woonplaats.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WoonplaatsFindUniqueArgs>(args: SelectSubset<T, WoonplaatsFindUniqueArgs<ExtArgs>>): Prisma__WoonplaatsClient<$Result.GetResult<Prisma.$WoonplaatsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Woonplaats that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WoonplaatsFindUniqueOrThrowArgs} args - Arguments to find a Woonplaats
     * @example
     * // Get one Woonplaats
     * const woonplaats = await prisma.woonplaats.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WoonplaatsFindUniqueOrThrowArgs>(args: SelectSubset<T, WoonplaatsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WoonplaatsClient<$Result.GetResult<Prisma.$WoonplaatsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Woonplaats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WoonplaatsFindFirstArgs} args - Arguments to find a Woonplaats
     * @example
     * // Get one Woonplaats
     * const woonplaats = await prisma.woonplaats.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WoonplaatsFindFirstArgs>(args?: SelectSubset<T, WoonplaatsFindFirstArgs<ExtArgs>>): Prisma__WoonplaatsClient<$Result.GetResult<Prisma.$WoonplaatsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Woonplaats that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WoonplaatsFindFirstOrThrowArgs} args - Arguments to find a Woonplaats
     * @example
     * // Get one Woonplaats
     * const woonplaats = await prisma.woonplaats.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WoonplaatsFindFirstOrThrowArgs>(args?: SelectSubset<T, WoonplaatsFindFirstOrThrowArgs<ExtArgs>>): Prisma__WoonplaatsClient<$Result.GetResult<Prisma.$WoonplaatsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Woonplaats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WoonplaatsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Woonplaats
     * const woonplaats = await prisma.woonplaats.findMany()
     * 
     * // Get first 10 Woonplaats
     * const woonplaats = await prisma.woonplaats.findMany({ take: 10 })
     * 
     * // Only select the `identificatie`
     * const woonplaatsWithIdentificatieOnly = await prisma.woonplaats.findMany({ select: { identificatie: true } })
     * 
     */
    findMany<T extends WoonplaatsFindManyArgs>(args?: SelectSubset<T, WoonplaatsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WoonplaatsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Woonplaats.
     * @param {WoonplaatsCreateArgs} args - Arguments to create a Woonplaats.
     * @example
     * // Create one Woonplaats
     * const Woonplaats = await prisma.woonplaats.create({
     *   data: {
     *     // ... data to create a Woonplaats
     *   }
     * })
     * 
     */
    create<T extends WoonplaatsCreateArgs>(args: SelectSubset<T, WoonplaatsCreateArgs<ExtArgs>>): Prisma__WoonplaatsClient<$Result.GetResult<Prisma.$WoonplaatsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Woonplaats.
     * @param {WoonplaatsCreateManyArgs} args - Arguments to create many Woonplaats.
     * @example
     * // Create many Woonplaats
     * const woonplaats = await prisma.woonplaats.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WoonplaatsCreateManyArgs>(args?: SelectSubset<T, WoonplaatsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Woonplaats and returns the data saved in the database.
     * @param {WoonplaatsCreateManyAndReturnArgs} args - Arguments to create many Woonplaats.
     * @example
     * // Create many Woonplaats
     * const woonplaats = await prisma.woonplaats.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Woonplaats and only return the `identificatie`
     * const woonplaatsWithIdentificatieOnly = await prisma.woonplaats.createManyAndReturn({ 
     *   select: { identificatie: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WoonplaatsCreateManyAndReturnArgs>(args?: SelectSubset<T, WoonplaatsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WoonplaatsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Woonplaats.
     * @param {WoonplaatsDeleteArgs} args - Arguments to delete one Woonplaats.
     * @example
     * // Delete one Woonplaats
     * const Woonplaats = await prisma.woonplaats.delete({
     *   where: {
     *     // ... filter to delete one Woonplaats
     *   }
     * })
     * 
     */
    delete<T extends WoonplaatsDeleteArgs>(args: SelectSubset<T, WoonplaatsDeleteArgs<ExtArgs>>): Prisma__WoonplaatsClient<$Result.GetResult<Prisma.$WoonplaatsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Woonplaats.
     * @param {WoonplaatsUpdateArgs} args - Arguments to update one Woonplaats.
     * @example
     * // Update one Woonplaats
     * const woonplaats = await prisma.woonplaats.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WoonplaatsUpdateArgs>(args: SelectSubset<T, WoonplaatsUpdateArgs<ExtArgs>>): Prisma__WoonplaatsClient<$Result.GetResult<Prisma.$WoonplaatsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Woonplaats.
     * @param {WoonplaatsDeleteManyArgs} args - Arguments to filter Woonplaats to delete.
     * @example
     * // Delete a few Woonplaats
     * const { count } = await prisma.woonplaats.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WoonplaatsDeleteManyArgs>(args?: SelectSubset<T, WoonplaatsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Woonplaats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WoonplaatsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Woonplaats
     * const woonplaats = await prisma.woonplaats.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WoonplaatsUpdateManyArgs>(args: SelectSubset<T, WoonplaatsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Woonplaats.
     * @param {WoonplaatsUpsertArgs} args - Arguments to update or create a Woonplaats.
     * @example
     * // Update or create a Woonplaats
     * const woonplaats = await prisma.woonplaats.upsert({
     *   create: {
     *     // ... data to create a Woonplaats
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Woonplaats we want to update
     *   }
     * })
     */
    upsert<T extends WoonplaatsUpsertArgs>(args: SelectSubset<T, WoonplaatsUpsertArgs<ExtArgs>>): Prisma__WoonplaatsClient<$Result.GetResult<Prisma.$WoonplaatsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Woonplaats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WoonplaatsCountArgs} args - Arguments to filter Woonplaats to count.
     * @example
     * // Count the number of Woonplaats
     * const count = await prisma.woonplaats.count({
     *   where: {
     *     // ... the filter for the Woonplaats we want to count
     *   }
     * })
    **/
    count<T extends WoonplaatsCountArgs>(
      args?: Subset<T, WoonplaatsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WoonplaatsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Woonplaats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WoonplaatsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WoonplaatsAggregateArgs>(args: Subset<T, WoonplaatsAggregateArgs>): Prisma.PrismaPromise<GetWoonplaatsAggregateType<T>>

    /**
     * Group by Woonplaats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WoonplaatsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WoonplaatsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WoonplaatsGroupByArgs['orderBy'] }
        : { orderBy?: WoonplaatsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WoonplaatsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWoonplaatsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Woonplaats model
   */
  readonly fields: WoonplaatsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Woonplaats.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WoonplaatsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    openbareRuimtes<T extends Woonplaats$openbareRuimtesArgs<ExtArgs> = {}>(args?: Subset<T, Woonplaats$openbareRuimtesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpenbareRuimtePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Woonplaats model
   */ 
  interface WoonplaatsFieldRefs {
    readonly identificatie: FieldRef<"Woonplaats", 'String'>
    readonly beginGeldigheid: FieldRef<"Woonplaats", 'DateTime'>
    readonly eindGeldigheid: FieldRef<"Woonplaats", 'DateTime'>
    readonly geconstateerd: FieldRef<"Woonplaats", 'Boolean'>
    readonly documentDatum: FieldRef<"Woonplaats", 'DateTime'>
    readonly documentNummer: FieldRef<"Woonplaats", 'String'>
    readonly geometry: FieldRef<"Woonplaats", 'Json'>
    readonly status: FieldRef<"Woonplaats", 'String'>
    readonly createdAt: FieldRef<"Woonplaats", 'DateTime'>
    readonly updatedAt: FieldRef<"Woonplaats", 'DateTime'>
    readonly naam: FieldRef<"Woonplaats", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Woonplaats findUnique
   */
  export type WoonplaatsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Woonplaats
     */
    select?: WoonplaatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WoonplaatsInclude<ExtArgs> | null
    /**
     * Filter, which Woonplaats to fetch.
     */
    where: WoonplaatsWhereUniqueInput
  }

  /**
   * Woonplaats findUniqueOrThrow
   */
  export type WoonplaatsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Woonplaats
     */
    select?: WoonplaatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WoonplaatsInclude<ExtArgs> | null
    /**
     * Filter, which Woonplaats to fetch.
     */
    where: WoonplaatsWhereUniqueInput
  }

  /**
   * Woonplaats findFirst
   */
  export type WoonplaatsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Woonplaats
     */
    select?: WoonplaatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WoonplaatsInclude<ExtArgs> | null
    /**
     * Filter, which Woonplaats to fetch.
     */
    where?: WoonplaatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Woonplaats to fetch.
     */
    orderBy?: WoonplaatsOrderByWithRelationInput | WoonplaatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Woonplaats.
     */
    cursor?: WoonplaatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Woonplaats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Woonplaats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Woonplaats.
     */
    distinct?: WoonplaatsScalarFieldEnum | WoonplaatsScalarFieldEnum[]
  }

  /**
   * Woonplaats findFirstOrThrow
   */
  export type WoonplaatsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Woonplaats
     */
    select?: WoonplaatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WoonplaatsInclude<ExtArgs> | null
    /**
     * Filter, which Woonplaats to fetch.
     */
    where?: WoonplaatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Woonplaats to fetch.
     */
    orderBy?: WoonplaatsOrderByWithRelationInput | WoonplaatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Woonplaats.
     */
    cursor?: WoonplaatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Woonplaats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Woonplaats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Woonplaats.
     */
    distinct?: WoonplaatsScalarFieldEnum | WoonplaatsScalarFieldEnum[]
  }

  /**
   * Woonplaats findMany
   */
  export type WoonplaatsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Woonplaats
     */
    select?: WoonplaatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WoonplaatsInclude<ExtArgs> | null
    /**
     * Filter, which Woonplaats to fetch.
     */
    where?: WoonplaatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Woonplaats to fetch.
     */
    orderBy?: WoonplaatsOrderByWithRelationInput | WoonplaatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Woonplaats.
     */
    cursor?: WoonplaatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Woonplaats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Woonplaats.
     */
    skip?: number
    distinct?: WoonplaatsScalarFieldEnum | WoonplaatsScalarFieldEnum[]
  }

  /**
   * Woonplaats create
   */
  export type WoonplaatsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Woonplaats
     */
    select?: WoonplaatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WoonplaatsInclude<ExtArgs> | null
    /**
     * The data needed to create a Woonplaats.
     */
    data: XOR<WoonplaatsCreateInput, WoonplaatsUncheckedCreateInput>
  }

  /**
   * Woonplaats createMany
   */
  export type WoonplaatsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Woonplaats.
     */
    data: WoonplaatsCreateManyInput | WoonplaatsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Woonplaats createManyAndReturn
   */
  export type WoonplaatsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Woonplaats
     */
    select?: WoonplaatsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Woonplaats.
     */
    data: WoonplaatsCreateManyInput | WoonplaatsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Woonplaats update
   */
  export type WoonplaatsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Woonplaats
     */
    select?: WoonplaatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WoonplaatsInclude<ExtArgs> | null
    /**
     * The data needed to update a Woonplaats.
     */
    data: XOR<WoonplaatsUpdateInput, WoonplaatsUncheckedUpdateInput>
    /**
     * Choose, which Woonplaats to update.
     */
    where: WoonplaatsWhereUniqueInput
  }

  /**
   * Woonplaats updateMany
   */
  export type WoonplaatsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Woonplaats.
     */
    data: XOR<WoonplaatsUpdateManyMutationInput, WoonplaatsUncheckedUpdateManyInput>
    /**
     * Filter which Woonplaats to update
     */
    where?: WoonplaatsWhereInput
  }

  /**
   * Woonplaats upsert
   */
  export type WoonplaatsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Woonplaats
     */
    select?: WoonplaatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WoonplaatsInclude<ExtArgs> | null
    /**
     * The filter to search for the Woonplaats to update in case it exists.
     */
    where: WoonplaatsWhereUniqueInput
    /**
     * In case the Woonplaats found by the `where` argument doesn't exist, create a new Woonplaats with this data.
     */
    create: XOR<WoonplaatsCreateInput, WoonplaatsUncheckedCreateInput>
    /**
     * In case the Woonplaats was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WoonplaatsUpdateInput, WoonplaatsUncheckedUpdateInput>
  }

  /**
   * Woonplaats delete
   */
  export type WoonplaatsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Woonplaats
     */
    select?: WoonplaatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WoonplaatsInclude<ExtArgs> | null
    /**
     * Filter which Woonplaats to delete.
     */
    where: WoonplaatsWhereUniqueInput
  }

  /**
   * Woonplaats deleteMany
   */
  export type WoonplaatsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Woonplaats to delete
     */
    where?: WoonplaatsWhereInput
  }

  /**
   * Woonplaats.openbareRuimtes
   */
  export type Woonplaats$openbareRuimtesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenbareRuimte
     */
    select?: OpenbareRuimteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenbareRuimteInclude<ExtArgs> | null
    where?: OpenbareRuimteWhereInput
    orderBy?: OpenbareRuimteOrderByWithRelationInput | OpenbareRuimteOrderByWithRelationInput[]
    cursor?: OpenbareRuimteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OpenbareRuimteScalarFieldEnum | OpenbareRuimteScalarFieldEnum[]
  }

  /**
   * Woonplaats without action
   */
  export type WoonplaatsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Woonplaats
     */
    select?: WoonplaatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WoonplaatsInclude<ExtArgs> | null
  }


  /**
   * Model OpenbareRuimte
   */

  export type AggregateOpenbareRuimte = {
    _count: OpenbareRuimteCountAggregateOutputType | null
    _min: OpenbareRuimteMinAggregateOutputType | null
    _max: OpenbareRuimteMaxAggregateOutputType | null
  }

  export type OpenbareRuimteMinAggregateOutputType = {
    identificatie: string | null
    beginGeldigheid: Date | null
    eindGeldigheid: Date | null
    geconstateerd: boolean | null
    documentDatum: Date | null
    documentNummer: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    naam: string | null
    type: string | null
    woonplaatsId: string | null
  }

  export type OpenbareRuimteMaxAggregateOutputType = {
    identificatie: string | null
    beginGeldigheid: Date | null
    eindGeldigheid: Date | null
    geconstateerd: boolean | null
    documentDatum: Date | null
    documentNummer: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    naam: string | null
    type: string | null
    woonplaatsId: string | null
  }

  export type OpenbareRuimteCountAggregateOutputType = {
    identificatie: number
    beginGeldigheid: number
    eindGeldigheid: number
    geconstateerd: number
    documentDatum: number
    documentNummer: number
    geometry: number
    status: number
    createdAt: number
    updatedAt: number
    naam: number
    type: number
    woonplaatsId: number
    _all: number
  }


  export type OpenbareRuimteMinAggregateInputType = {
    identificatie?: true
    beginGeldigheid?: true
    eindGeldigheid?: true
    geconstateerd?: true
    documentDatum?: true
    documentNummer?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    naam?: true
    type?: true
    woonplaatsId?: true
  }

  export type OpenbareRuimteMaxAggregateInputType = {
    identificatie?: true
    beginGeldigheid?: true
    eindGeldigheid?: true
    geconstateerd?: true
    documentDatum?: true
    documentNummer?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    naam?: true
    type?: true
    woonplaatsId?: true
  }

  export type OpenbareRuimteCountAggregateInputType = {
    identificatie?: true
    beginGeldigheid?: true
    eindGeldigheid?: true
    geconstateerd?: true
    documentDatum?: true
    documentNummer?: true
    geometry?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    naam?: true
    type?: true
    woonplaatsId?: true
    _all?: true
  }

  export type OpenbareRuimteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OpenbareRuimte to aggregate.
     */
    where?: OpenbareRuimteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OpenbareRuimtes to fetch.
     */
    orderBy?: OpenbareRuimteOrderByWithRelationInput | OpenbareRuimteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OpenbareRuimteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OpenbareRuimtes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OpenbareRuimtes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OpenbareRuimtes
    **/
    _count?: true | OpenbareRuimteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OpenbareRuimteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OpenbareRuimteMaxAggregateInputType
  }

  export type GetOpenbareRuimteAggregateType<T extends OpenbareRuimteAggregateArgs> = {
        [P in keyof T & keyof AggregateOpenbareRuimte]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOpenbareRuimte[P]>
      : GetScalarType<T[P], AggregateOpenbareRuimte[P]>
  }




  export type OpenbareRuimteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OpenbareRuimteWhereInput
    orderBy?: OpenbareRuimteOrderByWithAggregationInput | OpenbareRuimteOrderByWithAggregationInput[]
    by: OpenbareRuimteScalarFieldEnum[] | OpenbareRuimteScalarFieldEnum
    having?: OpenbareRuimteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OpenbareRuimteCountAggregateInputType | true
    _min?: OpenbareRuimteMinAggregateInputType
    _max?: OpenbareRuimteMaxAggregateInputType
  }

  export type OpenbareRuimteGroupByOutputType = {
    identificatie: string
    beginGeldigheid: Date
    eindGeldigheid: Date | null
    geconstateerd: boolean
    documentDatum: Date
    documentNummer: string
    geometry: JsonValue | null
    status: string
    createdAt: Date
    updatedAt: Date
    naam: string
    type: string
    woonplaatsId: string
    _count: OpenbareRuimteCountAggregateOutputType | null
    _min: OpenbareRuimteMinAggregateOutputType | null
    _max: OpenbareRuimteMaxAggregateOutputType | null
  }

  type GetOpenbareRuimteGroupByPayload<T extends OpenbareRuimteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OpenbareRuimteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OpenbareRuimteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OpenbareRuimteGroupByOutputType[P]>
            : GetScalarType<T[P], OpenbareRuimteGroupByOutputType[P]>
        }
      >
    >


  export type OpenbareRuimteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identificatie?: boolean
    beginGeldigheid?: boolean
    eindGeldigheid?: boolean
    geconstateerd?: boolean
    documentDatum?: boolean
    documentNummer?: boolean
    geometry?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    naam?: boolean
    type?: boolean
    woonplaatsId?: boolean
    nummeraanduidingen?: boolean | OpenbareRuimte$nummeraanduidingenArgs<ExtArgs>
    woonplaats?: boolean | WoonplaatsDefaultArgs<ExtArgs>
    _count?: boolean | OpenbareRuimteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["openbareRuimte"]>

  export type OpenbareRuimteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identificatie?: boolean
    beginGeldigheid?: boolean
    eindGeldigheid?: boolean
    geconstateerd?: boolean
    documentDatum?: boolean
    documentNummer?: boolean
    geometry?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    naam?: boolean
    type?: boolean
    woonplaatsId?: boolean
    woonplaats?: boolean | WoonplaatsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["openbareRuimte"]>

  export type OpenbareRuimteSelectScalar = {
    identificatie?: boolean
    beginGeldigheid?: boolean
    eindGeldigheid?: boolean
    geconstateerd?: boolean
    documentDatum?: boolean
    documentNummer?: boolean
    geometry?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    naam?: boolean
    type?: boolean
    woonplaatsId?: boolean
  }

  export type OpenbareRuimteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nummeraanduidingen?: boolean | OpenbareRuimte$nummeraanduidingenArgs<ExtArgs>
    woonplaats?: boolean | WoonplaatsDefaultArgs<ExtArgs>
    _count?: boolean | OpenbareRuimteCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OpenbareRuimteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    woonplaats?: boolean | WoonplaatsDefaultArgs<ExtArgs>
  }

  export type $OpenbareRuimtePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OpenbareRuimte"
    objects: {
      nummeraanduidingen: Prisma.$NummeraanduidingPayload<ExtArgs>[]
      woonplaats: Prisma.$WoonplaatsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      identificatie: string
      beginGeldigheid: Date
      eindGeldigheid: Date | null
      geconstateerd: boolean
      documentDatum: Date
      documentNummer: string
      geometry: Prisma.JsonValue | null
      status: string
      createdAt: Date
      updatedAt: Date
      naam: string
      type: string
      woonplaatsId: string
    }, ExtArgs["result"]["openbareRuimte"]>
    composites: {}
  }

  type OpenbareRuimteGetPayload<S extends boolean | null | undefined | OpenbareRuimteDefaultArgs> = $Result.GetResult<Prisma.$OpenbareRuimtePayload, S>

  type OpenbareRuimteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OpenbareRuimteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OpenbareRuimteCountAggregateInputType | true
    }

  export interface OpenbareRuimteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OpenbareRuimte'], meta: { name: 'OpenbareRuimte' } }
    /**
     * Find zero or one OpenbareRuimte that matches the filter.
     * @param {OpenbareRuimteFindUniqueArgs} args - Arguments to find a OpenbareRuimte
     * @example
     * // Get one OpenbareRuimte
     * const openbareRuimte = await prisma.openbareRuimte.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OpenbareRuimteFindUniqueArgs>(args: SelectSubset<T, OpenbareRuimteFindUniqueArgs<ExtArgs>>): Prisma__OpenbareRuimteClient<$Result.GetResult<Prisma.$OpenbareRuimtePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OpenbareRuimte that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OpenbareRuimteFindUniqueOrThrowArgs} args - Arguments to find a OpenbareRuimte
     * @example
     * // Get one OpenbareRuimte
     * const openbareRuimte = await prisma.openbareRuimte.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OpenbareRuimteFindUniqueOrThrowArgs>(args: SelectSubset<T, OpenbareRuimteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OpenbareRuimteClient<$Result.GetResult<Prisma.$OpenbareRuimtePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OpenbareRuimte that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpenbareRuimteFindFirstArgs} args - Arguments to find a OpenbareRuimte
     * @example
     * // Get one OpenbareRuimte
     * const openbareRuimte = await prisma.openbareRuimte.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OpenbareRuimteFindFirstArgs>(args?: SelectSubset<T, OpenbareRuimteFindFirstArgs<ExtArgs>>): Prisma__OpenbareRuimteClient<$Result.GetResult<Prisma.$OpenbareRuimtePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OpenbareRuimte that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpenbareRuimteFindFirstOrThrowArgs} args - Arguments to find a OpenbareRuimte
     * @example
     * // Get one OpenbareRuimte
     * const openbareRuimte = await prisma.openbareRuimte.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OpenbareRuimteFindFirstOrThrowArgs>(args?: SelectSubset<T, OpenbareRuimteFindFirstOrThrowArgs<ExtArgs>>): Prisma__OpenbareRuimteClient<$Result.GetResult<Prisma.$OpenbareRuimtePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OpenbareRuimtes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpenbareRuimteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OpenbareRuimtes
     * const openbareRuimtes = await prisma.openbareRuimte.findMany()
     * 
     * // Get first 10 OpenbareRuimtes
     * const openbareRuimtes = await prisma.openbareRuimte.findMany({ take: 10 })
     * 
     * // Only select the `identificatie`
     * const openbareRuimteWithIdentificatieOnly = await prisma.openbareRuimte.findMany({ select: { identificatie: true } })
     * 
     */
    findMany<T extends OpenbareRuimteFindManyArgs>(args?: SelectSubset<T, OpenbareRuimteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpenbareRuimtePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a OpenbareRuimte.
     * @param {OpenbareRuimteCreateArgs} args - Arguments to create a OpenbareRuimte.
     * @example
     * // Create one OpenbareRuimte
     * const OpenbareRuimte = await prisma.openbareRuimte.create({
     *   data: {
     *     // ... data to create a OpenbareRuimte
     *   }
     * })
     * 
     */
    create<T extends OpenbareRuimteCreateArgs>(args: SelectSubset<T, OpenbareRuimteCreateArgs<ExtArgs>>): Prisma__OpenbareRuimteClient<$Result.GetResult<Prisma.$OpenbareRuimtePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OpenbareRuimtes.
     * @param {OpenbareRuimteCreateManyArgs} args - Arguments to create many OpenbareRuimtes.
     * @example
     * // Create many OpenbareRuimtes
     * const openbareRuimte = await prisma.openbareRuimte.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OpenbareRuimteCreateManyArgs>(args?: SelectSubset<T, OpenbareRuimteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OpenbareRuimtes and returns the data saved in the database.
     * @param {OpenbareRuimteCreateManyAndReturnArgs} args - Arguments to create many OpenbareRuimtes.
     * @example
     * // Create many OpenbareRuimtes
     * const openbareRuimte = await prisma.openbareRuimte.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OpenbareRuimtes and only return the `identificatie`
     * const openbareRuimteWithIdentificatieOnly = await prisma.openbareRuimte.createManyAndReturn({ 
     *   select: { identificatie: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OpenbareRuimteCreateManyAndReturnArgs>(args?: SelectSubset<T, OpenbareRuimteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpenbareRuimtePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a OpenbareRuimte.
     * @param {OpenbareRuimteDeleteArgs} args - Arguments to delete one OpenbareRuimte.
     * @example
     * // Delete one OpenbareRuimte
     * const OpenbareRuimte = await prisma.openbareRuimte.delete({
     *   where: {
     *     // ... filter to delete one OpenbareRuimte
     *   }
     * })
     * 
     */
    delete<T extends OpenbareRuimteDeleteArgs>(args: SelectSubset<T, OpenbareRuimteDeleteArgs<ExtArgs>>): Prisma__OpenbareRuimteClient<$Result.GetResult<Prisma.$OpenbareRuimtePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OpenbareRuimte.
     * @param {OpenbareRuimteUpdateArgs} args - Arguments to update one OpenbareRuimte.
     * @example
     * // Update one OpenbareRuimte
     * const openbareRuimte = await prisma.openbareRuimte.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OpenbareRuimteUpdateArgs>(args: SelectSubset<T, OpenbareRuimteUpdateArgs<ExtArgs>>): Prisma__OpenbareRuimteClient<$Result.GetResult<Prisma.$OpenbareRuimtePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OpenbareRuimtes.
     * @param {OpenbareRuimteDeleteManyArgs} args - Arguments to filter OpenbareRuimtes to delete.
     * @example
     * // Delete a few OpenbareRuimtes
     * const { count } = await prisma.openbareRuimte.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OpenbareRuimteDeleteManyArgs>(args?: SelectSubset<T, OpenbareRuimteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OpenbareRuimtes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpenbareRuimteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OpenbareRuimtes
     * const openbareRuimte = await prisma.openbareRuimte.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OpenbareRuimteUpdateManyArgs>(args: SelectSubset<T, OpenbareRuimteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OpenbareRuimte.
     * @param {OpenbareRuimteUpsertArgs} args - Arguments to update or create a OpenbareRuimte.
     * @example
     * // Update or create a OpenbareRuimte
     * const openbareRuimte = await prisma.openbareRuimte.upsert({
     *   create: {
     *     // ... data to create a OpenbareRuimte
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OpenbareRuimte we want to update
     *   }
     * })
     */
    upsert<T extends OpenbareRuimteUpsertArgs>(args: SelectSubset<T, OpenbareRuimteUpsertArgs<ExtArgs>>): Prisma__OpenbareRuimteClient<$Result.GetResult<Prisma.$OpenbareRuimtePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of OpenbareRuimtes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpenbareRuimteCountArgs} args - Arguments to filter OpenbareRuimtes to count.
     * @example
     * // Count the number of OpenbareRuimtes
     * const count = await prisma.openbareRuimte.count({
     *   where: {
     *     // ... the filter for the OpenbareRuimtes we want to count
     *   }
     * })
    **/
    count<T extends OpenbareRuimteCountArgs>(
      args?: Subset<T, OpenbareRuimteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OpenbareRuimteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OpenbareRuimte.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpenbareRuimteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OpenbareRuimteAggregateArgs>(args: Subset<T, OpenbareRuimteAggregateArgs>): Prisma.PrismaPromise<GetOpenbareRuimteAggregateType<T>>

    /**
     * Group by OpenbareRuimte.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpenbareRuimteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OpenbareRuimteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OpenbareRuimteGroupByArgs['orderBy'] }
        : { orderBy?: OpenbareRuimteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OpenbareRuimteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOpenbareRuimteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OpenbareRuimte model
   */
  readonly fields: OpenbareRuimteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OpenbareRuimte.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OpenbareRuimteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    nummeraanduidingen<T extends OpenbareRuimte$nummeraanduidingenArgs<ExtArgs> = {}>(args?: Subset<T, OpenbareRuimte$nummeraanduidingenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NummeraanduidingPayload<ExtArgs>, T, "findMany"> | Null>
    woonplaats<T extends WoonplaatsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WoonplaatsDefaultArgs<ExtArgs>>): Prisma__WoonplaatsClient<$Result.GetResult<Prisma.$WoonplaatsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OpenbareRuimte model
   */ 
  interface OpenbareRuimteFieldRefs {
    readonly identificatie: FieldRef<"OpenbareRuimte", 'String'>
    readonly beginGeldigheid: FieldRef<"OpenbareRuimte", 'DateTime'>
    readonly eindGeldigheid: FieldRef<"OpenbareRuimte", 'DateTime'>
    readonly geconstateerd: FieldRef<"OpenbareRuimte", 'Boolean'>
    readonly documentDatum: FieldRef<"OpenbareRuimte", 'DateTime'>
    readonly documentNummer: FieldRef<"OpenbareRuimte", 'String'>
    readonly geometry: FieldRef<"OpenbareRuimte", 'Json'>
    readonly status: FieldRef<"OpenbareRuimte", 'String'>
    readonly createdAt: FieldRef<"OpenbareRuimte", 'DateTime'>
    readonly updatedAt: FieldRef<"OpenbareRuimte", 'DateTime'>
    readonly naam: FieldRef<"OpenbareRuimte", 'String'>
    readonly type: FieldRef<"OpenbareRuimte", 'String'>
    readonly woonplaatsId: FieldRef<"OpenbareRuimte", 'String'>
  }
    

  // Custom InputTypes
  /**
   * OpenbareRuimte findUnique
   */
  export type OpenbareRuimteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenbareRuimte
     */
    select?: OpenbareRuimteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenbareRuimteInclude<ExtArgs> | null
    /**
     * Filter, which OpenbareRuimte to fetch.
     */
    where: OpenbareRuimteWhereUniqueInput
  }

  /**
   * OpenbareRuimte findUniqueOrThrow
   */
  export type OpenbareRuimteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenbareRuimte
     */
    select?: OpenbareRuimteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenbareRuimteInclude<ExtArgs> | null
    /**
     * Filter, which OpenbareRuimte to fetch.
     */
    where: OpenbareRuimteWhereUniqueInput
  }

  /**
   * OpenbareRuimte findFirst
   */
  export type OpenbareRuimteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenbareRuimte
     */
    select?: OpenbareRuimteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenbareRuimteInclude<ExtArgs> | null
    /**
     * Filter, which OpenbareRuimte to fetch.
     */
    where?: OpenbareRuimteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OpenbareRuimtes to fetch.
     */
    orderBy?: OpenbareRuimteOrderByWithRelationInput | OpenbareRuimteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OpenbareRuimtes.
     */
    cursor?: OpenbareRuimteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OpenbareRuimtes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OpenbareRuimtes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OpenbareRuimtes.
     */
    distinct?: OpenbareRuimteScalarFieldEnum | OpenbareRuimteScalarFieldEnum[]
  }

  /**
   * OpenbareRuimte findFirstOrThrow
   */
  export type OpenbareRuimteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenbareRuimte
     */
    select?: OpenbareRuimteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenbareRuimteInclude<ExtArgs> | null
    /**
     * Filter, which OpenbareRuimte to fetch.
     */
    where?: OpenbareRuimteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OpenbareRuimtes to fetch.
     */
    orderBy?: OpenbareRuimteOrderByWithRelationInput | OpenbareRuimteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OpenbareRuimtes.
     */
    cursor?: OpenbareRuimteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OpenbareRuimtes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OpenbareRuimtes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OpenbareRuimtes.
     */
    distinct?: OpenbareRuimteScalarFieldEnum | OpenbareRuimteScalarFieldEnum[]
  }

  /**
   * OpenbareRuimte findMany
   */
  export type OpenbareRuimteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenbareRuimte
     */
    select?: OpenbareRuimteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenbareRuimteInclude<ExtArgs> | null
    /**
     * Filter, which OpenbareRuimtes to fetch.
     */
    where?: OpenbareRuimteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OpenbareRuimtes to fetch.
     */
    orderBy?: OpenbareRuimteOrderByWithRelationInput | OpenbareRuimteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OpenbareRuimtes.
     */
    cursor?: OpenbareRuimteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OpenbareRuimtes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OpenbareRuimtes.
     */
    skip?: number
    distinct?: OpenbareRuimteScalarFieldEnum | OpenbareRuimteScalarFieldEnum[]
  }

  /**
   * OpenbareRuimte create
   */
  export type OpenbareRuimteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenbareRuimte
     */
    select?: OpenbareRuimteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenbareRuimteInclude<ExtArgs> | null
    /**
     * The data needed to create a OpenbareRuimte.
     */
    data: XOR<OpenbareRuimteCreateInput, OpenbareRuimteUncheckedCreateInput>
  }

  /**
   * OpenbareRuimte createMany
   */
  export type OpenbareRuimteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OpenbareRuimtes.
     */
    data: OpenbareRuimteCreateManyInput | OpenbareRuimteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OpenbareRuimte createManyAndReturn
   */
  export type OpenbareRuimteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenbareRuimte
     */
    select?: OpenbareRuimteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many OpenbareRuimtes.
     */
    data: OpenbareRuimteCreateManyInput | OpenbareRuimteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenbareRuimteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OpenbareRuimte update
   */
  export type OpenbareRuimteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenbareRuimte
     */
    select?: OpenbareRuimteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenbareRuimteInclude<ExtArgs> | null
    /**
     * The data needed to update a OpenbareRuimte.
     */
    data: XOR<OpenbareRuimteUpdateInput, OpenbareRuimteUncheckedUpdateInput>
    /**
     * Choose, which OpenbareRuimte to update.
     */
    where: OpenbareRuimteWhereUniqueInput
  }

  /**
   * OpenbareRuimte updateMany
   */
  export type OpenbareRuimteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OpenbareRuimtes.
     */
    data: XOR<OpenbareRuimteUpdateManyMutationInput, OpenbareRuimteUncheckedUpdateManyInput>
    /**
     * Filter which OpenbareRuimtes to update
     */
    where?: OpenbareRuimteWhereInput
  }

  /**
   * OpenbareRuimte upsert
   */
  export type OpenbareRuimteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenbareRuimte
     */
    select?: OpenbareRuimteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenbareRuimteInclude<ExtArgs> | null
    /**
     * The filter to search for the OpenbareRuimte to update in case it exists.
     */
    where: OpenbareRuimteWhereUniqueInput
    /**
     * In case the OpenbareRuimte found by the `where` argument doesn't exist, create a new OpenbareRuimte with this data.
     */
    create: XOR<OpenbareRuimteCreateInput, OpenbareRuimteUncheckedCreateInput>
    /**
     * In case the OpenbareRuimte was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OpenbareRuimteUpdateInput, OpenbareRuimteUncheckedUpdateInput>
  }

  /**
   * OpenbareRuimte delete
   */
  export type OpenbareRuimteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenbareRuimte
     */
    select?: OpenbareRuimteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenbareRuimteInclude<ExtArgs> | null
    /**
     * Filter which OpenbareRuimte to delete.
     */
    where: OpenbareRuimteWhereUniqueInput
  }

  /**
   * OpenbareRuimte deleteMany
   */
  export type OpenbareRuimteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OpenbareRuimtes to delete
     */
    where?: OpenbareRuimteWhereInput
  }

  /**
   * OpenbareRuimte.nummeraanduidingen
   */
  export type OpenbareRuimte$nummeraanduidingenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nummeraanduiding
     */
    select?: NummeraanduidingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NummeraanduidingInclude<ExtArgs> | null
    where?: NummeraanduidingWhereInput
    orderBy?: NummeraanduidingOrderByWithRelationInput | NummeraanduidingOrderByWithRelationInput[]
    cursor?: NummeraanduidingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NummeraanduidingScalarFieldEnum | NummeraanduidingScalarFieldEnum[]
  }

  /**
   * OpenbareRuimte without action
   */
  export type OpenbareRuimteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenbareRuimte
     */
    select?: OpenbareRuimteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenbareRuimteInclude<ExtArgs> | null
  }


  /**
   * Model Pand
   */

  export type AggregatePand = {
    _count: PandCountAggregateOutputType | null
    _avg: PandAvgAggregateOutputType | null
    _sum: PandSumAggregateOutputType | null
    _min: PandMinAggregateOutputType | null
    _max: PandMaxAggregateOutputType | null
  }

  export type PandAvgAggregateOutputType = {
    oorspronkelijkBouwjaar: number | null
  }

  export type PandSumAggregateOutputType = {
    oorspronkelijkBouwjaar: number | null
  }

  export type PandMinAggregateOutputType = {
    identificatie: string | null
    beginGeldigheid: Date | null
    eindGeldigheid: Date | null
    geconstateerd: boolean | null
    documentDatum: Date | null
    documentNummer: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    oorspronkelijkBouwjaar: number | null
  }

  export type PandMaxAggregateOutputType = {
    identificatie: string | null
    beginGeldigheid: Date | null
    eindGeldigheid: Date | null
    geconstateerd: boolean | null
    documentDatum: Date | null
    documentNummer: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    oorspronkelijkBouwjaar: number | null
  }

  export type PandCountAggregateOutputType = {
    identificatie: number
    beginGeldigheid: number
    eindGeldigheid: number
    geconstateerd: number
    documentDatum: number
    documentNummer: number
    geometry: number
    status: number
    createdAt: number
    updatedAt: number
    oorspronkelijkBouwjaar: number
    _all: number
  }


  export type PandAvgAggregateInputType = {
    oorspronkelijkBouwjaar?: true
  }

  export type PandSumAggregateInputType = {
    oorspronkelijkBouwjaar?: true
  }

  export type PandMinAggregateInputType = {
    identificatie?: true
    beginGeldigheid?: true
    eindGeldigheid?: true
    geconstateerd?: true
    documentDatum?: true
    documentNummer?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    oorspronkelijkBouwjaar?: true
  }

  export type PandMaxAggregateInputType = {
    identificatie?: true
    beginGeldigheid?: true
    eindGeldigheid?: true
    geconstateerd?: true
    documentDatum?: true
    documentNummer?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    oorspronkelijkBouwjaar?: true
  }

  export type PandCountAggregateInputType = {
    identificatie?: true
    beginGeldigheid?: true
    eindGeldigheid?: true
    geconstateerd?: true
    documentDatum?: true
    documentNummer?: true
    geometry?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    oorspronkelijkBouwjaar?: true
    _all?: true
  }

  export type PandAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pand to aggregate.
     */
    where?: PandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pands to fetch.
     */
    orderBy?: PandOrderByWithRelationInput | PandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pands
    **/
    _count?: true | PandCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PandAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PandSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PandMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PandMaxAggregateInputType
  }

  export type GetPandAggregateType<T extends PandAggregateArgs> = {
        [P in keyof T & keyof AggregatePand]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePand[P]>
      : GetScalarType<T[P], AggregatePand[P]>
  }




  export type PandGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PandWhereInput
    orderBy?: PandOrderByWithAggregationInput | PandOrderByWithAggregationInput[]
    by: PandScalarFieldEnum[] | PandScalarFieldEnum
    having?: PandScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PandCountAggregateInputType | true
    _avg?: PandAvgAggregateInputType
    _sum?: PandSumAggregateInputType
    _min?: PandMinAggregateInputType
    _max?: PandMaxAggregateInputType
  }

  export type PandGroupByOutputType = {
    identificatie: string
    beginGeldigheid: Date
    eindGeldigheid: Date | null
    geconstateerd: boolean
    documentDatum: Date
    documentNummer: string
    geometry: JsonValue | null
    status: string
    createdAt: Date
    updatedAt: Date
    oorspronkelijkBouwjaar: number
    _count: PandCountAggregateOutputType | null
    _avg: PandAvgAggregateOutputType | null
    _sum: PandSumAggregateOutputType | null
    _min: PandMinAggregateOutputType | null
    _max: PandMaxAggregateOutputType | null
  }

  type GetPandGroupByPayload<T extends PandGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PandGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PandGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PandGroupByOutputType[P]>
            : GetScalarType<T[P], PandGroupByOutputType[P]>
        }
      >
    >


  export type PandSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identificatie?: boolean
    beginGeldigheid?: boolean
    eindGeldigheid?: boolean
    geconstateerd?: boolean
    documentDatum?: boolean
    documentNummer?: boolean
    geometry?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    oorspronkelijkBouwjaar?: boolean
    verblijfsobjecten?: boolean | Pand$verblijfsobjectenArgs<ExtArgs>
    _count?: boolean | PandCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pand"]>

  export type PandSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identificatie?: boolean
    beginGeldigheid?: boolean
    eindGeldigheid?: boolean
    geconstateerd?: boolean
    documentDatum?: boolean
    documentNummer?: boolean
    geometry?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    oorspronkelijkBouwjaar?: boolean
  }, ExtArgs["result"]["pand"]>

  export type PandSelectScalar = {
    identificatie?: boolean
    beginGeldigheid?: boolean
    eindGeldigheid?: boolean
    geconstateerd?: boolean
    documentDatum?: boolean
    documentNummer?: boolean
    geometry?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    oorspronkelijkBouwjaar?: boolean
  }

  export type PandInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    verblijfsobjecten?: boolean | Pand$verblijfsobjectenArgs<ExtArgs>
    _count?: boolean | PandCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PandIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PandPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Pand"
    objects: {
      verblijfsobjecten: Prisma.$VerblijfsobjectPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      identificatie: string
      beginGeldigheid: Date
      eindGeldigheid: Date | null
      geconstateerd: boolean
      documentDatum: Date
      documentNummer: string
      geometry: Prisma.JsonValue | null
      status: string
      createdAt: Date
      updatedAt: Date
      oorspronkelijkBouwjaar: number
    }, ExtArgs["result"]["pand"]>
    composites: {}
  }

  type PandGetPayload<S extends boolean | null | undefined | PandDefaultArgs> = $Result.GetResult<Prisma.$PandPayload, S>

  type PandCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PandFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PandCountAggregateInputType | true
    }

  export interface PandDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Pand'], meta: { name: 'Pand' } }
    /**
     * Find zero or one Pand that matches the filter.
     * @param {PandFindUniqueArgs} args - Arguments to find a Pand
     * @example
     * // Get one Pand
     * const pand = await prisma.pand.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PandFindUniqueArgs>(args: SelectSubset<T, PandFindUniqueArgs<ExtArgs>>): Prisma__PandClient<$Result.GetResult<Prisma.$PandPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Pand that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PandFindUniqueOrThrowArgs} args - Arguments to find a Pand
     * @example
     * // Get one Pand
     * const pand = await prisma.pand.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PandFindUniqueOrThrowArgs>(args: SelectSubset<T, PandFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PandClient<$Result.GetResult<Prisma.$PandPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Pand that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PandFindFirstArgs} args - Arguments to find a Pand
     * @example
     * // Get one Pand
     * const pand = await prisma.pand.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PandFindFirstArgs>(args?: SelectSubset<T, PandFindFirstArgs<ExtArgs>>): Prisma__PandClient<$Result.GetResult<Prisma.$PandPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Pand that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PandFindFirstOrThrowArgs} args - Arguments to find a Pand
     * @example
     * // Get one Pand
     * const pand = await prisma.pand.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PandFindFirstOrThrowArgs>(args?: SelectSubset<T, PandFindFirstOrThrowArgs<ExtArgs>>): Prisma__PandClient<$Result.GetResult<Prisma.$PandPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Pands that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PandFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pands
     * const pands = await prisma.pand.findMany()
     * 
     * // Get first 10 Pands
     * const pands = await prisma.pand.findMany({ take: 10 })
     * 
     * // Only select the `identificatie`
     * const pandWithIdentificatieOnly = await prisma.pand.findMany({ select: { identificatie: true } })
     * 
     */
    findMany<T extends PandFindManyArgs>(args?: SelectSubset<T, PandFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PandPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Pand.
     * @param {PandCreateArgs} args - Arguments to create a Pand.
     * @example
     * // Create one Pand
     * const Pand = await prisma.pand.create({
     *   data: {
     *     // ... data to create a Pand
     *   }
     * })
     * 
     */
    create<T extends PandCreateArgs>(args: SelectSubset<T, PandCreateArgs<ExtArgs>>): Prisma__PandClient<$Result.GetResult<Prisma.$PandPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Pands.
     * @param {PandCreateManyArgs} args - Arguments to create many Pands.
     * @example
     * // Create many Pands
     * const pand = await prisma.pand.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PandCreateManyArgs>(args?: SelectSubset<T, PandCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pands and returns the data saved in the database.
     * @param {PandCreateManyAndReturnArgs} args - Arguments to create many Pands.
     * @example
     * // Create many Pands
     * const pand = await prisma.pand.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pands and only return the `identificatie`
     * const pandWithIdentificatieOnly = await prisma.pand.createManyAndReturn({ 
     *   select: { identificatie: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PandCreateManyAndReturnArgs>(args?: SelectSubset<T, PandCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PandPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Pand.
     * @param {PandDeleteArgs} args - Arguments to delete one Pand.
     * @example
     * // Delete one Pand
     * const Pand = await prisma.pand.delete({
     *   where: {
     *     // ... filter to delete one Pand
     *   }
     * })
     * 
     */
    delete<T extends PandDeleteArgs>(args: SelectSubset<T, PandDeleteArgs<ExtArgs>>): Prisma__PandClient<$Result.GetResult<Prisma.$PandPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Pand.
     * @param {PandUpdateArgs} args - Arguments to update one Pand.
     * @example
     * // Update one Pand
     * const pand = await prisma.pand.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PandUpdateArgs>(args: SelectSubset<T, PandUpdateArgs<ExtArgs>>): Prisma__PandClient<$Result.GetResult<Prisma.$PandPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Pands.
     * @param {PandDeleteManyArgs} args - Arguments to filter Pands to delete.
     * @example
     * // Delete a few Pands
     * const { count } = await prisma.pand.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PandDeleteManyArgs>(args?: SelectSubset<T, PandDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PandUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pands
     * const pand = await prisma.pand.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PandUpdateManyArgs>(args: SelectSubset<T, PandUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pand.
     * @param {PandUpsertArgs} args - Arguments to update or create a Pand.
     * @example
     * // Update or create a Pand
     * const pand = await prisma.pand.upsert({
     *   create: {
     *     // ... data to create a Pand
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pand we want to update
     *   }
     * })
     */
    upsert<T extends PandUpsertArgs>(args: SelectSubset<T, PandUpsertArgs<ExtArgs>>): Prisma__PandClient<$Result.GetResult<Prisma.$PandPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Pands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PandCountArgs} args - Arguments to filter Pands to count.
     * @example
     * // Count the number of Pands
     * const count = await prisma.pand.count({
     *   where: {
     *     // ... the filter for the Pands we want to count
     *   }
     * })
    **/
    count<T extends PandCountArgs>(
      args?: Subset<T, PandCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PandCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pand.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PandAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PandAggregateArgs>(args: Subset<T, PandAggregateArgs>): Prisma.PrismaPromise<GetPandAggregateType<T>>

    /**
     * Group by Pand.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PandGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PandGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PandGroupByArgs['orderBy'] }
        : { orderBy?: PandGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PandGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPandGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Pand model
   */
  readonly fields: PandFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Pand.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PandClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    verblijfsobjecten<T extends Pand$verblijfsobjectenArgs<ExtArgs> = {}>(args?: Subset<T, Pand$verblijfsobjectenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerblijfsobjectPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Pand model
   */ 
  interface PandFieldRefs {
    readonly identificatie: FieldRef<"Pand", 'String'>
    readonly beginGeldigheid: FieldRef<"Pand", 'DateTime'>
    readonly eindGeldigheid: FieldRef<"Pand", 'DateTime'>
    readonly geconstateerd: FieldRef<"Pand", 'Boolean'>
    readonly documentDatum: FieldRef<"Pand", 'DateTime'>
    readonly documentNummer: FieldRef<"Pand", 'String'>
    readonly geometry: FieldRef<"Pand", 'Json'>
    readonly status: FieldRef<"Pand", 'String'>
    readonly createdAt: FieldRef<"Pand", 'DateTime'>
    readonly updatedAt: FieldRef<"Pand", 'DateTime'>
    readonly oorspronkelijkBouwjaar: FieldRef<"Pand", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Pand findUnique
   */
  export type PandFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pand
     */
    select?: PandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PandInclude<ExtArgs> | null
    /**
     * Filter, which Pand to fetch.
     */
    where: PandWhereUniqueInput
  }

  /**
   * Pand findUniqueOrThrow
   */
  export type PandFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pand
     */
    select?: PandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PandInclude<ExtArgs> | null
    /**
     * Filter, which Pand to fetch.
     */
    where: PandWhereUniqueInput
  }

  /**
   * Pand findFirst
   */
  export type PandFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pand
     */
    select?: PandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PandInclude<ExtArgs> | null
    /**
     * Filter, which Pand to fetch.
     */
    where?: PandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pands to fetch.
     */
    orderBy?: PandOrderByWithRelationInput | PandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pands.
     */
    cursor?: PandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pands.
     */
    distinct?: PandScalarFieldEnum | PandScalarFieldEnum[]
  }

  /**
   * Pand findFirstOrThrow
   */
  export type PandFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pand
     */
    select?: PandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PandInclude<ExtArgs> | null
    /**
     * Filter, which Pand to fetch.
     */
    where?: PandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pands to fetch.
     */
    orderBy?: PandOrderByWithRelationInput | PandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pands.
     */
    cursor?: PandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pands.
     */
    distinct?: PandScalarFieldEnum | PandScalarFieldEnum[]
  }

  /**
   * Pand findMany
   */
  export type PandFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pand
     */
    select?: PandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PandInclude<ExtArgs> | null
    /**
     * Filter, which Pands to fetch.
     */
    where?: PandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pands to fetch.
     */
    orderBy?: PandOrderByWithRelationInput | PandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pands.
     */
    cursor?: PandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pands.
     */
    skip?: number
    distinct?: PandScalarFieldEnum | PandScalarFieldEnum[]
  }

  /**
   * Pand create
   */
  export type PandCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pand
     */
    select?: PandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PandInclude<ExtArgs> | null
    /**
     * The data needed to create a Pand.
     */
    data: XOR<PandCreateInput, PandUncheckedCreateInput>
  }

  /**
   * Pand createMany
   */
  export type PandCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Pands.
     */
    data: PandCreateManyInput | PandCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Pand createManyAndReturn
   */
  export type PandCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pand
     */
    select?: PandSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Pands.
     */
    data: PandCreateManyInput | PandCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Pand update
   */
  export type PandUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pand
     */
    select?: PandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PandInclude<ExtArgs> | null
    /**
     * The data needed to update a Pand.
     */
    data: XOR<PandUpdateInput, PandUncheckedUpdateInput>
    /**
     * Choose, which Pand to update.
     */
    where: PandWhereUniqueInput
  }

  /**
   * Pand updateMany
   */
  export type PandUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Pands.
     */
    data: XOR<PandUpdateManyMutationInput, PandUncheckedUpdateManyInput>
    /**
     * Filter which Pands to update
     */
    where?: PandWhereInput
  }

  /**
   * Pand upsert
   */
  export type PandUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pand
     */
    select?: PandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PandInclude<ExtArgs> | null
    /**
     * The filter to search for the Pand to update in case it exists.
     */
    where: PandWhereUniqueInput
    /**
     * In case the Pand found by the `where` argument doesn't exist, create a new Pand with this data.
     */
    create: XOR<PandCreateInput, PandUncheckedCreateInput>
    /**
     * In case the Pand was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PandUpdateInput, PandUncheckedUpdateInput>
  }

  /**
   * Pand delete
   */
  export type PandDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pand
     */
    select?: PandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PandInclude<ExtArgs> | null
    /**
     * Filter which Pand to delete.
     */
    where: PandWhereUniqueInput
  }

  /**
   * Pand deleteMany
   */
  export type PandDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pands to delete
     */
    where?: PandWhereInput
  }

  /**
   * Pand.verblijfsobjecten
   */
  export type Pand$verblijfsobjectenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verblijfsobject
     */
    select?: VerblijfsobjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerblijfsobjectInclude<ExtArgs> | null
    where?: VerblijfsobjectWhereInput
    orderBy?: VerblijfsobjectOrderByWithRelationInput | VerblijfsobjectOrderByWithRelationInput[]
    cursor?: VerblijfsobjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VerblijfsobjectScalarFieldEnum | VerblijfsobjectScalarFieldEnum[]
  }

  /**
   * Pand without action
   */
  export type PandDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pand
     */
    select?: PandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PandInclude<ExtArgs> | null
  }


  /**
   * Model Nummeraanduiding
   */

  export type AggregateNummeraanduiding = {
    _count: NummeraanduidingCountAggregateOutputType | null
    _avg: NummeraanduidingAvgAggregateOutputType | null
    _sum: NummeraanduidingSumAggregateOutputType | null
    _min: NummeraanduidingMinAggregateOutputType | null
    _max: NummeraanduidingMaxAggregateOutputType | null
  }

  export type NummeraanduidingAvgAggregateOutputType = {
    huisnummer: number | null
  }

  export type NummeraanduidingSumAggregateOutputType = {
    huisnummer: number | null
  }

  export type NummeraanduidingMinAggregateOutputType = {
    identificatie: string | null
    beginGeldigheid: Date | null
    eindGeldigheid: Date | null
    geconstateerd: boolean | null
    documentDatum: Date | null
    documentNummer: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    huisnummer: number | null
    huisletter: string | null
    huisnummertoevoeging: string | null
    postcode: string | null
    type: string | null
    openbareRuimteId: string | null
  }

  export type NummeraanduidingMaxAggregateOutputType = {
    identificatie: string | null
    beginGeldigheid: Date | null
    eindGeldigheid: Date | null
    geconstateerd: boolean | null
    documentDatum: Date | null
    documentNummer: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    huisnummer: number | null
    huisletter: string | null
    huisnummertoevoeging: string | null
    postcode: string | null
    type: string | null
    openbareRuimteId: string | null
  }

  export type NummeraanduidingCountAggregateOutputType = {
    identificatie: number
    beginGeldigheid: number
    eindGeldigheid: number
    geconstateerd: number
    documentDatum: number
    documentNummer: number
    geometry: number
    status: number
    createdAt: number
    updatedAt: number
    huisnummer: number
    huisletter: number
    huisnummertoevoeging: number
    postcode: number
    type: number
    openbareRuimteId: number
    _all: number
  }


  export type NummeraanduidingAvgAggregateInputType = {
    huisnummer?: true
  }

  export type NummeraanduidingSumAggregateInputType = {
    huisnummer?: true
  }

  export type NummeraanduidingMinAggregateInputType = {
    identificatie?: true
    beginGeldigheid?: true
    eindGeldigheid?: true
    geconstateerd?: true
    documentDatum?: true
    documentNummer?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    huisnummer?: true
    huisletter?: true
    huisnummertoevoeging?: true
    postcode?: true
    type?: true
    openbareRuimteId?: true
  }

  export type NummeraanduidingMaxAggregateInputType = {
    identificatie?: true
    beginGeldigheid?: true
    eindGeldigheid?: true
    geconstateerd?: true
    documentDatum?: true
    documentNummer?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    huisnummer?: true
    huisletter?: true
    huisnummertoevoeging?: true
    postcode?: true
    type?: true
    openbareRuimteId?: true
  }

  export type NummeraanduidingCountAggregateInputType = {
    identificatie?: true
    beginGeldigheid?: true
    eindGeldigheid?: true
    geconstateerd?: true
    documentDatum?: true
    documentNummer?: true
    geometry?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    huisnummer?: true
    huisletter?: true
    huisnummertoevoeging?: true
    postcode?: true
    type?: true
    openbareRuimteId?: true
    _all?: true
  }

  export type NummeraanduidingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Nummeraanduiding to aggregate.
     */
    where?: NummeraanduidingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Nummeraanduidings to fetch.
     */
    orderBy?: NummeraanduidingOrderByWithRelationInput | NummeraanduidingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NummeraanduidingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Nummeraanduidings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Nummeraanduidings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Nummeraanduidings
    **/
    _count?: true | NummeraanduidingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NummeraanduidingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NummeraanduidingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NummeraanduidingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NummeraanduidingMaxAggregateInputType
  }

  export type GetNummeraanduidingAggregateType<T extends NummeraanduidingAggregateArgs> = {
        [P in keyof T & keyof AggregateNummeraanduiding]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNummeraanduiding[P]>
      : GetScalarType<T[P], AggregateNummeraanduiding[P]>
  }




  export type NummeraanduidingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NummeraanduidingWhereInput
    orderBy?: NummeraanduidingOrderByWithAggregationInput | NummeraanduidingOrderByWithAggregationInput[]
    by: NummeraanduidingScalarFieldEnum[] | NummeraanduidingScalarFieldEnum
    having?: NummeraanduidingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NummeraanduidingCountAggregateInputType | true
    _avg?: NummeraanduidingAvgAggregateInputType
    _sum?: NummeraanduidingSumAggregateInputType
    _min?: NummeraanduidingMinAggregateInputType
    _max?: NummeraanduidingMaxAggregateInputType
  }

  export type NummeraanduidingGroupByOutputType = {
    identificatie: string
    beginGeldigheid: Date
    eindGeldigheid: Date | null
    geconstateerd: boolean
    documentDatum: Date
    documentNummer: string
    geometry: JsonValue | null
    status: string
    createdAt: Date
    updatedAt: Date
    huisnummer: number
    huisletter: string | null
    huisnummertoevoeging: string | null
    postcode: string | null
    type: string
    openbareRuimteId: string
    _count: NummeraanduidingCountAggregateOutputType | null
    _avg: NummeraanduidingAvgAggregateOutputType | null
    _sum: NummeraanduidingSumAggregateOutputType | null
    _min: NummeraanduidingMinAggregateOutputType | null
    _max: NummeraanduidingMaxAggregateOutputType | null
  }

  type GetNummeraanduidingGroupByPayload<T extends NummeraanduidingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NummeraanduidingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NummeraanduidingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NummeraanduidingGroupByOutputType[P]>
            : GetScalarType<T[P], NummeraanduidingGroupByOutputType[P]>
        }
      >
    >


  export type NummeraanduidingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identificatie?: boolean
    beginGeldigheid?: boolean
    eindGeldigheid?: boolean
    geconstateerd?: boolean
    documentDatum?: boolean
    documentNummer?: boolean
    geometry?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    huisnummer?: boolean
    huisletter?: boolean
    huisnummertoevoeging?: boolean
    postcode?: boolean
    type?: boolean
    openbareRuimteId?: boolean
    openbareRuimte?: boolean | OpenbareRuimteDefaultArgs<ExtArgs>
    verblijfsobject?: boolean | Nummeraanduiding$verblijfsobjectArgs<ExtArgs>
    ligplaats?: boolean | Nummeraanduiding$ligplaatsArgs<ExtArgs>
    standplaats?: boolean | Nummeraanduiding$standplaatsArgs<ExtArgs>
  }, ExtArgs["result"]["nummeraanduiding"]>

  export type NummeraanduidingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identificatie?: boolean
    beginGeldigheid?: boolean
    eindGeldigheid?: boolean
    geconstateerd?: boolean
    documentDatum?: boolean
    documentNummer?: boolean
    geometry?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    huisnummer?: boolean
    huisletter?: boolean
    huisnummertoevoeging?: boolean
    postcode?: boolean
    type?: boolean
    openbareRuimteId?: boolean
    openbareRuimte?: boolean | OpenbareRuimteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nummeraanduiding"]>

  export type NummeraanduidingSelectScalar = {
    identificatie?: boolean
    beginGeldigheid?: boolean
    eindGeldigheid?: boolean
    geconstateerd?: boolean
    documentDatum?: boolean
    documentNummer?: boolean
    geometry?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    huisnummer?: boolean
    huisletter?: boolean
    huisnummertoevoeging?: boolean
    postcode?: boolean
    type?: boolean
    openbareRuimteId?: boolean
  }

  export type NummeraanduidingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    openbareRuimte?: boolean | OpenbareRuimteDefaultArgs<ExtArgs>
    verblijfsobject?: boolean | Nummeraanduiding$verblijfsobjectArgs<ExtArgs>
    ligplaats?: boolean | Nummeraanduiding$ligplaatsArgs<ExtArgs>
    standplaats?: boolean | Nummeraanduiding$standplaatsArgs<ExtArgs>
  }
  export type NummeraanduidingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    openbareRuimte?: boolean | OpenbareRuimteDefaultArgs<ExtArgs>
  }

  export type $NummeraanduidingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Nummeraanduiding"
    objects: {
      openbareRuimte: Prisma.$OpenbareRuimtePayload<ExtArgs>
      verblijfsobject: Prisma.$VerblijfsobjectPayload<ExtArgs> | null
      ligplaats: Prisma.$LigplaatsPayload<ExtArgs> | null
      standplaats: Prisma.$StandplaatsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      identificatie: string
      beginGeldigheid: Date
      eindGeldigheid: Date | null
      geconstateerd: boolean
      documentDatum: Date
      documentNummer: string
      geometry: Prisma.JsonValue | null
      status: string
      createdAt: Date
      updatedAt: Date
      huisnummer: number
      huisletter: string | null
      huisnummertoevoeging: string | null
      postcode: string | null
      type: string
      openbareRuimteId: string
    }, ExtArgs["result"]["nummeraanduiding"]>
    composites: {}
  }

  type NummeraanduidingGetPayload<S extends boolean | null | undefined | NummeraanduidingDefaultArgs> = $Result.GetResult<Prisma.$NummeraanduidingPayload, S>

  type NummeraanduidingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NummeraanduidingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NummeraanduidingCountAggregateInputType | true
    }

  export interface NummeraanduidingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Nummeraanduiding'], meta: { name: 'Nummeraanduiding' } }
    /**
     * Find zero or one Nummeraanduiding that matches the filter.
     * @param {NummeraanduidingFindUniqueArgs} args - Arguments to find a Nummeraanduiding
     * @example
     * // Get one Nummeraanduiding
     * const nummeraanduiding = await prisma.nummeraanduiding.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NummeraanduidingFindUniqueArgs>(args: SelectSubset<T, NummeraanduidingFindUniqueArgs<ExtArgs>>): Prisma__NummeraanduidingClient<$Result.GetResult<Prisma.$NummeraanduidingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Nummeraanduiding that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NummeraanduidingFindUniqueOrThrowArgs} args - Arguments to find a Nummeraanduiding
     * @example
     * // Get one Nummeraanduiding
     * const nummeraanduiding = await prisma.nummeraanduiding.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NummeraanduidingFindUniqueOrThrowArgs>(args: SelectSubset<T, NummeraanduidingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NummeraanduidingClient<$Result.GetResult<Prisma.$NummeraanduidingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Nummeraanduiding that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NummeraanduidingFindFirstArgs} args - Arguments to find a Nummeraanduiding
     * @example
     * // Get one Nummeraanduiding
     * const nummeraanduiding = await prisma.nummeraanduiding.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NummeraanduidingFindFirstArgs>(args?: SelectSubset<T, NummeraanduidingFindFirstArgs<ExtArgs>>): Prisma__NummeraanduidingClient<$Result.GetResult<Prisma.$NummeraanduidingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Nummeraanduiding that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NummeraanduidingFindFirstOrThrowArgs} args - Arguments to find a Nummeraanduiding
     * @example
     * // Get one Nummeraanduiding
     * const nummeraanduiding = await prisma.nummeraanduiding.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NummeraanduidingFindFirstOrThrowArgs>(args?: SelectSubset<T, NummeraanduidingFindFirstOrThrowArgs<ExtArgs>>): Prisma__NummeraanduidingClient<$Result.GetResult<Prisma.$NummeraanduidingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Nummeraanduidings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NummeraanduidingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Nummeraanduidings
     * const nummeraanduidings = await prisma.nummeraanduiding.findMany()
     * 
     * // Get first 10 Nummeraanduidings
     * const nummeraanduidings = await prisma.nummeraanduiding.findMany({ take: 10 })
     * 
     * // Only select the `identificatie`
     * const nummeraanduidingWithIdentificatieOnly = await prisma.nummeraanduiding.findMany({ select: { identificatie: true } })
     * 
     */
    findMany<T extends NummeraanduidingFindManyArgs>(args?: SelectSubset<T, NummeraanduidingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NummeraanduidingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Nummeraanduiding.
     * @param {NummeraanduidingCreateArgs} args - Arguments to create a Nummeraanduiding.
     * @example
     * // Create one Nummeraanduiding
     * const Nummeraanduiding = await prisma.nummeraanduiding.create({
     *   data: {
     *     // ... data to create a Nummeraanduiding
     *   }
     * })
     * 
     */
    create<T extends NummeraanduidingCreateArgs>(args: SelectSubset<T, NummeraanduidingCreateArgs<ExtArgs>>): Prisma__NummeraanduidingClient<$Result.GetResult<Prisma.$NummeraanduidingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Nummeraanduidings.
     * @param {NummeraanduidingCreateManyArgs} args - Arguments to create many Nummeraanduidings.
     * @example
     * // Create many Nummeraanduidings
     * const nummeraanduiding = await prisma.nummeraanduiding.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NummeraanduidingCreateManyArgs>(args?: SelectSubset<T, NummeraanduidingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Nummeraanduidings and returns the data saved in the database.
     * @param {NummeraanduidingCreateManyAndReturnArgs} args - Arguments to create many Nummeraanduidings.
     * @example
     * // Create many Nummeraanduidings
     * const nummeraanduiding = await prisma.nummeraanduiding.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Nummeraanduidings and only return the `identificatie`
     * const nummeraanduidingWithIdentificatieOnly = await prisma.nummeraanduiding.createManyAndReturn({ 
     *   select: { identificatie: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NummeraanduidingCreateManyAndReturnArgs>(args?: SelectSubset<T, NummeraanduidingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NummeraanduidingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Nummeraanduiding.
     * @param {NummeraanduidingDeleteArgs} args - Arguments to delete one Nummeraanduiding.
     * @example
     * // Delete one Nummeraanduiding
     * const Nummeraanduiding = await prisma.nummeraanduiding.delete({
     *   where: {
     *     // ... filter to delete one Nummeraanduiding
     *   }
     * })
     * 
     */
    delete<T extends NummeraanduidingDeleteArgs>(args: SelectSubset<T, NummeraanduidingDeleteArgs<ExtArgs>>): Prisma__NummeraanduidingClient<$Result.GetResult<Prisma.$NummeraanduidingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Nummeraanduiding.
     * @param {NummeraanduidingUpdateArgs} args - Arguments to update one Nummeraanduiding.
     * @example
     * // Update one Nummeraanduiding
     * const nummeraanduiding = await prisma.nummeraanduiding.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NummeraanduidingUpdateArgs>(args: SelectSubset<T, NummeraanduidingUpdateArgs<ExtArgs>>): Prisma__NummeraanduidingClient<$Result.GetResult<Prisma.$NummeraanduidingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Nummeraanduidings.
     * @param {NummeraanduidingDeleteManyArgs} args - Arguments to filter Nummeraanduidings to delete.
     * @example
     * // Delete a few Nummeraanduidings
     * const { count } = await prisma.nummeraanduiding.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NummeraanduidingDeleteManyArgs>(args?: SelectSubset<T, NummeraanduidingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Nummeraanduidings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NummeraanduidingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Nummeraanduidings
     * const nummeraanduiding = await prisma.nummeraanduiding.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NummeraanduidingUpdateManyArgs>(args: SelectSubset<T, NummeraanduidingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Nummeraanduiding.
     * @param {NummeraanduidingUpsertArgs} args - Arguments to update or create a Nummeraanduiding.
     * @example
     * // Update or create a Nummeraanduiding
     * const nummeraanduiding = await prisma.nummeraanduiding.upsert({
     *   create: {
     *     // ... data to create a Nummeraanduiding
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Nummeraanduiding we want to update
     *   }
     * })
     */
    upsert<T extends NummeraanduidingUpsertArgs>(args: SelectSubset<T, NummeraanduidingUpsertArgs<ExtArgs>>): Prisma__NummeraanduidingClient<$Result.GetResult<Prisma.$NummeraanduidingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Nummeraanduidings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NummeraanduidingCountArgs} args - Arguments to filter Nummeraanduidings to count.
     * @example
     * // Count the number of Nummeraanduidings
     * const count = await prisma.nummeraanduiding.count({
     *   where: {
     *     // ... the filter for the Nummeraanduidings we want to count
     *   }
     * })
    **/
    count<T extends NummeraanduidingCountArgs>(
      args?: Subset<T, NummeraanduidingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NummeraanduidingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Nummeraanduiding.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NummeraanduidingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NummeraanduidingAggregateArgs>(args: Subset<T, NummeraanduidingAggregateArgs>): Prisma.PrismaPromise<GetNummeraanduidingAggregateType<T>>

    /**
     * Group by Nummeraanduiding.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NummeraanduidingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NummeraanduidingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NummeraanduidingGroupByArgs['orderBy'] }
        : { orderBy?: NummeraanduidingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NummeraanduidingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNummeraanduidingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Nummeraanduiding model
   */
  readonly fields: NummeraanduidingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Nummeraanduiding.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NummeraanduidingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    openbareRuimte<T extends OpenbareRuimteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OpenbareRuimteDefaultArgs<ExtArgs>>): Prisma__OpenbareRuimteClient<$Result.GetResult<Prisma.$OpenbareRuimtePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    verblijfsobject<T extends Nummeraanduiding$verblijfsobjectArgs<ExtArgs> = {}>(args?: Subset<T, Nummeraanduiding$verblijfsobjectArgs<ExtArgs>>): Prisma__VerblijfsobjectClient<$Result.GetResult<Prisma.$VerblijfsobjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    ligplaats<T extends Nummeraanduiding$ligplaatsArgs<ExtArgs> = {}>(args?: Subset<T, Nummeraanduiding$ligplaatsArgs<ExtArgs>>): Prisma__LigplaatsClient<$Result.GetResult<Prisma.$LigplaatsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    standplaats<T extends Nummeraanduiding$standplaatsArgs<ExtArgs> = {}>(args?: Subset<T, Nummeraanduiding$standplaatsArgs<ExtArgs>>): Prisma__StandplaatsClient<$Result.GetResult<Prisma.$StandplaatsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Nummeraanduiding model
   */ 
  interface NummeraanduidingFieldRefs {
    readonly identificatie: FieldRef<"Nummeraanduiding", 'String'>
    readonly beginGeldigheid: FieldRef<"Nummeraanduiding", 'DateTime'>
    readonly eindGeldigheid: FieldRef<"Nummeraanduiding", 'DateTime'>
    readonly geconstateerd: FieldRef<"Nummeraanduiding", 'Boolean'>
    readonly documentDatum: FieldRef<"Nummeraanduiding", 'DateTime'>
    readonly documentNummer: FieldRef<"Nummeraanduiding", 'String'>
    readonly geometry: FieldRef<"Nummeraanduiding", 'Json'>
    readonly status: FieldRef<"Nummeraanduiding", 'String'>
    readonly createdAt: FieldRef<"Nummeraanduiding", 'DateTime'>
    readonly updatedAt: FieldRef<"Nummeraanduiding", 'DateTime'>
    readonly huisnummer: FieldRef<"Nummeraanduiding", 'Int'>
    readonly huisletter: FieldRef<"Nummeraanduiding", 'String'>
    readonly huisnummertoevoeging: FieldRef<"Nummeraanduiding", 'String'>
    readonly postcode: FieldRef<"Nummeraanduiding", 'String'>
    readonly type: FieldRef<"Nummeraanduiding", 'String'>
    readonly openbareRuimteId: FieldRef<"Nummeraanduiding", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Nummeraanduiding findUnique
   */
  export type NummeraanduidingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nummeraanduiding
     */
    select?: NummeraanduidingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NummeraanduidingInclude<ExtArgs> | null
    /**
     * Filter, which Nummeraanduiding to fetch.
     */
    where: NummeraanduidingWhereUniqueInput
  }

  /**
   * Nummeraanduiding findUniqueOrThrow
   */
  export type NummeraanduidingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nummeraanduiding
     */
    select?: NummeraanduidingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NummeraanduidingInclude<ExtArgs> | null
    /**
     * Filter, which Nummeraanduiding to fetch.
     */
    where: NummeraanduidingWhereUniqueInput
  }

  /**
   * Nummeraanduiding findFirst
   */
  export type NummeraanduidingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nummeraanduiding
     */
    select?: NummeraanduidingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NummeraanduidingInclude<ExtArgs> | null
    /**
     * Filter, which Nummeraanduiding to fetch.
     */
    where?: NummeraanduidingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Nummeraanduidings to fetch.
     */
    orderBy?: NummeraanduidingOrderByWithRelationInput | NummeraanduidingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Nummeraanduidings.
     */
    cursor?: NummeraanduidingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Nummeraanduidings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Nummeraanduidings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Nummeraanduidings.
     */
    distinct?: NummeraanduidingScalarFieldEnum | NummeraanduidingScalarFieldEnum[]
  }

  /**
   * Nummeraanduiding findFirstOrThrow
   */
  export type NummeraanduidingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nummeraanduiding
     */
    select?: NummeraanduidingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NummeraanduidingInclude<ExtArgs> | null
    /**
     * Filter, which Nummeraanduiding to fetch.
     */
    where?: NummeraanduidingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Nummeraanduidings to fetch.
     */
    orderBy?: NummeraanduidingOrderByWithRelationInput | NummeraanduidingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Nummeraanduidings.
     */
    cursor?: NummeraanduidingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Nummeraanduidings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Nummeraanduidings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Nummeraanduidings.
     */
    distinct?: NummeraanduidingScalarFieldEnum | NummeraanduidingScalarFieldEnum[]
  }

  /**
   * Nummeraanduiding findMany
   */
  export type NummeraanduidingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nummeraanduiding
     */
    select?: NummeraanduidingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NummeraanduidingInclude<ExtArgs> | null
    /**
     * Filter, which Nummeraanduidings to fetch.
     */
    where?: NummeraanduidingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Nummeraanduidings to fetch.
     */
    orderBy?: NummeraanduidingOrderByWithRelationInput | NummeraanduidingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Nummeraanduidings.
     */
    cursor?: NummeraanduidingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Nummeraanduidings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Nummeraanduidings.
     */
    skip?: number
    distinct?: NummeraanduidingScalarFieldEnum | NummeraanduidingScalarFieldEnum[]
  }

  /**
   * Nummeraanduiding create
   */
  export type NummeraanduidingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nummeraanduiding
     */
    select?: NummeraanduidingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NummeraanduidingInclude<ExtArgs> | null
    /**
     * The data needed to create a Nummeraanduiding.
     */
    data: XOR<NummeraanduidingCreateInput, NummeraanduidingUncheckedCreateInput>
  }

  /**
   * Nummeraanduiding createMany
   */
  export type NummeraanduidingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Nummeraanduidings.
     */
    data: NummeraanduidingCreateManyInput | NummeraanduidingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Nummeraanduiding createManyAndReturn
   */
  export type NummeraanduidingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nummeraanduiding
     */
    select?: NummeraanduidingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Nummeraanduidings.
     */
    data: NummeraanduidingCreateManyInput | NummeraanduidingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NummeraanduidingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Nummeraanduiding update
   */
  export type NummeraanduidingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nummeraanduiding
     */
    select?: NummeraanduidingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NummeraanduidingInclude<ExtArgs> | null
    /**
     * The data needed to update a Nummeraanduiding.
     */
    data: XOR<NummeraanduidingUpdateInput, NummeraanduidingUncheckedUpdateInput>
    /**
     * Choose, which Nummeraanduiding to update.
     */
    where: NummeraanduidingWhereUniqueInput
  }

  /**
   * Nummeraanduiding updateMany
   */
  export type NummeraanduidingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Nummeraanduidings.
     */
    data: XOR<NummeraanduidingUpdateManyMutationInput, NummeraanduidingUncheckedUpdateManyInput>
    /**
     * Filter which Nummeraanduidings to update
     */
    where?: NummeraanduidingWhereInput
  }

  /**
   * Nummeraanduiding upsert
   */
  export type NummeraanduidingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nummeraanduiding
     */
    select?: NummeraanduidingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NummeraanduidingInclude<ExtArgs> | null
    /**
     * The filter to search for the Nummeraanduiding to update in case it exists.
     */
    where: NummeraanduidingWhereUniqueInput
    /**
     * In case the Nummeraanduiding found by the `where` argument doesn't exist, create a new Nummeraanduiding with this data.
     */
    create: XOR<NummeraanduidingCreateInput, NummeraanduidingUncheckedCreateInput>
    /**
     * In case the Nummeraanduiding was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NummeraanduidingUpdateInput, NummeraanduidingUncheckedUpdateInput>
  }

  /**
   * Nummeraanduiding delete
   */
  export type NummeraanduidingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nummeraanduiding
     */
    select?: NummeraanduidingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NummeraanduidingInclude<ExtArgs> | null
    /**
     * Filter which Nummeraanduiding to delete.
     */
    where: NummeraanduidingWhereUniqueInput
  }

  /**
   * Nummeraanduiding deleteMany
   */
  export type NummeraanduidingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Nummeraanduidings to delete
     */
    where?: NummeraanduidingWhereInput
  }

  /**
   * Nummeraanduiding.verblijfsobject
   */
  export type Nummeraanduiding$verblijfsobjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verblijfsobject
     */
    select?: VerblijfsobjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerblijfsobjectInclude<ExtArgs> | null
    where?: VerblijfsobjectWhereInput
  }

  /**
   * Nummeraanduiding.ligplaats
   */
  export type Nummeraanduiding$ligplaatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ligplaats
     */
    select?: LigplaatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigplaatsInclude<ExtArgs> | null
    where?: LigplaatsWhereInput
  }

  /**
   * Nummeraanduiding.standplaats
   */
  export type Nummeraanduiding$standplaatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Standplaats
     */
    select?: StandplaatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandplaatsInclude<ExtArgs> | null
    where?: StandplaatsWhereInput
  }

  /**
   * Nummeraanduiding without action
   */
  export type NummeraanduidingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nummeraanduiding
     */
    select?: NummeraanduidingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NummeraanduidingInclude<ExtArgs> | null
  }


  /**
   * Model Verblijfsobject
   */

  export type AggregateVerblijfsobject = {
    _count: VerblijfsobjectCountAggregateOutputType | null
    _avg: VerblijfsobjectAvgAggregateOutputType | null
    _sum: VerblijfsobjectSumAggregateOutputType | null
    _min: VerblijfsobjectMinAggregateOutputType | null
    _max: VerblijfsobjectMaxAggregateOutputType | null
  }

  export type VerblijfsobjectAvgAggregateOutputType = {
    rd_x: number | null
    rd_y: number | null
    longitude: number | null
    latitude: number | null
    oppervlakte: number | null
  }

  export type VerblijfsobjectSumAggregateOutputType = {
    rd_x: number | null
    rd_y: number | null
    longitude: number | null
    latitude: number | null
    oppervlakte: number | null
  }

  export type VerblijfsobjectMinAggregateOutputType = {
    identificatie: string | null
    beginGeldigheid: Date | null
    eindGeldigheid: Date | null
    geconstateerd: boolean | null
    documentDatum: Date | null
    documentNummer: string | null
    rd_x: number | null
    rd_y: number | null
    longitude: number | null
    latitude: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    oppervlakte: number | null
    nummeraanduidingId: string | null
    pandId: string | null
  }

  export type VerblijfsobjectMaxAggregateOutputType = {
    identificatie: string | null
    beginGeldigheid: Date | null
    eindGeldigheid: Date | null
    geconstateerd: boolean | null
    documentDatum: Date | null
    documentNummer: string | null
    rd_x: number | null
    rd_y: number | null
    longitude: number | null
    latitude: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    oppervlakte: number | null
    nummeraanduidingId: string | null
    pandId: string | null
  }

  export type VerblijfsobjectCountAggregateOutputType = {
    identificatie: number
    beginGeldigheid: number
    eindGeldigheid: number
    geconstateerd: number
    documentDatum: number
    documentNummer: number
    geometry: number
    rd_x: number
    rd_y: number
    longitude: number
    latitude: number
    status: number
    createdAt: number
    updatedAt: number
    gebruiksdoel: number
    oppervlakte: number
    nummeraanduidingId: number
    pandId: number
    _all: number
  }


  export type VerblijfsobjectAvgAggregateInputType = {
    rd_x?: true
    rd_y?: true
    longitude?: true
    latitude?: true
    oppervlakte?: true
  }

  export type VerblijfsobjectSumAggregateInputType = {
    rd_x?: true
    rd_y?: true
    longitude?: true
    latitude?: true
    oppervlakte?: true
  }

  export type VerblijfsobjectMinAggregateInputType = {
    identificatie?: true
    beginGeldigheid?: true
    eindGeldigheid?: true
    geconstateerd?: true
    documentDatum?: true
    documentNummer?: true
    rd_x?: true
    rd_y?: true
    longitude?: true
    latitude?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    oppervlakte?: true
    nummeraanduidingId?: true
    pandId?: true
  }

  export type VerblijfsobjectMaxAggregateInputType = {
    identificatie?: true
    beginGeldigheid?: true
    eindGeldigheid?: true
    geconstateerd?: true
    documentDatum?: true
    documentNummer?: true
    rd_x?: true
    rd_y?: true
    longitude?: true
    latitude?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    oppervlakte?: true
    nummeraanduidingId?: true
    pandId?: true
  }

  export type VerblijfsobjectCountAggregateInputType = {
    identificatie?: true
    beginGeldigheid?: true
    eindGeldigheid?: true
    geconstateerd?: true
    documentDatum?: true
    documentNummer?: true
    geometry?: true
    rd_x?: true
    rd_y?: true
    longitude?: true
    latitude?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    gebruiksdoel?: true
    oppervlakte?: true
    nummeraanduidingId?: true
    pandId?: true
    _all?: true
  }

  export type VerblijfsobjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verblijfsobject to aggregate.
     */
    where?: VerblijfsobjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verblijfsobjects to fetch.
     */
    orderBy?: VerblijfsobjectOrderByWithRelationInput | VerblijfsobjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerblijfsobjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verblijfsobjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verblijfsobjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Verblijfsobjects
    **/
    _count?: true | VerblijfsobjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VerblijfsobjectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VerblijfsobjectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerblijfsobjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerblijfsobjectMaxAggregateInputType
  }

  export type GetVerblijfsobjectAggregateType<T extends VerblijfsobjectAggregateArgs> = {
        [P in keyof T & keyof AggregateVerblijfsobject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerblijfsobject[P]>
      : GetScalarType<T[P], AggregateVerblijfsobject[P]>
  }




  export type VerblijfsobjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerblijfsobjectWhereInput
    orderBy?: VerblijfsobjectOrderByWithAggregationInput | VerblijfsobjectOrderByWithAggregationInput[]
    by: VerblijfsobjectScalarFieldEnum[] | VerblijfsobjectScalarFieldEnum
    having?: VerblijfsobjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerblijfsobjectCountAggregateInputType | true
    _avg?: VerblijfsobjectAvgAggregateInputType
    _sum?: VerblijfsobjectSumAggregateInputType
    _min?: VerblijfsobjectMinAggregateInputType
    _max?: VerblijfsobjectMaxAggregateInputType
  }

  export type VerblijfsobjectGroupByOutputType = {
    identificatie: string
    beginGeldigheid: Date
    eindGeldigheid: Date | null
    geconstateerd: boolean
    documentDatum: Date
    documentNummer: string
    geometry: JsonValue | null
    rd_x: number | null
    rd_y: number | null
    longitude: number | null
    latitude: number | null
    status: string
    createdAt: Date
    updatedAt: Date
    gebruiksdoel: string[]
    oppervlakte: number
    nummeraanduidingId: string
    pandId: string
    _count: VerblijfsobjectCountAggregateOutputType | null
    _avg: VerblijfsobjectAvgAggregateOutputType | null
    _sum: VerblijfsobjectSumAggregateOutputType | null
    _min: VerblijfsobjectMinAggregateOutputType | null
    _max: VerblijfsobjectMaxAggregateOutputType | null
  }

  type GetVerblijfsobjectGroupByPayload<T extends VerblijfsobjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerblijfsobjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerblijfsobjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerblijfsobjectGroupByOutputType[P]>
            : GetScalarType<T[P], VerblijfsobjectGroupByOutputType[P]>
        }
      >
    >


  export type VerblijfsobjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identificatie?: boolean
    beginGeldigheid?: boolean
    eindGeldigheid?: boolean
    geconstateerd?: boolean
    documentDatum?: boolean
    documentNummer?: boolean
    geometry?: boolean
    rd_x?: boolean
    rd_y?: boolean
    longitude?: boolean
    latitude?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gebruiksdoel?: boolean
    oppervlakte?: boolean
    nummeraanduidingId?: boolean
    pandId?: boolean
    nummeraanduiding?: boolean | NummeraanduidingDefaultArgs<ExtArgs>
    pand?: boolean | PandDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verblijfsobject"]>

  export type VerblijfsobjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identificatie?: boolean
    beginGeldigheid?: boolean
    eindGeldigheid?: boolean
    geconstateerd?: boolean
    documentDatum?: boolean
    documentNummer?: boolean
    geometry?: boolean
    rd_x?: boolean
    rd_y?: boolean
    longitude?: boolean
    latitude?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gebruiksdoel?: boolean
    oppervlakte?: boolean
    nummeraanduidingId?: boolean
    pandId?: boolean
    nummeraanduiding?: boolean | NummeraanduidingDefaultArgs<ExtArgs>
    pand?: boolean | PandDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verblijfsobject"]>

  export type VerblijfsobjectSelectScalar = {
    identificatie?: boolean
    beginGeldigheid?: boolean
    eindGeldigheid?: boolean
    geconstateerd?: boolean
    documentDatum?: boolean
    documentNummer?: boolean
    geometry?: boolean
    rd_x?: boolean
    rd_y?: boolean
    longitude?: boolean
    latitude?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gebruiksdoel?: boolean
    oppervlakte?: boolean
    nummeraanduidingId?: boolean
    pandId?: boolean
  }

  export type VerblijfsobjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nummeraanduiding?: boolean | NummeraanduidingDefaultArgs<ExtArgs>
    pand?: boolean | PandDefaultArgs<ExtArgs>
  }
  export type VerblijfsobjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nummeraanduiding?: boolean | NummeraanduidingDefaultArgs<ExtArgs>
    pand?: boolean | PandDefaultArgs<ExtArgs>
  }

  export type $VerblijfsobjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Verblijfsobject"
    objects: {
      nummeraanduiding: Prisma.$NummeraanduidingPayload<ExtArgs>
      pand: Prisma.$PandPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      identificatie: string
      beginGeldigheid: Date
      eindGeldigheid: Date | null
      geconstateerd: boolean
      documentDatum: Date
      documentNummer: string
      geometry: Prisma.JsonValue | null
      rd_x: number | null
      rd_y: number | null
      longitude: number | null
      latitude: number | null
      status: string
      createdAt: Date
      updatedAt: Date
      gebruiksdoel: string[]
      oppervlakte: number
      nummeraanduidingId: string
      pandId: string
    }, ExtArgs["result"]["verblijfsobject"]>
    composites: {}
  }

  type VerblijfsobjectGetPayload<S extends boolean | null | undefined | VerblijfsobjectDefaultArgs> = $Result.GetResult<Prisma.$VerblijfsobjectPayload, S>

  type VerblijfsobjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VerblijfsobjectFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VerblijfsobjectCountAggregateInputType | true
    }

  export interface VerblijfsobjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Verblijfsobject'], meta: { name: 'Verblijfsobject' } }
    /**
     * Find zero or one Verblijfsobject that matches the filter.
     * @param {VerblijfsobjectFindUniqueArgs} args - Arguments to find a Verblijfsobject
     * @example
     * // Get one Verblijfsobject
     * const verblijfsobject = await prisma.verblijfsobject.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerblijfsobjectFindUniqueArgs>(args: SelectSubset<T, VerblijfsobjectFindUniqueArgs<ExtArgs>>): Prisma__VerblijfsobjectClient<$Result.GetResult<Prisma.$VerblijfsobjectPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Verblijfsobject that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VerblijfsobjectFindUniqueOrThrowArgs} args - Arguments to find a Verblijfsobject
     * @example
     * // Get one Verblijfsobject
     * const verblijfsobject = await prisma.verblijfsobject.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerblijfsobjectFindUniqueOrThrowArgs>(args: SelectSubset<T, VerblijfsobjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerblijfsobjectClient<$Result.GetResult<Prisma.$VerblijfsobjectPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Verblijfsobject that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerblijfsobjectFindFirstArgs} args - Arguments to find a Verblijfsobject
     * @example
     * // Get one Verblijfsobject
     * const verblijfsobject = await prisma.verblijfsobject.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerblijfsobjectFindFirstArgs>(args?: SelectSubset<T, VerblijfsobjectFindFirstArgs<ExtArgs>>): Prisma__VerblijfsobjectClient<$Result.GetResult<Prisma.$VerblijfsobjectPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Verblijfsobject that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerblijfsobjectFindFirstOrThrowArgs} args - Arguments to find a Verblijfsobject
     * @example
     * // Get one Verblijfsobject
     * const verblijfsobject = await prisma.verblijfsobject.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerblijfsobjectFindFirstOrThrowArgs>(args?: SelectSubset<T, VerblijfsobjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerblijfsobjectClient<$Result.GetResult<Prisma.$VerblijfsobjectPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Verblijfsobjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerblijfsobjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Verblijfsobjects
     * const verblijfsobjects = await prisma.verblijfsobject.findMany()
     * 
     * // Get first 10 Verblijfsobjects
     * const verblijfsobjects = await prisma.verblijfsobject.findMany({ take: 10 })
     * 
     * // Only select the `identificatie`
     * const verblijfsobjectWithIdentificatieOnly = await prisma.verblijfsobject.findMany({ select: { identificatie: true } })
     * 
     */
    findMany<T extends VerblijfsobjectFindManyArgs>(args?: SelectSubset<T, VerblijfsobjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerblijfsobjectPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Verblijfsobject.
     * @param {VerblijfsobjectCreateArgs} args - Arguments to create a Verblijfsobject.
     * @example
     * // Create one Verblijfsobject
     * const Verblijfsobject = await prisma.verblijfsobject.create({
     *   data: {
     *     // ... data to create a Verblijfsobject
     *   }
     * })
     * 
     */
    create<T extends VerblijfsobjectCreateArgs>(args: SelectSubset<T, VerblijfsobjectCreateArgs<ExtArgs>>): Prisma__VerblijfsobjectClient<$Result.GetResult<Prisma.$VerblijfsobjectPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Verblijfsobjects.
     * @param {VerblijfsobjectCreateManyArgs} args - Arguments to create many Verblijfsobjects.
     * @example
     * // Create many Verblijfsobjects
     * const verblijfsobject = await prisma.verblijfsobject.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerblijfsobjectCreateManyArgs>(args?: SelectSubset<T, VerblijfsobjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Verblijfsobjects and returns the data saved in the database.
     * @param {VerblijfsobjectCreateManyAndReturnArgs} args - Arguments to create many Verblijfsobjects.
     * @example
     * // Create many Verblijfsobjects
     * const verblijfsobject = await prisma.verblijfsobject.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Verblijfsobjects and only return the `identificatie`
     * const verblijfsobjectWithIdentificatieOnly = await prisma.verblijfsobject.createManyAndReturn({ 
     *   select: { identificatie: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerblijfsobjectCreateManyAndReturnArgs>(args?: SelectSubset<T, VerblijfsobjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerblijfsobjectPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Verblijfsobject.
     * @param {VerblijfsobjectDeleteArgs} args - Arguments to delete one Verblijfsobject.
     * @example
     * // Delete one Verblijfsobject
     * const Verblijfsobject = await prisma.verblijfsobject.delete({
     *   where: {
     *     // ... filter to delete one Verblijfsobject
     *   }
     * })
     * 
     */
    delete<T extends VerblijfsobjectDeleteArgs>(args: SelectSubset<T, VerblijfsobjectDeleteArgs<ExtArgs>>): Prisma__VerblijfsobjectClient<$Result.GetResult<Prisma.$VerblijfsobjectPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Verblijfsobject.
     * @param {VerblijfsobjectUpdateArgs} args - Arguments to update one Verblijfsobject.
     * @example
     * // Update one Verblijfsobject
     * const verblijfsobject = await prisma.verblijfsobject.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerblijfsobjectUpdateArgs>(args: SelectSubset<T, VerblijfsobjectUpdateArgs<ExtArgs>>): Prisma__VerblijfsobjectClient<$Result.GetResult<Prisma.$VerblijfsobjectPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Verblijfsobjects.
     * @param {VerblijfsobjectDeleteManyArgs} args - Arguments to filter Verblijfsobjects to delete.
     * @example
     * // Delete a few Verblijfsobjects
     * const { count } = await prisma.verblijfsobject.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerblijfsobjectDeleteManyArgs>(args?: SelectSubset<T, VerblijfsobjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verblijfsobjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerblijfsobjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Verblijfsobjects
     * const verblijfsobject = await prisma.verblijfsobject.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerblijfsobjectUpdateManyArgs>(args: SelectSubset<T, VerblijfsobjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Verblijfsobject.
     * @param {VerblijfsobjectUpsertArgs} args - Arguments to update or create a Verblijfsobject.
     * @example
     * // Update or create a Verblijfsobject
     * const verblijfsobject = await prisma.verblijfsobject.upsert({
     *   create: {
     *     // ... data to create a Verblijfsobject
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Verblijfsobject we want to update
     *   }
     * })
     */
    upsert<T extends VerblijfsobjectUpsertArgs>(args: SelectSubset<T, VerblijfsobjectUpsertArgs<ExtArgs>>): Prisma__VerblijfsobjectClient<$Result.GetResult<Prisma.$VerblijfsobjectPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Verblijfsobjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerblijfsobjectCountArgs} args - Arguments to filter Verblijfsobjects to count.
     * @example
     * // Count the number of Verblijfsobjects
     * const count = await prisma.verblijfsobject.count({
     *   where: {
     *     // ... the filter for the Verblijfsobjects we want to count
     *   }
     * })
    **/
    count<T extends VerblijfsobjectCountArgs>(
      args?: Subset<T, VerblijfsobjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerblijfsobjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Verblijfsobject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerblijfsobjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerblijfsobjectAggregateArgs>(args: Subset<T, VerblijfsobjectAggregateArgs>): Prisma.PrismaPromise<GetVerblijfsobjectAggregateType<T>>

    /**
     * Group by Verblijfsobject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerblijfsobjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerblijfsobjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerblijfsobjectGroupByArgs['orderBy'] }
        : { orderBy?: VerblijfsobjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerblijfsobjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerblijfsobjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Verblijfsobject model
   */
  readonly fields: VerblijfsobjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Verblijfsobject.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerblijfsobjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    nummeraanduiding<T extends NummeraanduidingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NummeraanduidingDefaultArgs<ExtArgs>>): Prisma__NummeraanduidingClient<$Result.GetResult<Prisma.$NummeraanduidingPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    pand<T extends PandDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PandDefaultArgs<ExtArgs>>): Prisma__PandClient<$Result.GetResult<Prisma.$PandPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Verblijfsobject model
   */ 
  interface VerblijfsobjectFieldRefs {
    readonly identificatie: FieldRef<"Verblijfsobject", 'String'>
    readonly beginGeldigheid: FieldRef<"Verblijfsobject", 'DateTime'>
    readonly eindGeldigheid: FieldRef<"Verblijfsobject", 'DateTime'>
    readonly geconstateerd: FieldRef<"Verblijfsobject", 'Boolean'>
    readonly documentDatum: FieldRef<"Verblijfsobject", 'DateTime'>
    readonly documentNummer: FieldRef<"Verblijfsobject", 'String'>
    readonly geometry: FieldRef<"Verblijfsobject", 'Json'>
    readonly rd_x: FieldRef<"Verblijfsobject", 'Float'>
    readonly rd_y: FieldRef<"Verblijfsobject", 'Float'>
    readonly longitude: FieldRef<"Verblijfsobject", 'Float'>
    readonly latitude: FieldRef<"Verblijfsobject", 'Float'>
    readonly status: FieldRef<"Verblijfsobject", 'String'>
    readonly createdAt: FieldRef<"Verblijfsobject", 'DateTime'>
    readonly updatedAt: FieldRef<"Verblijfsobject", 'DateTime'>
    readonly gebruiksdoel: FieldRef<"Verblijfsobject", 'String[]'>
    readonly oppervlakte: FieldRef<"Verblijfsobject", 'Int'>
    readonly nummeraanduidingId: FieldRef<"Verblijfsobject", 'String'>
    readonly pandId: FieldRef<"Verblijfsobject", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Verblijfsobject findUnique
   */
  export type VerblijfsobjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verblijfsobject
     */
    select?: VerblijfsobjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerblijfsobjectInclude<ExtArgs> | null
    /**
     * Filter, which Verblijfsobject to fetch.
     */
    where: VerblijfsobjectWhereUniqueInput
  }

  /**
   * Verblijfsobject findUniqueOrThrow
   */
  export type VerblijfsobjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verblijfsobject
     */
    select?: VerblijfsobjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerblijfsobjectInclude<ExtArgs> | null
    /**
     * Filter, which Verblijfsobject to fetch.
     */
    where: VerblijfsobjectWhereUniqueInput
  }

  /**
   * Verblijfsobject findFirst
   */
  export type VerblijfsobjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verblijfsobject
     */
    select?: VerblijfsobjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerblijfsobjectInclude<ExtArgs> | null
    /**
     * Filter, which Verblijfsobject to fetch.
     */
    where?: VerblijfsobjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verblijfsobjects to fetch.
     */
    orderBy?: VerblijfsobjectOrderByWithRelationInput | VerblijfsobjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verblijfsobjects.
     */
    cursor?: VerblijfsobjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verblijfsobjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verblijfsobjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verblijfsobjects.
     */
    distinct?: VerblijfsobjectScalarFieldEnum | VerblijfsobjectScalarFieldEnum[]
  }

  /**
   * Verblijfsobject findFirstOrThrow
   */
  export type VerblijfsobjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verblijfsobject
     */
    select?: VerblijfsobjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerblijfsobjectInclude<ExtArgs> | null
    /**
     * Filter, which Verblijfsobject to fetch.
     */
    where?: VerblijfsobjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verblijfsobjects to fetch.
     */
    orderBy?: VerblijfsobjectOrderByWithRelationInput | VerblijfsobjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verblijfsobjects.
     */
    cursor?: VerblijfsobjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verblijfsobjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verblijfsobjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verblijfsobjects.
     */
    distinct?: VerblijfsobjectScalarFieldEnum | VerblijfsobjectScalarFieldEnum[]
  }

  /**
   * Verblijfsobject findMany
   */
  export type VerblijfsobjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verblijfsobject
     */
    select?: VerblijfsobjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerblijfsobjectInclude<ExtArgs> | null
    /**
     * Filter, which Verblijfsobjects to fetch.
     */
    where?: VerblijfsobjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verblijfsobjects to fetch.
     */
    orderBy?: VerblijfsobjectOrderByWithRelationInput | VerblijfsobjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Verblijfsobjects.
     */
    cursor?: VerblijfsobjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verblijfsobjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verblijfsobjects.
     */
    skip?: number
    distinct?: VerblijfsobjectScalarFieldEnum | VerblijfsobjectScalarFieldEnum[]
  }

  /**
   * Verblijfsobject create
   */
  export type VerblijfsobjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verblijfsobject
     */
    select?: VerblijfsobjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerblijfsobjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Verblijfsobject.
     */
    data: XOR<VerblijfsobjectCreateInput, VerblijfsobjectUncheckedCreateInput>
  }

  /**
   * Verblijfsobject createMany
   */
  export type VerblijfsobjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Verblijfsobjects.
     */
    data: VerblijfsobjectCreateManyInput | VerblijfsobjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Verblijfsobject createManyAndReturn
   */
  export type VerblijfsobjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verblijfsobject
     */
    select?: VerblijfsobjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Verblijfsobjects.
     */
    data: VerblijfsobjectCreateManyInput | VerblijfsobjectCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerblijfsobjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Verblijfsobject update
   */
  export type VerblijfsobjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verblijfsobject
     */
    select?: VerblijfsobjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerblijfsobjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Verblijfsobject.
     */
    data: XOR<VerblijfsobjectUpdateInput, VerblijfsobjectUncheckedUpdateInput>
    /**
     * Choose, which Verblijfsobject to update.
     */
    where: VerblijfsobjectWhereUniqueInput
  }

  /**
   * Verblijfsobject updateMany
   */
  export type VerblijfsobjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Verblijfsobjects.
     */
    data: XOR<VerblijfsobjectUpdateManyMutationInput, VerblijfsobjectUncheckedUpdateManyInput>
    /**
     * Filter which Verblijfsobjects to update
     */
    where?: VerblijfsobjectWhereInput
  }

  /**
   * Verblijfsobject upsert
   */
  export type VerblijfsobjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verblijfsobject
     */
    select?: VerblijfsobjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerblijfsobjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Verblijfsobject to update in case it exists.
     */
    where: VerblijfsobjectWhereUniqueInput
    /**
     * In case the Verblijfsobject found by the `where` argument doesn't exist, create a new Verblijfsobject with this data.
     */
    create: XOR<VerblijfsobjectCreateInput, VerblijfsobjectUncheckedCreateInput>
    /**
     * In case the Verblijfsobject was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerblijfsobjectUpdateInput, VerblijfsobjectUncheckedUpdateInput>
  }

  /**
   * Verblijfsobject delete
   */
  export type VerblijfsobjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verblijfsobject
     */
    select?: VerblijfsobjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerblijfsobjectInclude<ExtArgs> | null
    /**
     * Filter which Verblijfsobject to delete.
     */
    where: VerblijfsobjectWhereUniqueInput
  }

  /**
   * Verblijfsobject deleteMany
   */
  export type VerblijfsobjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verblijfsobjects to delete
     */
    where?: VerblijfsobjectWhereInput
  }

  /**
   * Verblijfsobject without action
   */
  export type VerblijfsobjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verblijfsobject
     */
    select?: VerblijfsobjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerblijfsobjectInclude<ExtArgs> | null
  }


  /**
   * Model spatial_ref_sys
   */

  export type AggregateSpatial_ref_sys = {
    _count: Spatial_ref_sysCountAggregateOutputType | null
    _avg: Spatial_ref_sysAvgAggregateOutputType | null
    _sum: Spatial_ref_sysSumAggregateOutputType | null
    _min: Spatial_ref_sysMinAggregateOutputType | null
    _max: Spatial_ref_sysMaxAggregateOutputType | null
  }

  export type Spatial_ref_sysAvgAggregateOutputType = {
    srid: number | null
    auth_srid: number | null
  }

  export type Spatial_ref_sysSumAggregateOutputType = {
    srid: number | null
    auth_srid: number | null
  }

  export type Spatial_ref_sysMinAggregateOutputType = {
    srid: number | null
    auth_name: string | null
    auth_srid: number | null
    srtext: string | null
    proj4text: string | null
  }

  export type Spatial_ref_sysMaxAggregateOutputType = {
    srid: number | null
    auth_name: string | null
    auth_srid: number | null
    srtext: string | null
    proj4text: string | null
  }

  export type Spatial_ref_sysCountAggregateOutputType = {
    srid: number
    auth_name: number
    auth_srid: number
    srtext: number
    proj4text: number
    _all: number
  }


  export type Spatial_ref_sysAvgAggregateInputType = {
    srid?: true
    auth_srid?: true
  }

  export type Spatial_ref_sysSumAggregateInputType = {
    srid?: true
    auth_srid?: true
  }

  export type Spatial_ref_sysMinAggregateInputType = {
    srid?: true
    auth_name?: true
    auth_srid?: true
    srtext?: true
    proj4text?: true
  }

  export type Spatial_ref_sysMaxAggregateInputType = {
    srid?: true
    auth_name?: true
    auth_srid?: true
    srtext?: true
    proj4text?: true
  }

  export type Spatial_ref_sysCountAggregateInputType = {
    srid?: true
    auth_name?: true
    auth_srid?: true
    srtext?: true
    proj4text?: true
    _all?: true
  }

  export type Spatial_ref_sysAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which spatial_ref_sys to aggregate.
     */
    where?: spatial_ref_sysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of spatial_ref_sys to fetch.
     */
    orderBy?: spatial_ref_sysOrderByWithRelationInput | spatial_ref_sysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: spatial_ref_sysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` spatial_ref_sys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` spatial_ref_sys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned spatial_ref_sys
    **/
    _count?: true | Spatial_ref_sysCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Spatial_ref_sysAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Spatial_ref_sysSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Spatial_ref_sysMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Spatial_ref_sysMaxAggregateInputType
  }

  export type GetSpatial_ref_sysAggregateType<T extends Spatial_ref_sysAggregateArgs> = {
        [P in keyof T & keyof AggregateSpatial_ref_sys]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpatial_ref_sys[P]>
      : GetScalarType<T[P], AggregateSpatial_ref_sys[P]>
  }




  export type spatial_ref_sysGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: spatial_ref_sysWhereInput
    orderBy?: spatial_ref_sysOrderByWithAggregationInput | spatial_ref_sysOrderByWithAggregationInput[]
    by: Spatial_ref_sysScalarFieldEnum[] | Spatial_ref_sysScalarFieldEnum
    having?: spatial_ref_sysScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Spatial_ref_sysCountAggregateInputType | true
    _avg?: Spatial_ref_sysAvgAggregateInputType
    _sum?: Spatial_ref_sysSumAggregateInputType
    _min?: Spatial_ref_sysMinAggregateInputType
    _max?: Spatial_ref_sysMaxAggregateInputType
  }

  export type Spatial_ref_sysGroupByOutputType = {
    srid: number
    auth_name: string | null
    auth_srid: number | null
    srtext: string | null
    proj4text: string | null
    _count: Spatial_ref_sysCountAggregateOutputType | null
    _avg: Spatial_ref_sysAvgAggregateOutputType | null
    _sum: Spatial_ref_sysSumAggregateOutputType | null
    _min: Spatial_ref_sysMinAggregateOutputType | null
    _max: Spatial_ref_sysMaxAggregateOutputType | null
  }

  type GetSpatial_ref_sysGroupByPayload<T extends spatial_ref_sysGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Spatial_ref_sysGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Spatial_ref_sysGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Spatial_ref_sysGroupByOutputType[P]>
            : GetScalarType<T[P], Spatial_ref_sysGroupByOutputType[P]>
        }
      >
    >


  export type spatial_ref_sysSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    srid?: boolean
    auth_name?: boolean
    auth_srid?: boolean
    srtext?: boolean
    proj4text?: boolean
  }, ExtArgs["result"]["spatial_ref_sys"]>

  export type spatial_ref_sysSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    srid?: boolean
    auth_name?: boolean
    auth_srid?: boolean
    srtext?: boolean
    proj4text?: boolean
  }, ExtArgs["result"]["spatial_ref_sys"]>

  export type spatial_ref_sysSelectScalar = {
    srid?: boolean
    auth_name?: boolean
    auth_srid?: boolean
    srtext?: boolean
    proj4text?: boolean
  }


  export type $spatial_ref_sysPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "spatial_ref_sys"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      srid: number
      auth_name: string | null
      auth_srid: number | null
      srtext: string | null
      proj4text: string | null
    }, ExtArgs["result"]["spatial_ref_sys"]>
    composites: {}
  }

  type spatial_ref_sysGetPayload<S extends boolean | null | undefined | spatial_ref_sysDefaultArgs> = $Result.GetResult<Prisma.$spatial_ref_sysPayload, S>

  type spatial_ref_sysCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<spatial_ref_sysFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Spatial_ref_sysCountAggregateInputType | true
    }

  export interface spatial_ref_sysDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['spatial_ref_sys'], meta: { name: 'spatial_ref_sys' } }
    /**
     * Find zero or one Spatial_ref_sys that matches the filter.
     * @param {spatial_ref_sysFindUniqueArgs} args - Arguments to find a Spatial_ref_sys
     * @example
     * // Get one Spatial_ref_sys
     * const spatial_ref_sys = await prisma.spatial_ref_sys.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends spatial_ref_sysFindUniqueArgs>(args: SelectSubset<T, spatial_ref_sysFindUniqueArgs<ExtArgs>>): Prisma__spatial_ref_sysClient<$Result.GetResult<Prisma.$spatial_ref_sysPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Spatial_ref_sys that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {spatial_ref_sysFindUniqueOrThrowArgs} args - Arguments to find a Spatial_ref_sys
     * @example
     * // Get one Spatial_ref_sys
     * const spatial_ref_sys = await prisma.spatial_ref_sys.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends spatial_ref_sysFindUniqueOrThrowArgs>(args: SelectSubset<T, spatial_ref_sysFindUniqueOrThrowArgs<ExtArgs>>): Prisma__spatial_ref_sysClient<$Result.GetResult<Prisma.$spatial_ref_sysPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Spatial_ref_sys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {spatial_ref_sysFindFirstArgs} args - Arguments to find a Spatial_ref_sys
     * @example
     * // Get one Spatial_ref_sys
     * const spatial_ref_sys = await prisma.spatial_ref_sys.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends spatial_ref_sysFindFirstArgs>(args?: SelectSubset<T, spatial_ref_sysFindFirstArgs<ExtArgs>>): Prisma__spatial_ref_sysClient<$Result.GetResult<Prisma.$spatial_ref_sysPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Spatial_ref_sys that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {spatial_ref_sysFindFirstOrThrowArgs} args - Arguments to find a Spatial_ref_sys
     * @example
     * // Get one Spatial_ref_sys
     * const spatial_ref_sys = await prisma.spatial_ref_sys.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends spatial_ref_sysFindFirstOrThrowArgs>(args?: SelectSubset<T, spatial_ref_sysFindFirstOrThrowArgs<ExtArgs>>): Prisma__spatial_ref_sysClient<$Result.GetResult<Prisma.$spatial_ref_sysPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Spatial_ref_sys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {spatial_ref_sysFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Spatial_ref_sys
     * const spatial_ref_sys = await prisma.spatial_ref_sys.findMany()
     * 
     * // Get first 10 Spatial_ref_sys
     * const spatial_ref_sys = await prisma.spatial_ref_sys.findMany({ take: 10 })
     * 
     * // Only select the `srid`
     * const spatial_ref_sysWithSridOnly = await prisma.spatial_ref_sys.findMany({ select: { srid: true } })
     * 
     */
    findMany<T extends spatial_ref_sysFindManyArgs>(args?: SelectSubset<T, spatial_ref_sysFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$spatial_ref_sysPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Spatial_ref_sys.
     * @param {spatial_ref_sysCreateArgs} args - Arguments to create a Spatial_ref_sys.
     * @example
     * // Create one Spatial_ref_sys
     * const Spatial_ref_sys = await prisma.spatial_ref_sys.create({
     *   data: {
     *     // ... data to create a Spatial_ref_sys
     *   }
     * })
     * 
     */
    create<T extends spatial_ref_sysCreateArgs>(args: SelectSubset<T, spatial_ref_sysCreateArgs<ExtArgs>>): Prisma__spatial_ref_sysClient<$Result.GetResult<Prisma.$spatial_ref_sysPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Spatial_ref_sys.
     * @param {spatial_ref_sysCreateManyArgs} args - Arguments to create many Spatial_ref_sys.
     * @example
     * // Create many Spatial_ref_sys
     * const spatial_ref_sys = await prisma.spatial_ref_sys.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends spatial_ref_sysCreateManyArgs>(args?: SelectSubset<T, spatial_ref_sysCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Spatial_ref_sys and returns the data saved in the database.
     * @param {spatial_ref_sysCreateManyAndReturnArgs} args - Arguments to create many Spatial_ref_sys.
     * @example
     * // Create many Spatial_ref_sys
     * const spatial_ref_sys = await prisma.spatial_ref_sys.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Spatial_ref_sys and only return the `srid`
     * const spatial_ref_sysWithSridOnly = await prisma.spatial_ref_sys.createManyAndReturn({ 
     *   select: { srid: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends spatial_ref_sysCreateManyAndReturnArgs>(args?: SelectSubset<T, spatial_ref_sysCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$spatial_ref_sysPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Spatial_ref_sys.
     * @param {spatial_ref_sysDeleteArgs} args - Arguments to delete one Spatial_ref_sys.
     * @example
     * // Delete one Spatial_ref_sys
     * const Spatial_ref_sys = await prisma.spatial_ref_sys.delete({
     *   where: {
     *     // ... filter to delete one Spatial_ref_sys
     *   }
     * })
     * 
     */
    delete<T extends spatial_ref_sysDeleteArgs>(args: SelectSubset<T, spatial_ref_sysDeleteArgs<ExtArgs>>): Prisma__spatial_ref_sysClient<$Result.GetResult<Prisma.$spatial_ref_sysPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Spatial_ref_sys.
     * @param {spatial_ref_sysUpdateArgs} args - Arguments to update one Spatial_ref_sys.
     * @example
     * // Update one Spatial_ref_sys
     * const spatial_ref_sys = await prisma.spatial_ref_sys.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends spatial_ref_sysUpdateArgs>(args: SelectSubset<T, spatial_ref_sysUpdateArgs<ExtArgs>>): Prisma__spatial_ref_sysClient<$Result.GetResult<Prisma.$spatial_ref_sysPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Spatial_ref_sys.
     * @param {spatial_ref_sysDeleteManyArgs} args - Arguments to filter Spatial_ref_sys to delete.
     * @example
     * // Delete a few Spatial_ref_sys
     * const { count } = await prisma.spatial_ref_sys.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends spatial_ref_sysDeleteManyArgs>(args?: SelectSubset<T, spatial_ref_sysDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Spatial_ref_sys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {spatial_ref_sysUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Spatial_ref_sys
     * const spatial_ref_sys = await prisma.spatial_ref_sys.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends spatial_ref_sysUpdateManyArgs>(args: SelectSubset<T, spatial_ref_sysUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Spatial_ref_sys.
     * @param {spatial_ref_sysUpsertArgs} args - Arguments to update or create a Spatial_ref_sys.
     * @example
     * // Update or create a Spatial_ref_sys
     * const spatial_ref_sys = await prisma.spatial_ref_sys.upsert({
     *   create: {
     *     // ... data to create a Spatial_ref_sys
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Spatial_ref_sys we want to update
     *   }
     * })
     */
    upsert<T extends spatial_ref_sysUpsertArgs>(args: SelectSubset<T, spatial_ref_sysUpsertArgs<ExtArgs>>): Prisma__spatial_ref_sysClient<$Result.GetResult<Prisma.$spatial_ref_sysPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Spatial_ref_sys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {spatial_ref_sysCountArgs} args - Arguments to filter Spatial_ref_sys to count.
     * @example
     * // Count the number of Spatial_ref_sys
     * const count = await prisma.spatial_ref_sys.count({
     *   where: {
     *     // ... the filter for the Spatial_ref_sys we want to count
     *   }
     * })
    **/
    count<T extends spatial_ref_sysCountArgs>(
      args?: Subset<T, spatial_ref_sysCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Spatial_ref_sysCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Spatial_ref_sys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Spatial_ref_sysAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Spatial_ref_sysAggregateArgs>(args: Subset<T, Spatial_ref_sysAggregateArgs>): Prisma.PrismaPromise<GetSpatial_ref_sysAggregateType<T>>

    /**
     * Group by Spatial_ref_sys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {spatial_ref_sysGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends spatial_ref_sysGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: spatial_ref_sysGroupByArgs['orderBy'] }
        : { orderBy?: spatial_ref_sysGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, spatial_ref_sysGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpatial_ref_sysGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the spatial_ref_sys model
   */
  readonly fields: spatial_ref_sysFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for spatial_ref_sys.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__spatial_ref_sysClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the spatial_ref_sys model
   */ 
  interface spatial_ref_sysFieldRefs {
    readonly srid: FieldRef<"spatial_ref_sys", 'Int'>
    readonly auth_name: FieldRef<"spatial_ref_sys", 'String'>
    readonly auth_srid: FieldRef<"spatial_ref_sys", 'Int'>
    readonly srtext: FieldRef<"spatial_ref_sys", 'String'>
    readonly proj4text: FieldRef<"spatial_ref_sys", 'String'>
  }
    

  // Custom InputTypes
  /**
   * spatial_ref_sys findUnique
   */
  export type spatial_ref_sysFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the spatial_ref_sys
     */
    select?: spatial_ref_sysSelect<ExtArgs> | null
    /**
     * Filter, which spatial_ref_sys to fetch.
     */
    where: spatial_ref_sysWhereUniqueInput
  }

  /**
   * spatial_ref_sys findUniqueOrThrow
   */
  export type spatial_ref_sysFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the spatial_ref_sys
     */
    select?: spatial_ref_sysSelect<ExtArgs> | null
    /**
     * Filter, which spatial_ref_sys to fetch.
     */
    where: spatial_ref_sysWhereUniqueInput
  }

  /**
   * spatial_ref_sys findFirst
   */
  export type spatial_ref_sysFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the spatial_ref_sys
     */
    select?: spatial_ref_sysSelect<ExtArgs> | null
    /**
     * Filter, which spatial_ref_sys to fetch.
     */
    where?: spatial_ref_sysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of spatial_ref_sys to fetch.
     */
    orderBy?: spatial_ref_sysOrderByWithRelationInput | spatial_ref_sysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for spatial_ref_sys.
     */
    cursor?: spatial_ref_sysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` spatial_ref_sys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` spatial_ref_sys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of spatial_ref_sys.
     */
    distinct?: Spatial_ref_sysScalarFieldEnum | Spatial_ref_sysScalarFieldEnum[]
  }

  /**
   * spatial_ref_sys findFirstOrThrow
   */
  export type spatial_ref_sysFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the spatial_ref_sys
     */
    select?: spatial_ref_sysSelect<ExtArgs> | null
    /**
     * Filter, which spatial_ref_sys to fetch.
     */
    where?: spatial_ref_sysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of spatial_ref_sys to fetch.
     */
    orderBy?: spatial_ref_sysOrderByWithRelationInput | spatial_ref_sysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for spatial_ref_sys.
     */
    cursor?: spatial_ref_sysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` spatial_ref_sys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` spatial_ref_sys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of spatial_ref_sys.
     */
    distinct?: Spatial_ref_sysScalarFieldEnum | Spatial_ref_sysScalarFieldEnum[]
  }

  /**
   * spatial_ref_sys findMany
   */
  export type spatial_ref_sysFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the spatial_ref_sys
     */
    select?: spatial_ref_sysSelect<ExtArgs> | null
    /**
     * Filter, which spatial_ref_sys to fetch.
     */
    where?: spatial_ref_sysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of spatial_ref_sys to fetch.
     */
    orderBy?: spatial_ref_sysOrderByWithRelationInput | spatial_ref_sysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing spatial_ref_sys.
     */
    cursor?: spatial_ref_sysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` spatial_ref_sys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` spatial_ref_sys.
     */
    skip?: number
    distinct?: Spatial_ref_sysScalarFieldEnum | Spatial_ref_sysScalarFieldEnum[]
  }

  /**
   * spatial_ref_sys create
   */
  export type spatial_ref_sysCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the spatial_ref_sys
     */
    select?: spatial_ref_sysSelect<ExtArgs> | null
    /**
     * The data needed to create a spatial_ref_sys.
     */
    data: XOR<spatial_ref_sysCreateInput, spatial_ref_sysUncheckedCreateInput>
  }

  /**
   * spatial_ref_sys createMany
   */
  export type spatial_ref_sysCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many spatial_ref_sys.
     */
    data: spatial_ref_sysCreateManyInput | spatial_ref_sysCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * spatial_ref_sys createManyAndReturn
   */
  export type spatial_ref_sysCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the spatial_ref_sys
     */
    select?: spatial_ref_sysSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many spatial_ref_sys.
     */
    data: spatial_ref_sysCreateManyInput | spatial_ref_sysCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * spatial_ref_sys update
   */
  export type spatial_ref_sysUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the spatial_ref_sys
     */
    select?: spatial_ref_sysSelect<ExtArgs> | null
    /**
     * The data needed to update a spatial_ref_sys.
     */
    data: XOR<spatial_ref_sysUpdateInput, spatial_ref_sysUncheckedUpdateInput>
    /**
     * Choose, which spatial_ref_sys to update.
     */
    where: spatial_ref_sysWhereUniqueInput
  }

  /**
   * spatial_ref_sys updateMany
   */
  export type spatial_ref_sysUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update spatial_ref_sys.
     */
    data: XOR<spatial_ref_sysUpdateManyMutationInput, spatial_ref_sysUncheckedUpdateManyInput>
    /**
     * Filter which spatial_ref_sys to update
     */
    where?: spatial_ref_sysWhereInput
  }

  /**
   * spatial_ref_sys upsert
   */
  export type spatial_ref_sysUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the spatial_ref_sys
     */
    select?: spatial_ref_sysSelect<ExtArgs> | null
    /**
     * The filter to search for the spatial_ref_sys to update in case it exists.
     */
    where: spatial_ref_sysWhereUniqueInput
    /**
     * In case the spatial_ref_sys found by the `where` argument doesn't exist, create a new spatial_ref_sys with this data.
     */
    create: XOR<spatial_ref_sysCreateInput, spatial_ref_sysUncheckedCreateInput>
    /**
     * In case the spatial_ref_sys was found with the provided `where` argument, update it with this data.
     */
    update: XOR<spatial_ref_sysUpdateInput, spatial_ref_sysUncheckedUpdateInput>
  }

  /**
   * spatial_ref_sys delete
   */
  export type spatial_ref_sysDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the spatial_ref_sys
     */
    select?: spatial_ref_sysSelect<ExtArgs> | null
    /**
     * Filter which spatial_ref_sys to delete.
     */
    where: spatial_ref_sysWhereUniqueInput
  }

  /**
   * spatial_ref_sys deleteMany
   */
  export type spatial_ref_sysDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which spatial_ref_sys to delete
     */
    where?: spatial_ref_sysWhereInput
  }

  /**
   * spatial_ref_sys without action
   */
  export type spatial_ref_sysDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the spatial_ref_sys
     */
    select?: spatial_ref_sysSelect<ExtArgs> | null
  }


  /**
   * Model ImportJob
   */

  export type AggregateImportJob = {
    _count: ImportJobCountAggregateOutputType | null
    _avg: ImportJobAvgAggregateOutputType | null
    _sum: ImportJobSumAggregateOutputType | null
    _min: ImportJobMinAggregateOutputType | null
    _max: ImportJobMaxAggregateOutputType | null
  }

  export type ImportJobAvgAggregateOutputType = {
    attempts: number | null
  }

  export type ImportJobSumAggregateOutputType = {
    attempts: number | null
  }

  export type ImportJobMinAggregateOutputType = {
    id: string | null
    entityType: string | null
    filePath: string | null
    status: string | null
    attempts: number | null
    error: string | null
    createdAt: Date | null
    startedAt: Date | null
    completedAt: Date | null
  }

  export type ImportJobMaxAggregateOutputType = {
    id: string | null
    entityType: string | null
    filePath: string | null
    status: string | null
    attempts: number | null
    error: string | null
    createdAt: Date | null
    startedAt: Date | null
    completedAt: Date | null
  }

  export type ImportJobCountAggregateOutputType = {
    id: number
    entityType: number
    filePath: number
    status: number
    attempts: number
    error: number
    createdAt: number
    startedAt: number
    completedAt: number
    _all: number
  }


  export type ImportJobAvgAggregateInputType = {
    attempts?: true
  }

  export type ImportJobSumAggregateInputType = {
    attempts?: true
  }

  export type ImportJobMinAggregateInputType = {
    id?: true
    entityType?: true
    filePath?: true
    status?: true
    attempts?: true
    error?: true
    createdAt?: true
    startedAt?: true
    completedAt?: true
  }

  export type ImportJobMaxAggregateInputType = {
    id?: true
    entityType?: true
    filePath?: true
    status?: true
    attempts?: true
    error?: true
    createdAt?: true
    startedAt?: true
    completedAt?: true
  }

  export type ImportJobCountAggregateInputType = {
    id?: true
    entityType?: true
    filePath?: true
    status?: true
    attempts?: true
    error?: true
    createdAt?: true
    startedAt?: true
    completedAt?: true
    _all?: true
  }

  export type ImportJobAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ImportJob to aggregate.
     */
    where?: ImportJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImportJobs to fetch.
     */
    orderBy?: ImportJobOrderByWithRelationInput | ImportJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ImportJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImportJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImportJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ImportJobs
    **/
    _count?: true | ImportJobCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ImportJobAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ImportJobSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ImportJobMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ImportJobMaxAggregateInputType
  }

  export type GetImportJobAggregateType<T extends ImportJobAggregateArgs> = {
        [P in keyof T & keyof AggregateImportJob]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImportJob[P]>
      : GetScalarType<T[P], AggregateImportJob[P]>
  }




  export type ImportJobGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImportJobWhereInput
    orderBy?: ImportJobOrderByWithAggregationInput | ImportJobOrderByWithAggregationInput[]
    by: ImportJobScalarFieldEnum[] | ImportJobScalarFieldEnum
    having?: ImportJobScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ImportJobCountAggregateInputType | true
    _avg?: ImportJobAvgAggregateInputType
    _sum?: ImportJobSumAggregateInputType
    _min?: ImportJobMinAggregateInputType
    _max?: ImportJobMaxAggregateInputType
  }

  export type ImportJobGroupByOutputType = {
    id: string
    entityType: string
    filePath: string
    status: string
    attempts: number
    error: string | null
    createdAt: Date
    startedAt: Date | null
    completedAt: Date | null
    _count: ImportJobCountAggregateOutputType | null
    _avg: ImportJobAvgAggregateOutputType | null
    _sum: ImportJobSumAggregateOutputType | null
    _min: ImportJobMinAggregateOutputType | null
    _max: ImportJobMaxAggregateOutputType | null
  }

  type GetImportJobGroupByPayload<T extends ImportJobGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ImportJobGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ImportJobGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ImportJobGroupByOutputType[P]>
            : GetScalarType<T[P], ImportJobGroupByOutputType[P]>
        }
      >
    >


  export type ImportJobSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityType?: boolean
    filePath?: boolean
    status?: boolean
    attempts?: boolean
    error?: boolean
    createdAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
  }, ExtArgs["result"]["importJob"]>

  export type ImportJobSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityType?: boolean
    filePath?: boolean
    status?: boolean
    attempts?: boolean
    error?: boolean
    createdAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
  }, ExtArgs["result"]["importJob"]>

  export type ImportJobSelectScalar = {
    id?: boolean
    entityType?: boolean
    filePath?: boolean
    status?: boolean
    attempts?: boolean
    error?: boolean
    createdAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
  }


  export type $ImportJobPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ImportJob"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      entityType: string
      filePath: string
      status: string
      attempts: number
      error: string | null
      createdAt: Date
      startedAt: Date | null
      completedAt: Date | null
    }, ExtArgs["result"]["importJob"]>
    composites: {}
  }

  type ImportJobGetPayload<S extends boolean | null | undefined | ImportJobDefaultArgs> = $Result.GetResult<Prisma.$ImportJobPayload, S>

  type ImportJobCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ImportJobFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ImportJobCountAggregateInputType | true
    }

  export interface ImportJobDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ImportJob'], meta: { name: 'ImportJob' } }
    /**
     * Find zero or one ImportJob that matches the filter.
     * @param {ImportJobFindUniqueArgs} args - Arguments to find a ImportJob
     * @example
     * // Get one ImportJob
     * const importJob = await prisma.importJob.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ImportJobFindUniqueArgs>(args: SelectSubset<T, ImportJobFindUniqueArgs<ExtArgs>>): Prisma__ImportJobClient<$Result.GetResult<Prisma.$ImportJobPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ImportJob that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ImportJobFindUniqueOrThrowArgs} args - Arguments to find a ImportJob
     * @example
     * // Get one ImportJob
     * const importJob = await prisma.importJob.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ImportJobFindUniqueOrThrowArgs>(args: SelectSubset<T, ImportJobFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ImportJobClient<$Result.GetResult<Prisma.$ImportJobPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ImportJob that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportJobFindFirstArgs} args - Arguments to find a ImportJob
     * @example
     * // Get one ImportJob
     * const importJob = await prisma.importJob.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ImportJobFindFirstArgs>(args?: SelectSubset<T, ImportJobFindFirstArgs<ExtArgs>>): Prisma__ImportJobClient<$Result.GetResult<Prisma.$ImportJobPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ImportJob that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportJobFindFirstOrThrowArgs} args - Arguments to find a ImportJob
     * @example
     * // Get one ImportJob
     * const importJob = await prisma.importJob.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ImportJobFindFirstOrThrowArgs>(args?: SelectSubset<T, ImportJobFindFirstOrThrowArgs<ExtArgs>>): Prisma__ImportJobClient<$Result.GetResult<Prisma.$ImportJobPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ImportJobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportJobFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ImportJobs
     * const importJobs = await prisma.importJob.findMany()
     * 
     * // Get first 10 ImportJobs
     * const importJobs = await prisma.importJob.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const importJobWithIdOnly = await prisma.importJob.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ImportJobFindManyArgs>(args?: SelectSubset<T, ImportJobFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImportJobPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ImportJob.
     * @param {ImportJobCreateArgs} args - Arguments to create a ImportJob.
     * @example
     * // Create one ImportJob
     * const ImportJob = await prisma.importJob.create({
     *   data: {
     *     // ... data to create a ImportJob
     *   }
     * })
     * 
     */
    create<T extends ImportJobCreateArgs>(args: SelectSubset<T, ImportJobCreateArgs<ExtArgs>>): Prisma__ImportJobClient<$Result.GetResult<Prisma.$ImportJobPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ImportJobs.
     * @param {ImportJobCreateManyArgs} args - Arguments to create many ImportJobs.
     * @example
     * // Create many ImportJobs
     * const importJob = await prisma.importJob.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ImportJobCreateManyArgs>(args?: SelectSubset<T, ImportJobCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ImportJobs and returns the data saved in the database.
     * @param {ImportJobCreateManyAndReturnArgs} args - Arguments to create many ImportJobs.
     * @example
     * // Create many ImportJobs
     * const importJob = await prisma.importJob.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ImportJobs and only return the `id`
     * const importJobWithIdOnly = await prisma.importJob.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ImportJobCreateManyAndReturnArgs>(args?: SelectSubset<T, ImportJobCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImportJobPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ImportJob.
     * @param {ImportJobDeleteArgs} args - Arguments to delete one ImportJob.
     * @example
     * // Delete one ImportJob
     * const ImportJob = await prisma.importJob.delete({
     *   where: {
     *     // ... filter to delete one ImportJob
     *   }
     * })
     * 
     */
    delete<T extends ImportJobDeleteArgs>(args: SelectSubset<T, ImportJobDeleteArgs<ExtArgs>>): Prisma__ImportJobClient<$Result.GetResult<Prisma.$ImportJobPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ImportJob.
     * @param {ImportJobUpdateArgs} args - Arguments to update one ImportJob.
     * @example
     * // Update one ImportJob
     * const importJob = await prisma.importJob.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ImportJobUpdateArgs>(args: SelectSubset<T, ImportJobUpdateArgs<ExtArgs>>): Prisma__ImportJobClient<$Result.GetResult<Prisma.$ImportJobPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ImportJobs.
     * @param {ImportJobDeleteManyArgs} args - Arguments to filter ImportJobs to delete.
     * @example
     * // Delete a few ImportJobs
     * const { count } = await prisma.importJob.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ImportJobDeleteManyArgs>(args?: SelectSubset<T, ImportJobDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ImportJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportJobUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ImportJobs
     * const importJob = await prisma.importJob.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ImportJobUpdateManyArgs>(args: SelectSubset<T, ImportJobUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ImportJob.
     * @param {ImportJobUpsertArgs} args - Arguments to update or create a ImportJob.
     * @example
     * // Update or create a ImportJob
     * const importJob = await prisma.importJob.upsert({
     *   create: {
     *     // ... data to create a ImportJob
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ImportJob we want to update
     *   }
     * })
     */
    upsert<T extends ImportJobUpsertArgs>(args: SelectSubset<T, ImportJobUpsertArgs<ExtArgs>>): Prisma__ImportJobClient<$Result.GetResult<Prisma.$ImportJobPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ImportJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportJobCountArgs} args - Arguments to filter ImportJobs to count.
     * @example
     * // Count the number of ImportJobs
     * const count = await prisma.importJob.count({
     *   where: {
     *     // ... the filter for the ImportJobs we want to count
     *   }
     * })
    **/
    count<T extends ImportJobCountArgs>(
      args?: Subset<T, ImportJobCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ImportJobCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ImportJob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportJobAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ImportJobAggregateArgs>(args: Subset<T, ImportJobAggregateArgs>): Prisma.PrismaPromise<GetImportJobAggregateType<T>>

    /**
     * Group by ImportJob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportJobGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ImportJobGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ImportJobGroupByArgs['orderBy'] }
        : { orderBy?: ImportJobGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ImportJobGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetImportJobGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ImportJob model
   */
  readonly fields: ImportJobFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ImportJob.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ImportJobClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ImportJob model
   */ 
  interface ImportJobFieldRefs {
    readonly id: FieldRef<"ImportJob", 'String'>
    readonly entityType: FieldRef<"ImportJob", 'String'>
    readonly filePath: FieldRef<"ImportJob", 'String'>
    readonly status: FieldRef<"ImportJob", 'String'>
    readonly attempts: FieldRef<"ImportJob", 'Int'>
    readonly error: FieldRef<"ImportJob", 'String'>
    readonly createdAt: FieldRef<"ImportJob", 'DateTime'>
    readonly startedAt: FieldRef<"ImportJob", 'DateTime'>
    readonly completedAt: FieldRef<"ImportJob", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ImportJob findUnique
   */
  export type ImportJobFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportJob
     */
    select?: ImportJobSelect<ExtArgs> | null
    /**
     * Filter, which ImportJob to fetch.
     */
    where: ImportJobWhereUniqueInput
  }

  /**
   * ImportJob findUniqueOrThrow
   */
  export type ImportJobFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportJob
     */
    select?: ImportJobSelect<ExtArgs> | null
    /**
     * Filter, which ImportJob to fetch.
     */
    where: ImportJobWhereUniqueInput
  }

  /**
   * ImportJob findFirst
   */
  export type ImportJobFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportJob
     */
    select?: ImportJobSelect<ExtArgs> | null
    /**
     * Filter, which ImportJob to fetch.
     */
    where?: ImportJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImportJobs to fetch.
     */
    orderBy?: ImportJobOrderByWithRelationInput | ImportJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ImportJobs.
     */
    cursor?: ImportJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImportJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImportJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ImportJobs.
     */
    distinct?: ImportJobScalarFieldEnum | ImportJobScalarFieldEnum[]
  }

  /**
   * ImportJob findFirstOrThrow
   */
  export type ImportJobFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportJob
     */
    select?: ImportJobSelect<ExtArgs> | null
    /**
     * Filter, which ImportJob to fetch.
     */
    where?: ImportJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImportJobs to fetch.
     */
    orderBy?: ImportJobOrderByWithRelationInput | ImportJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ImportJobs.
     */
    cursor?: ImportJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImportJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImportJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ImportJobs.
     */
    distinct?: ImportJobScalarFieldEnum | ImportJobScalarFieldEnum[]
  }

  /**
   * ImportJob findMany
   */
  export type ImportJobFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportJob
     */
    select?: ImportJobSelect<ExtArgs> | null
    /**
     * Filter, which ImportJobs to fetch.
     */
    where?: ImportJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImportJobs to fetch.
     */
    orderBy?: ImportJobOrderByWithRelationInput | ImportJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ImportJobs.
     */
    cursor?: ImportJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImportJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImportJobs.
     */
    skip?: number
    distinct?: ImportJobScalarFieldEnum | ImportJobScalarFieldEnum[]
  }

  /**
   * ImportJob create
   */
  export type ImportJobCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportJob
     */
    select?: ImportJobSelect<ExtArgs> | null
    /**
     * The data needed to create a ImportJob.
     */
    data: XOR<ImportJobCreateInput, ImportJobUncheckedCreateInput>
  }

  /**
   * ImportJob createMany
   */
  export type ImportJobCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ImportJobs.
     */
    data: ImportJobCreateManyInput | ImportJobCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ImportJob createManyAndReturn
   */
  export type ImportJobCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportJob
     */
    select?: ImportJobSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ImportJobs.
     */
    data: ImportJobCreateManyInput | ImportJobCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ImportJob update
   */
  export type ImportJobUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportJob
     */
    select?: ImportJobSelect<ExtArgs> | null
    /**
     * The data needed to update a ImportJob.
     */
    data: XOR<ImportJobUpdateInput, ImportJobUncheckedUpdateInput>
    /**
     * Choose, which ImportJob to update.
     */
    where: ImportJobWhereUniqueInput
  }

  /**
   * ImportJob updateMany
   */
  export type ImportJobUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ImportJobs.
     */
    data: XOR<ImportJobUpdateManyMutationInput, ImportJobUncheckedUpdateManyInput>
    /**
     * Filter which ImportJobs to update
     */
    where?: ImportJobWhereInput
  }

  /**
   * ImportJob upsert
   */
  export type ImportJobUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportJob
     */
    select?: ImportJobSelect<ExtArgs> | null
    /**
     * The filter to search for the ImportJob to update in case it exists.
     */
    where: ImportJobWhereUniqueInput
    /**
     * In case the ImportJob found by the `where` argument doesn't exist, create a new ImportJob with this data.
     */
    create: XOR<ImportJobCreateInput, ImportJobUncheckedCreateInput>
    /**
     * In case the ImportJob was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ImportJobUpdateInput, ImportJobUncheckedUpdateInput>
  }

  /**
   * ImportJob delete
   */
  export type ImportJobDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportJob
     */
    select?: ImportJobSelect<ExtArgs> | null
    /**
     * Filter which ImportJob to delete.
     */
    where: ImportJobWhereUniqueInput
  }

  /**
   * ImportJob deleteMany
   */
  export type ImportJobDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ImportJobs to delete
     */
    where?: ImportJobWhereInput
  }

  /**
   * ImportJob without action
   */
  export type ImportJobDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportJob
     */
    select?: ImportJobSelect<ExtArgs> | null
  }


  /**
   * Model NummeraanduidingStaging
   */

  export type AggregateNummeraanduidingStaging = {
    _count: NummeraanduidingStagingCountAggregateOutputType | null
    _avg: NummeraanduidingStagingAvgAggregateOutputType | null
    _sum: NummeraanduidingStagingSumAggregateOutputType | null
    _min: NummeraanduidingStagingMinAggregateOutputType | null
    _max: NummeraanduidingStagingMaxAggregateOutputType | null
  }

  export type NummeraanduidingStagingAvgAggregateOutputType = {
    id: number | null
    huisnummer: number | null
  }

  export type NummeraanduidingStagingSumAggregateOutputType = {
    id: number | null
    huisnummer: number | null
  }

  export type NummeraanduidingStagingMinAggregateOutputType = {
    id: number | null
    identificatie: string | null
    huisnummer: number | null
    huisletter: string | null
    huisnummertoevoeging: string | null
    postcode: string | null
    typeObject: string | null
    status: string | null
    geconstateerd: boolean | null
    documentDatum: Date | null
    documentNummer: string | null
    beginGeldigheid: Date | null
    tijdstipRegistratie: Date | null
    openbareRuimteId: string | null
    processingBatch: string | null
    processed: boolean | null
    error: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NummeraanduidingStagingMaxAggregateOutputType = {
    id: number | null
    identificatie: string | null
    huisnummer: number | null
    huisletter: string | null
    huisnummertoevoeging: string | null
    postcode: string | null
    typeObject: string | null
    status: string | null
    geconstateerd: boolean | null
    documentDatum: Date | null
    documentNummer: string | null
    beginGeldigheid: Date | null
    tijdstipRegistratie: Date | null
    openbareRuimteId: string | null
    processingBatch: string | null
    processed: boolean | null
    error: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NummeraanduidingStagingCountAggregateOutputType = {
    id: number
    identificatie: number
    huisnummer: number
    huisletter: number
    huisnummertoevoeging: number
    postcode: number
    typeObject: number
    status: number
    geconstateerd: number
    documentDatum: number
    documentNummer: number
    beginGeldigheid: number
    tijdstipRegistratie: number
    openbareRuimteId: number
    processingBatch: number
    processed: number
    error: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NummeraanduidingStagingAvgAggregateInputType = {
    id?: true
    huisnummer?: true
  }

  export type NummeraanduidingStagingSumAggregateInputType = {
    id?: true
    huisnummer?: true
  }

  export type NummeraanduidingStagingMinAggregateInputType = {
    id?: true
    identificatie?: true
    huisnummer?: true
    huisletter?: true
    huisnummertoevoeging?: true
    postcode?: true
    typeObject?: true
    status?: true
    geconstateerd?: true
    documentDatum?: true
    documentNummer?: true
    beginGeldigheid?: true
    tijdstipRegistratie?: true
    openbareRuimteId?: true
    processingBatch?: true
    processed?: true
    error?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NummeraanduidingStagingMaxAggregateInputType = {
    id?: true
    identificatie?: true
    huisnummer?: true
    huisletter?: true
    huisnummertoevoeging?: true
    postcode?: true
    typeObject?: true
    status?: true
    geconstateerd?: true
    documentDatum?: true
    documentNummer?: true
    beginGeldigheid?: true
    tijdstipRegistratie?: true
    openbareRuimteId?: true
    processingBatch?: true
    processed?: true
    error?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NummeraanduidingStagingCountAggregateInputType = {
    id?: true
    identificatie?: true
    huisnummer?: true
    huisletter?: true
    huisnummertoevoeging?: true
    postcode?: true
    typeObject?: true
    status?: true
    geconstateerd?: true
    documentDatum?: true
    documentNummer?: true
    beginGeldigheid?: true
    tijdstipRegistratie?: true
    openbareRuimteId?: true
    processingBatch?: true
    processed?: true
    error?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NummeraanduidingStagingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NummeraanduidingStaging to aggregate.
     */
    where?: NummeraanduidingStagingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NummeraanduidingStagings to fetch.
     */
    orderBy?: NummeraanduidingStagingOrderByWithRelationInput | NummeraanduidingStagingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NummeraanduidingStagingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NummeraanduidingStagings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NummeraanduidingStagings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NummeraanduidingStagings
    **/
    _count?: true | NummeraanduidingStagingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NummeraanduidingStagingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NummeraanduidingStagingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NummeraanduidingStagingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NummeraanduidingStagingMaxAggregateInputType
  }

  export type GetNummeraanduidingStagingAggregateType<T extends NummeraanduidingStagingAggregateArgs> = {
        [P in keyof T & keyof AggregateNummeraanduidingStaging]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNummeraanduidingStaging[P]>
      : GetScalarType<T[P], AggregateNummeraanduidingStaging[P]>
  }




  export type NummeraanduidingStagingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NummeraanduidingStagingWhereInput
    orderBy?: NummeraanduidingStagingOrderByWithAggregationInput | NummeraanduidingStagingOrderByWithAggregationInput[]
    by: NummeraanduidingStagingScalarFieldEnum[] | NummeraanduidingStagingScalarFieldEnum
    having?: NummeraanduidingStagingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NummeraanduidingStagingCountAggregateInputType | true
    _avg?: NummeraanduidingStagingAvgAggregateInputType
    _sum?: NummeraanduidingStagingSumAggregateInputType
    _min?: NummeraanduidingStagingMinAggregateInputType
    _max?: NummeraanduidingStagingMaxAggregateInputType
  }

  export type NummeraanduidingStagingGroupByOutputType = {
    id: number
    identificatie: string
    huisnummer: number
    huisletter: string | null
    huisnummertoevoeging: string | null
    postcode: string | null
    typeObject: string
    status: string
    geconstateerd: boolean
    documentDatum: Date
    documentNummer: string
    beginGeldigheid: Date
    tijdstipRegistratie: Date
    openbareRuimteId: string
    processingBatch: string | null
    processed: boolean
    error: string | null
    createdAt: Date
    updatedAt: Date
    _count: NummeraanduidingStagingCountAggregateOutputType | null
    _avg: NummeraanduidingStagingAvgAggregateOutputType | null
    _sum: NummeraanduidingStagingSumAggregateOutputType | null
    _min: NummeraanduidingStagingMinAggregateOutputType | null
    _max: NummeraanduidingStagingMaxAggregateOutputType | null
  }

  type GetNummeraanduidingStagingGroupByPayload<T extends NummeraanduidingStagingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NummeraanduidingStagingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NummeraanduidingStagingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NummeraanduidingStagingGroupByOutputType[P]>
            : GetScalarType<T[P], NummeraanduidingStagingGroupByOutputType[P]>
        }
      >
    >


  export type NummeraanduidingStagingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identificatie?: boolean
    huisnummer?: boolean
    huisletter?: boolean
    huisnummertoevoeging?: boolean
    postcode?: boolean
    typeObject?: boolean
    status?: boolean
    geconstateerd?: boolean
    documentDatum?: boolean
    documentNummer?: boolean
    beginGeldigheid?: boolean
    tijdstipRegistratie?: boolean
    openbareRuimteId?: boolean
    processingBatch?: boolean
    processed?: boolean
    error?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["nummeraanduidingStaging"]>

  export type NummeraanduidingStagingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identificatie?: boolean
    huisnummer?: boolean
    huisletter?: boolean
    huisnummertoevoeging?: boolean
    postcode?: boolean
    typeObject?: boolean
    status?: boolean
    geconstateerd?: boolean
    documentDatum?: boolean
    documentNummer?: boolean
    beginGeldigheid?: boolean
    tijdstipRegistratie?: boolean
    openbareRuimteId?: boolean
    processingBatch?: boolean
    processed?: boolean
    error?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["nummeraanduidingStaging"]>

  export type NummeraanduidingStagingSelectScalar = {
    id?: boolean
    identificatie?: boolean
    huisnummer?: boolean
    huisletter?: boolean
    huisnummertoevoeging?: boolean
    postcode?: boolean
    typeObject?: boolean
    status?: boolean
    geconstateerd?: boolean
    documentDatum?: boolean
    documentNummer?: boolean
    beginGeldigheid?: boolean
    tijdstipRegistratie?: boolean
    openbareRuimteId?: boolean
    processingBatch?: boolean
    processed?: boolean
    error?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $NummeraanduidingStagingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NummeraanduidingStaging"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      identificatie: string
      huisnummer: number
      huisletter: string | null
      huisnummertoevoeging: string | null
      postcode: string | null
      typeObject: string
      status: string
      geconstateerd: boolean
      documentDatum: Date
      documentNummer: string
      beginGeldigheid: Date
      tijdstipRegistratie: Date
      openbareRuimteId: string
      processingBatch: string | null
      processed: boolean
      error: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["nummeraanduidingStaging"]>
    composites: {}
  }

  type NummeraanduidingStagingGetPayload<S extends boolean | null | undefined | NummeraanduidingStagingDefaultArgs> = $Result.GetResult<Prisma.$NummeraanduidingStagingPayload, S>

  type NummeraanduidingStagingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NummeraanduidingStagingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NummeraanduidingStagingCountAggregateInputType | true
    }

  export interface NummeraanduidingStagingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NummeraanduidingStaging'], meta: { name: 'NummeraanduidingStaging' } }
    /**
     * Find zero or one NummeraanduidingStaging that matches the filter.
     * @param {NummeraanduidingStagingFindUniqueArgs} args - Arguments to find a NummeraanduidingStaging
     * @example
     * // Get one NummeraanduidingStaging
     * const nummeraanduidingStaging = await prisma.nummeraanduidingStaging.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NummeraanduidingStagingFindUniqueArgs>(args: SelectSubset<T, NummeraanduidingStagingFindUniqueArgs<ExtArgs>>): Prisma__NummeraanduidingStagingClient<$Result.GetResult<Prisma.$NummeraanduidingStagingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NummeraanduidingStaging that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NummeraanduidingStagingFindUniqueOrThrowArgs} args - Arguments to find a NummeraanduidingStaging
     * @example
     * // Get one NummeraanduidingStaging
     * const nummeraanduidingStaging = await prisma.nummeraanduidingStaging.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NummeraanduidingStagingFindUniqueOrThrowArgs>(args: SelectSubset<T, NummeraanduidingStagingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NummeraanduidingStagingClient<$Result.GetResult<Prisma.$NummeraanduidingStagingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NummeraanduidingStaging that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NummeraanduidingStagingFindFirstArgs} args - Arguments to find a NummeraanduidingStaging
     * @example
     * // Get one NummeraanduidingStaging
     * const nummeraanduidingStaging = await prisma.nummeraanduidingStaging.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NummeraanduidingStagingFindFirstArgs>(args?: SelectSubset<T, NummeraanduidingStagingFindFirstArgs<ExtArgs>>): Prisma__NummeraanduidingStagingClient<$Result.GetResult<Prisma.$NummeraanduidingStagingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NummeraanduidingStaging that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NummeraanduidingStagingFindFirstOrThrowArgs} args - Arguments to find a NummeraanduidingStaging
     * @example
     * // Get one NummeraanduidingStaging
     * const nummeraanduidingStaging = await prisma.nummeraanduidingStaging.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NummeraanduidingStagingFindFirstOrThrowArgs>(args?: SelectSubset<T, NummeraanduidingStagingFindFirstOrThrowArgs<ExtArgs>>): Prisma__NummeraanduidingStagingClient<$Result.GetResult<Prisma.$NummeraanduidingStagingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NummeraanduidingStagings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NummeraanduidingStagingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NummeraanduidingStagings
     * const nummeraanduidingStagings = await prisma.nummeraanduidingStaging.findMany()
     * 
     * // Get first 10 NummeraanduidingStagings
     * const nummeraanduidingStagings = await prisma.nummeraanduidingStaging.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const nummeraanduidingStagingWithIdOnly = await prisma.nummeraanduidingStaging.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NummeraanduidingStagingFindManyArgs>(args?: SelectSubset<T, NummeraanduidingStagingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NummeraanduidingStagingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NummeraanduidingStaging.
     * @param {NummeraanduidingStagingCreateArgs} args - Arguments to create a NummeraanduidingStaging.
     * @example
     * // Create one NummeraanduidingStaging
     * const NummeraanduidingStaging = await prisma.nummeraanduidingStaging.create({
     *   data: {
     *     // ... data to create a NummeraanduidingStaging
     *   }
     * })
     * 
     */
    create<T extends NummeraanduidingStagingCreateArgs>(args: SelectSubset<T, NummeraanduidingStagingCreateArgs<ExtArgs>>): Prisma__NummeraanduidingStagingClient<$Result.GetResult<Prisma.$NummeraanduidingStagingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NummeraanduidingStagings.
     * @param {NummeraanduidingStagingCreateManyArgs} args - Arguments to create many NummeraanduidingStagings.
     * @example
     * // Create many NummeraanduidingStagings
     * const nummeraanduidingStaging = await prisma.nummeraanduidingStaging.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NummeraanduidingStagingCreateManyArgs>(args?: SelectSubset<T, NummeraanduidingStagingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NummeraanduidingStagings and returns the data saved in the database.
     * @param {NummeraanduidingStagingCreateManyAndReturnArgs} args - Arguments to create many NummeraanduidingStagings.
     * @example
     * // Create many NummeraanduidingStagings
     * const nummeraanduidingStaging = await prisma.nummeraanduidingStaging.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NummeraanduidingStagings and only return the `id`
     * const nummeraanduidingStagingWithIdOnly = await prisma.nummeraanduidingStaging.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NummeraanduidingStagingCreateManyAndReturnArgs>(args?: SelectSubset<T, NummeraanduidingStagingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NummeraanduidingStagingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a NummeraanduidingStaging.
     * @param {NummeraanduidingStagingDeleteArgs} args - Arguments to delete one NummeraanduidingStaging.
     * @example
     * // Delete one NummeraanduidingStaging
     * const NummeraanduidingStaging = await prisma.nummeraanduidingStaging.delete({
     *   where: {
     *     // ... filter to delete one NummeraanduidingStaging
     *   }
     * })
     * 
     */
    delete<T extends NummeraanduidingStagingDeleteArgs>(args: SelectSubset<T, NummeraanduidingStagingDeleteArgs<ExtArgs>>): Prisma__NummeraanduidingStagingClient<$Result.GetResult<Prisma.$NummeraanduidingStagingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NummeraanduidingStaging.
     * @param {NummeraanduidingStagingUpdateArgs} args - Arguments to update one NummeraanduidingStaging.
     * @example
     * // Update one NummeraanduidingStaging
     * const nummeraanduidingStaging = await prisma.nummeraanduidingStaging.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NummeraanduidingStagingUpdateArgs>(args: SelectSubset<T, NummeraanduidingStagingUpdateArgs<ExtArgs>>): Prisma__NummeraanduidingStagingClient<$Result.GetResult<Prisma.$NummeraanduidingStagingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NummeraanduidingStagings.
     * @param {NummeraanduidingStagingDeleteManyArgs} args - Arguments to filter NummeraanduidingStagings to delete.
     * @example
     * // Delete a few NummeraanduidingStagings
     * const { count } = await prisma.nummeraanduidingStaging.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NummeraanduidingStagingDeleteManyArgs>(args?: SelectSubset<T, NummeraanduidingStagingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NummeraanduidingStagings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NummeraanduidingStagingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NummeraanduidingStagings
     * const nummeraanduidingStaging = await prisma.nummeraanduidingStaging.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NummeraanduidingStagingUpdateManyArgs>(args: SelectSubset<T, NummeraanduidingStagingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NummeraanduidingStaging.
     * @param {NummeraanduidingStagingUpsertArgs} args - Arguments to update or create a NummeraanduidingStaging.
     * @example
     * // Update or create a NummeraanduidingStaging
     * const nummeraanduidingStaging = await prisma.nummeraanduidingStaging.upsert({
     *   create: {
     *     // ... data to create a NummeraanduidingStaging
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NummeraanduidingStaging we want to update
     *   }
     * })
     */
    upsert<T extends NummeraanduidingStagingUpsertArgs>(args: SelectSubset<T, NummeraanduidingStagingUpsertArgs<ExtArgs>>): Prisma__NummeraanduidingStagingClient<$Result.GetResult<Prisma.$NummeraanduidingStagingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NummeraanduidingStagings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NummeraanduidingStagingCountArgs} args - Arguments to filter NummeraanduidingStagings to count.
     * @example
     * // Count the number of NummeraanduidingStagings
     * const count = await prisma.nummeraanduidingStaging.count({
     *   where: {
     *     // ... the filter for the NummeraanduidingStagings we want to count
     *   }
     * })
    **/
    count<T extends NummeraanduidingStagingCountArgs>(
      args?: Subset<T, NummeraanduidingStagingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NummeraanduidingStagingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NummeraanduidingStaging.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NummeraanduidingStagingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NummeraanduidingStagingAggregateArgs>(args: Subset<T, NummeraanduidingStagingAggregateArgs>): Prisma.PrismaPromise<GetNummeraanduidingStagingAggregateType<T>>

    /**
     * Group by NummeraanduidingStaging.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NummeraanduidingStagingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NummeraanduidingStagingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NummeraanduidingStagingGroupByArgs['orderBy'] }
        : { orderBy?: NummeraanduidingStagingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NummeraanduidingStagingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNummeraanduidingStagingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NummeraanduidingStaging model
   */
  readonly fields: NummeraanduidingStagingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NummeraanduidingStaging.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NummeraanduidingStagingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NummeraanduidingStaging model
   */ 
  interface NummeraanduidingStagingFieldRefs {
    readonly id: FieldRef<"NummeraanduidingStaging", 'Int'>
    readonly identificatie: FieldRef<"NummeraanduidingStaging", 'String'>
    readonly huisnummer: FieldRef<"NummeraanduidingStaging", 'Int'>
    readonly huisletter: FieldRef<"NummeraanduidingStaging", 'String'>
    readonly huisnummertoevoeging: FieldRef<"NummeraanduidingStaging", 'String'>
    readonly postcode: FieldRef<"NummeraanduidingStaging", 'String'>
    readonly typeObject: FieldRef<"NummeraanduidingStaging", 'String'>
    readonly status: FieldRef<"NummeraanduidingStaging", 'String'>
    readonly geconstateerd: FieldRef<"NummeraanduidingStaging", 'Boolean'>
    readonly documentDatum: FieldRef<"NummeraanduidingStaging", 'DateTime'>
    readonly documentNummer: FieldRef<"NummeraanduidingStaging", 'String'>
    readonly beginGeldigheid: FieldRef<"NummeraanduidingStaging", 'DateTime'>
    readonly tijdstipRegistratie: FieldRef<"NummeraanduidingStaging", 'DateTime'>
    readonly openbareRuimteId: FieldRef<"NummeraanduidingStaging", 'String'>
    readonly processingBatch: FieldRef<"NummeraanduidingStaging", 'String'>
    readonly processed: FieldRef<"NummeraanduidingStaging", 'Boolean'>
    readonly error: FieldRef<"NummeraanduidingStaging", 'String'>
    readonly createdAt: FieldRef<"NummeraanduidingStaging", 'DateTime'>
    readonly updatedAt: FieldRef<"NummeraanduidingStaging", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NummeraanduidingStaging findUnique
   */
  export type NummeraanduidingStagingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NummeraanduidingStaging
     */
    select?: NummeraanduidingStagingSelect<ExtArgs> | null
    /**
     * Filter, which NummeraanduidingStaging to fetch.
     */
    where: NummeraanduidingStagingWhereUniqueInput
  }

  /**
   * NummeraanduidingStaging findUniqueOrThrow
   */
  export type NummeraanduidingStagingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NummeraanduidingStaging
     */
    select?: NummeraanduidingStagingSelect<ExtArgs> | null
    /**
     * Filter, which NummeraanduidingStaging to fetch.
     */
    where: NummeraanduidingStagingWhereUniqueInput
  }

  /**
   * NummeraanduidingStaging findFirst
   */
  export type NummeraanduidingStagingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NummeraanduidingStaging
     */
    select?: NummeraanduidingStagingSelect<ExtArgs> | null
    /**
     * Filter, which NummeraanduidingStaging to fetch.
     */
    where?: NummeraanduidingStagingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NummeraanduidingStagings to fetch.
     */
    orderBy?: NummeraanduidingStagingOrderByWithRelationInput | NummeraanduidingStagingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NummeraanduidingStagings.
     */
    cursor?: NummeraanduidingStagingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NummeraanduidingStagings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NummeraanduidingStagings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NummeraanduidingStagings.
     */
    distinct?: NummeraanduidingStagingScalarFieldEnum | NummeraanduidingStagingScalarFieldEnum[]
  }

  /**
   * NummeraanduidingStaging findFirstOrThrow
   */
  export type NummeraanduidingStagingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NummeraanduidingStaging
     */
    select?: NummeraanduidingStagingSelect<ExtArgs> | null
    /**
     * Filter, which NummeraanduidingStaging to fetch.
     */
    where?: NummeraanduidingStagingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NummeraanduidingStagings to fetch.
     */
    orderBy?: NummeraanduidingStagingOrderByWithRelationInput | NummeraanduidingStagingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NummeraanduidingStagings.
     */
    cursor?: NummeraanduidingStagingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NummeraanduidingStagings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NummeraanduidingStagings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NummeraanduidingStagings.
     */
    distinct?: NummeraanduidingStagingScalarFieldEnum | NummeraanduidingStagingScalarFieldEnum[]
  }

  /**
   * NummeraanduidingStaging findMany
   */
  export type NummeraanduidingStagingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NummeraanduidingStaging
     */
    select?: NummeraanduidingStagingSelect<ExtArgs> | null
    /**
     * Filter, which NummeraanduidingStagings to fetch.
     */
    where?: NummeraanduidingStagingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NummeraanduidingStagings to fetch.
     */
    orderBy?: NummeraanduidingStagingOrderByWithRelationInput | NummeraanduidingStagingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NummeraanduidingStagings.
     */
    cursor?: NummeraanduidingStagingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NummeraanduidingStagings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NummeraanduidingStagings.
     */
    skip?: number
    distinct?: NummeraanduidingStagingScalarFieldEnum | NummeraanduidingStagingScalarFieldEnum[]
  }

  /**
   * NummeraanduidingStaging create
   */
  export type NummeraanduidingStagingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NummeraanduidingStaging
     */
    select?: NummeraanduidingStagingSelect<ExtArgs> | null
    /**
     * The data needed to create a NummeraanduidingStaging.
     */
    data: XOR<NummeraanduidingStagingCreateInput, NummeraanduidingStagingUncheckedCreateInput>
  }

  /**
   * NummeraanduidingStaging createMany
   */
  export type NummeraanduidingStagingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NummeraanduidingStagings.
     */
    data: NummeraanduidingStagingCreateManyInput | NummeraanduidingStagingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NummeraanduidingStaging createManyAndReturn
   */
  export type NummeraanduidingStagingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NummeraanduidingStaging
     */
    select?: NummeraanduidingStagingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many NummeraanduidingStagings.
     */
    data: NummeraanduidingStagingCreateManyInput | NummeraanduidingStagingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NummeraanduidingStaging update
   */
  export type NummeraanduidingStagingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NummeraanduidingStaging
     */
    select?: NummeraanduidingStagingSelect<ExtArgs> | null
    /**
     * The data needed to update a NummeraanduidingStaging.
     */
    data: XOR<NummeraanduidingStagingUpdateInput, NummeraanduidingStagingUncheckedUpdateInput>
    /**
     * Choose, which NummeraanduidingStaging to update.
     */
    where: NummeraanduidingStagingWhereUniqueInput
  }

  /**
   * NummeraanduidingStaging updateMany
   */
  export type NummeraanduidingStagingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NummeraanduidingStagings.
     */
    data: XOR<NummeraanduidingStagingUpdateManyMutationInput, NummeraanduidingStagingUncheckedUpdateManyInput>
    /**
     * Filter which NummeraanduidingStagings to update
     */
    where?: NummeraanduidingStagingWhereInput
  }

  /**
   * NummeraanduidingStaging upsert
   */
  export type NummeraanduidingStagingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NummeraanduidingStaging
     */
    select?: NummeraanduidingStagingSelect<ExtArgs> | null
    /**
     * The filter to search for the NummeraanduidingStaging to update in case it exists.
     */
    where: NummeraanduidingStagingWhereUniqueInput
    /**
     * In case the NummeraanduidingStaging found by the `where` argument doesn't exist, create a new NummeraanduidingStaging with this data.
     */
    create: XOR<NummeraanduidingStagingCreateInput, NummeraanduidingStagingUncheckedCreateInput>
    /**
     * In case the NummeraanduidingStaging was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NummeraanduidingStagingUpdateInput, NummeraanduidingStagingUncheckedUpdateInput>
  }

  /**
   * NummeraanduidingStaging delete
   */
  export type NummeraanduidingStagingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NummeraanduidingStaging
     */
    select?: NummeraanduidingStagingSelect<ExtArgs> | null
    /**
     * Filter which NummeraanduidingStaging to delete.
     */
    where: NummeraanduidingStagingWhereUniqueInput
  }

  /**
   * NummeraanduidingStaging deleteMany
   */
  export type NummeraanduidingStagingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NummeraanduidingStagings to delete
     */
    where?: NummeraanduidingStagingWhereInput
  }

  /**
   * NummeraanduidingStaging without action
   */
  export type NummeraanduidingStagingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NummeraanduidingStaging
     */
    select?: NummeraanduidingStagingSelect<ExtArgs> | null
  }


  /**
   * Model Ligplaats
   */

  export type AggregateLigplaats = {
    _count: LigplaatsCountAggregateOutputType | null
    _min: LigplaatsMinAggregateOutputType | null
    _max: LigplaatsMaxAggregateOutputType | null
  }

  export type LigplaatsMinAggregateOutputType = {
    identificatie: string | null
    beginGeldigheid: Date | null
    eindGeldigheid: Date | null
    geconstateerd: boolean | null
    documentDatum: Date | null
    documentNummer: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    nummeraanduidingId: string | null
  }

  export type LigplaatsMaxAggregateOutputType = {
    identificatie: string | null
    beginGeldigheid: Date | null
    eindGeldigheid: Date | null
    geconstateerd: boolean | null
    documentDatum: Date | null
    documentNummer: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    nummeraanduidingId: string | null
  }

  export type LigplaatsCountAggregateOutputType = {
    identificatie: number
    beginGeldigheid: number
    eindGeldigheid: number
    geconstateerd: number
    documentDatum: number
    documentNummer: number
    geometry: number
    status: number
    createdAt: number
    updatedAt: number
    nummeraanduidingId: number
    _all: number
  }


  export type LigplaatsMinAggregateInputType = {
    identificatie?: true
    beginGeldigheid?: true
    eindGeldigheid?: true
    geconstateerd?: true
    documentDatum?: true
    documentNummer?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    nummeraanduidingId?: true
  }

  export type LigplaatsMaxAggregateInputType = {
    identificatie?: true
    beginGeldigheid?: true
    eindGeldigheid?: true
    geconstateerd?: true
    documentDatum?: true
    documentNummer?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    nummeraanduidingId?: true
  }

  export type LigplaatsCountAggregateInputType = {
    identificatie?: true
    beginGeldigheid?: true
    eindGeldigheid?: true
    geconstateerd?: true
    documentDatum?: true
    documentNummer?: true
    geometry?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    nummeraanduidingId?: true
    _all?: true
  }

  export type LigplaatsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ligplaats to aggregate.
     */
    where?: LigplaatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ligplaats to fetch.
     */
    orderBy?: LigplaatsOrderByWithRelationInput | LigplaatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LigplaatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ligplaats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ligplaats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Ligplaats
    **/
    _count?: true | LigplaatsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LigplaatsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LigplaatsMaxAggregateInputType
  }

  export type GetLigplaatsAggregateType<T extends LigplaatsAggregateArgs> = {
        [P in keyof T & keyof AggregateLigplaats]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLigplaats[P]>
      : GetScalarType<T[P], AggregateLigplaats[P]>
  }




  export type LigplaatsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LigplaatsWhereInput
    orderBy?: LigplaatsOrderByWithAggregationInput | LigplaatsOrderByWithAggregationInput[]
    by: LigplaatsScalarFieldEnum[] | LigplaatsScalarFieldEnum
    having?: LigplaatsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LigplaatsCountAggregateInputType | true
    _min?: LigplaatsMinAggregateInputType
    _max?: LigplaatsMaxAggregateInputType
  }

  export type LigplaatsGroupByOutputType = {
    identificatie: string
    beginGeldigheid: Date
    eindGeldigheid: Date | null
    geconstateerd: boolean
    documentDatum: Date
    documentNummer: string
    geometry: JsonValue | null
    status: string
    createdAt: Date
    updatedAt: Date
    nummeraanduidingId: string
    _count: LigplaatsCountAggregateOutputType | null
    _min: LigplaatsMinAggregateOutputType | null
    _max: LigplaatsMaxAggregateOutputType | null
  }

  type GetLigplaatsGroupByPayload<T extends LigplaatsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LigplaatsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LigplaatsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LigplaatsGroupByOutputType[P]>
            : GetScalarType<T[P], LigplaatsGroupByOutputType[P]>
        }
      >
    >


  export type LigplaatsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identificatie?: boolean
    beginGeldigheid?: boolean
    eindGeldigheid?: boolean
    geconstateerd?: boolean
    documentDatum?: boolean
    documentNummer?: boolean
    geometry?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    nummeraanduidingId?: boolean
    nummeraanduiding?: boolean | NummeraanduidingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ligplaats"]>

  export type LigplaatsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identificatie?: boolean
    beginGeldigheid?: boolean
    eindGeldigheid?: boolean
    geconstateerd?: boolean
    documentDatum?: boolean
    documentNummer?: boolean
    geometry?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    nummeraanduidingId?: boolean
    nummeraanduiding?: boolean | NummeraanduidingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ligplaats"]>

  export type LigplaatsSelectScalar = {
    identificatie?: boolean
    beginGeldigheid?: boolean
    eindGeldigheid?: boolean
    geconstateerd?: boolean
    documentDatum?: boolean
    documentNummer?: boolean
    geometry?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    nummeraanduidingId?: boolean
  }

  export type LigplaatsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nummeraanduiding?: boolean | NummeraanduidingDefaultArgs<ExtArgs>
  }
  export type LigplaatsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nummeraanduiding?: boolean | NummeraanduidingDefaultArgs<ExtArgs>
  }

  export type $LigplaatsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Ligplaats"
    objects: {
      nummeraanduiding: Prisma.$NummeraanduidingPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      identificatie: string
      beginGeldigheid: Date
      eindGeldigheid: Date | null
      geconstateerd: boolean
      documentDatum: Date
      documentNummer: string
      geometry: Prisma.JsonValue | null
      status: string
      createdAt: Date
      updatedAt: Date
      nummeraanduidingId: string
    }, ExtArgs["result"]["ligplaats"]>
    composites: {}
  }

  type LigplaatsGetPayload<S extends boolean | null | undefined | LigplaatsDefaultArgs> = $Result.GetResult<Prisma.$LigplaatsPayload, S>

  type LigplaatsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LigplaatsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LigplaatsCountAggregateInputType | true
    }

  export interface LigplaatsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Ligplaats'], meta: { name: 'Ligplaats' } }
    /**
     * Find zero or one Ligplaats that matches the filter.
     * @param {LigplaatsFindUniqueArgs} args - Arguments to find a Ligplaats
     * @example
     * // Get one Ligplaats
     * const ligplaats = await prisma.ligplaats.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LigplaatsFindUniqueArgs>(args: SelectSubset<T, LigplaatsFindUniqueArgs<ExtArgs>>): Prisma__LigplaatsClient<$Result.GetResult<Prisma.$LigplaatsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Ligplaats that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LigplaatsFindUniqueOrThrowArgs} args - Arguments to find a Ligplaats
     * @example
     * // Get one Ligplaats
     * const ligplaats = await prisma.ligplaats.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LigplaatsFindUniqueOrThrowArgs>(args: SelectSubset<T, LigplaatsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LigplaatsClient<$Result.GetResult<Prisma.$LigplaatsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Ligplaats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigplaatsFindFirstArgs} args - Arguments to find a Ligplaats
     * @example
     * // Get one Ligplaats
     * const ligplaats = await prisma.ligplaats.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LigplaatsFindFirstArgs>(args?: SelectSubset<T, LigplaatsFindFirstArgs<ExtArgs>>): Prisma__LigplaatsClient<$Result.GetResult<Prisma.$LigplaatsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Ligplaats that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigplaatsFindFirstOrThrowArgs} args - Arguments to find a Ligplaats
     * @example
     * // Get one Ligplaats
     * const ligplaats = await prisma.ligplaats.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LigplaatsFindFirstOrThrowArgs>(args?: SelectSubset<T, LigplaatsFindFirstOrThrowArgs<ExtArgs>>): Prisma__LigplaatsClient<$Result.GetResult<Prisma.$LigplaatsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Ligplaats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigplaatsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ligplaats
     * const ligplaats = await prisma.ligplaats.findMany()
     * 
     * // Get first 10 Ligplaats
     * const ligplaats = await prisma.ligplaats.findMany({ take: 10 })
     * 
     * // Only select the `identificatie`
     * const ligplaatsWithIdentificatieOnly = await prisma.ligplaats.findMany({ select: { identificatie: true } })
     * 
     */
    findMany<T extends LigplaatsFindManyArgs>(args?: SelectSubset<T, LigplaatsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LigplaatsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Ligplaats.
     * @param {LigplaatsCreateArgs} args - Arguments to create a Ligplaats.
     * @example
     * // Create one Ligplaats
     * const Ligplaats = await prisma.ligplaats.create({
     *   data: {
     *     // ... data to create a Ligplaats
     *   }
     * })
     * 
     */
    create<T extends LigplaatsCreateArgs>(args: SelectSubset<T, LigplaatsCreateArgs<ExtArgs>>): Prisma__LigplaatsClient<$Result.GetResult<Prisma.$LigplaatsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Ligplaats.
     * @param {LigplaatsCreateManyArgs} args - Arguments to create many Ligplaats.
     * @example
     * // Create many Ligplaats
     * const ligplaats = await prisma.ligplaats.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LigplaatsCreateManyArgs>(args?: SelectSubset<T, LigplaatsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ligplaats and returns the data saved in the database.
     * @param {LigplaatsCreateManyAndReturnArgs} args - Arguments to create many Ligplaats.
     * @example
     * // Create many Ligplaats
     * const ligplaats = await prisma.ligplaats.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ligplaats and only return the `identificatie`
     * const ligplaatsWithIdentificatieOnly = await prisma.ligplaats.createManyAndReturn({ 
     *   select: { identificatie: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LigplaatsCreateManyAndReturnArgs>(args?: SelectSubset<T, LigplaatsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LigplaatsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Ligplaats.
     * @param {LigplaatsDeleteArgs} args - Arguments to delete one Ligplaats.
     * @example
     * // Delete one Ligplaats
     * const Ligplaats = await prisma.ligplaats.delete({
     *   where: {
     *     // ... filter to delete one Ligplaats
     *   }
     * })
     * 
     */
    delete<T extends LigplaatsDeleteArgs>(args: SelectSubset<T, LigplaatsDeleteArgs<ExtArgs>>): Prisma__LigplaatsClient<$Result.GetResult<Prisma.$LigplaatsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Ligplaats.
     * @param {LigplaatsUpdateArgs} args - Arguments to update one Ligplaats.
     * @example
     * // Update one Ligplaats
     * const ligplaats = await prisma.ligplaats.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LigplaatsUpdateArgs>(args: SelectSubset<T, LigplaatsUpdateArgs<ExtArgs>>): Prisma__LigplaatsClient<$Result.GetResult<Prisma.$LigplaatsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Ligplaats.
     * @param {LigplaatsDeleteManyArgs} args - Arguments to filter Ligplaats to delete.
     * @example
     * // Delete a few Ligplaats
     * const { count } = await prisma.ligplaats.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LigplaatsDeleteManyArgs>(args?: SelectSubset<T, LigplaatsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ligplaats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigplaatsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ligplaats
     * const ligplaats = await prisma.ligplaats.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LigplaatsUpdateManyArgs>(args: SelectSubset<T, LigplaatsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ligplaats.
     * @param {LigplaatsUpsertArgs} args - Arguments to update or create a Ligplaats.
     * @example
     * // Update or create a Ligplaats
     * const ligplaats = await prisma.ligplaats.upsert({
     *   create: {
     *     // ... data to create a Ligplaats
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ligplaats we want to update
     *   }
     * })
     */
    upsert<T extends LigplaatsUpsertArgs>(args: SelectSubset<T, LigplaatsUpsertArgs<ExtArgs>>): Prisma__LigplaatsClient<$Result.GetResult<Prisma.$LigplaatsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Ligplaats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigplaatsCountArgs} args - Arguments to filter Ligplaats to count.
     * @example
     * // Count the number of Ligplaats
     * const count = await prisma.ligplaats.count({
     *   where: {
     *     // ... the filter for the Ligplaats we want to count
     *   }
     * })
    **/
    count<T extends LigplaatsCountArgs>(
      args?: Subset<T, LigplaatsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LigplaatsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ligplaats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigplaatsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LigplaatsAggregateArgs>(args: Subset<T, LigplaatsAggregateArgs>): Prisma.PrismaPromise<GetLigplaatsAggregateType<T>>

    /**
     * Group by Ligplaats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigplaatsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LigplaatsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LigplaatsGroupByArgs['orderBy'] }
        : { orderBy?: LigplaatsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LigplaatsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLigplaatsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Ligplaats model
   */
  readonly fields: LigplaatsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Ligplaats.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LigplaatsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    nummeraanduiding<T extends NummeraanduidingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NummeraanduidingDefaultArgs<ExtArgs>>): Prisma__NummeraanduidingClient<$Result.GetResult<Prisma.$NummeraanduidingPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Ligplaats model
   */ 
  interface LigplaatsFieldRefs {
    readonly identificatie: FieldRef<"Ligplaats", 'String'>
    readonly beginGeldigheid: FieldRef<"Ligplaats", 'DateTime'>
    readonly eindGeldigheid: FieldRef<"Ligplaats", 'DateTime'>
    readonly geconstateerd: FieldRef<"Ligplaats", 'Boolean'>
    readonly documentDatum: FieldRef<"Ligplaats", 'DateTime'>
    readonly documentNummer: FieldRef<"Ligplaats", 'String'>
    readonly geometry: FieldRef<"Ligplaats", 'Json'>
    readonly status: FieldRef<"Ligplaats", 'String'>
    readonly createdAt: FieldRef<"Ligplaats", 'DateTime'>
    readonly updatedAt: FieldRef<"Ligplaats", 'DateTime'>
    readonly nummeraanduidingId: FieldRef<"Ligplaats", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Ligplaats findUnique
   */
  export type LigplaatsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ligplaats
     */
    select?: LigplaatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigplaatsInclude<ExtArgs> | null
    /**
     * Filter, which Ligplaats to fetch.
     */
    where: LigplaatsWhereUniqueInput
  }

  /**
   * Ligplaats findUniqueOrThrow
   */
  export type LigplaatsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ligplaats
     */
    select?: LigplaatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigplaatsInclude<ExtArgs> | null
    /**
     * Filter, which Ligplaats to fetch.
     */
    where: LigplaatsWhereUniqueInput
  }

  /**
   * Ligplaats findFirst
   */
  export type LigplaatsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ligplaats
     */
    select?: LigplaatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigplaatsInclude<ExtArgs> | null
    /**
     * Filter, which Ligplaats to fetch.
     */
    where?: LigplaatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ligplaats to fetch.
     */
    orderBy?: LigplaatsOrderByWithRelationInput | LigplaatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ligplaats.
     */
    cursor?: LigplaatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ligplaats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ligplaats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ligplaats.
     */
    distinct?: LigplaatsScalarFieldEnum | LigplaatsScalarFieldEnum[]
  }

  /**
   * Ligplaats findFirstOrThrow
   */
  export type LigplaatsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ligplaats
     */
    select?: LigplaatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigplaatsInclude<ExtArgs> | null
    /**
     * Filter, which Ligplaats to fetch.
     */
    where?: LigplaatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ligplaats to fetch.
     */
    orderBy?: LigplaatsOrderByWithRelationInput | LigplaatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ligplaats.
     */
    cursor?: LigplaatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ligplaats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ligplaats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ligplaats.
     */
    distinct?: LigplaatsScalarFieldEnum | LigplaatsScalarFieldEnum[]
  }

  /**
   * Ligplaats findMany
   */
  export type LigplaatsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ligplaats
     */
    select?: LigplaatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigplaatsInclude<ExtArgs> | null
    /**
     * Filter, which Ligplaats to fetch.
     */
    where?: LigplaatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ligplaats to fetch.
     */
    orderBy?: LigplaatsOrderByWithRelationInput | LigplaatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Ligplaats.
     */
    cursor?: LigplaatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ligplaats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ligplaats.
     */
    skip?: number
    distinct?: LigplaatsScalarFieldEnum | LigplaatsScalarFieldEnum[]
  }

  /**
   * Ligplaats create
   */
  export type LigplaatsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ligplaats
     */
    select?: LigplaatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigplaatsInclude<ExtArgs> | null
    /**
     * The data needed to create a Ligplaats.
     */
    data: XOR<LigplaatsCreateInput, LigplaatsUncheckedCreateInput>
  }

  /**
   * Ligplaats createMany
   */
  export type LigplaatsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Ligplaats.
     */
    data: LigplaatsCreateManyInput | LigplaatsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Ligplaats createManyAndReturn
   */
  export type LigplaatsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ligplaats
     */
    select?: LigplaatsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Ligplaats.
     */
    data: LigplaatsCreateManyInput | LigplaatsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigplaatsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Ligplaats update
   */
  export type LigplaatsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ligplaats
     */
    select?: LigplaatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigplaatsInclude<ExtArgs> | null
    /**
     * The data needed to update a Ligplaats.
     */
    data: XOR<LigplaatsUpdateInput, LigplaatsUncheckedUpdateInput>
    /**
     * Choose, which Ligplaats to update.
     */
    where: LigplaatsWhereUniqueInput
  }

  /**
   * Ligplaats updateMany
   */
  export type LigplaatsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Ligplaats.
     */
    data: XOR<LigplaatsUpdateManyMutationInput, LigplaatsUncheckedUpdateManyInput>
    /**
     * Filter which Ligplaats to update
     */
    where?: LigplaatsWhereInput
  }

  /**
   * Ligplaats upsert
   */
  export type LigplaatsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ligplaats
     */
    select?: LigplaatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigplaatsInclude<ExtArgs> | null
    /**
     * The filter to search for the Ligplaats to update in case it exists.
     */
    where: LigplaatsWhereUniqueInput
    /**
     * In case the Ligplaats found by the `where` argument doesn't exist, create a new Ligplaats with this data.
     */
    create: XOR<LigplaatsCreateInput, LigplaatsUncheckedCreateInput>
    /**
     * In case the Ligplaats was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LigplaatsUpdateInput, LigplaatsUncheckedUpdateInput>
  }

  /**
   * Ligplaats delete
   */
  export type LigplaatsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ligplaats
     */
    select?: LigplaatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigplaatsInclude<ExtArgs> | null
    /**
     * Filter which Ligplaats to delete.
     */
    where: LigplaatsWhereUniqueInput
  }

  /**
   * Ligplaats deleteMany
   */
  export type LigplaatsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ligplaats to delete
     */
    where?: LigplaatsWhereInput
  }

  /**
   * Ligplaats without action
   */
  export type LigplaatsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ligplaats
     */
    select?: LigplaatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigplaatsInclude<ExtArgs> | null
  }


  /**
   * Model Standplaats
   */

  export type AggregateStandplaats = {
    _count: StandplaatsCountAggregateOutputType | null
    _min: StandplaatsMinAggregateOutputType | null
    _max: StandplaatsMaxAggregateOutputType | null
  }

  export type StandplaatsMinAggregateOutputType = {
    identificatie: string | null
    beginGeldigheid: Date | null
    eindGeldigheid: Date | null
    geconstateerd: boolean | null
    documentDatum: Date | null
    documentNummer: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    nummeraanduidingId: string | null
  }

  export type StandplaatsMaxAggregateOutputType = {
    identificatie: string | null
    beginGeldigheid: Date | null
    eindGeldigheid: Date | null
    geconstateerd: boolean | null
    documentDatum: Date | null
    documentNummer: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    nummeraanduidingId: string | null
  }

  export type StandplaatsCountAggregateOutputType = {
    identificatie: number
    beginGeldigheid: number
    eindGeldigheid: number
    geconstateerd: number
    documentDatum: number
    documentNummer: number
    geometry: number
    status: number
    createdAt: number
    updatedAt: number
    nummeraanduidingId: number
    _all: number
  }


  export type StandplaatsMinAggregateInputType = {
    identificatie?: true
    beginGeldigheid?: true
    eindGeldigheid?: true
    geconstateerd?: true
    documentDatum?: true
    documentNummer?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    nummeraanduidingId?: true
  }

  export type StandplaatsMaxAggregateInputType = {
    identificatie?: true
    beginGeldigheid?: true
    eindGeldigheid?: true
    geconstateerd?: true
    documentDatum?: true
    documentNummer?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    nummeraanduidingId?: true
  }

  export type StandplaatsCountAggregateInputType = {
    identificatie?: true
    beginGeldigheid?: true
    eindGeldigheid?: true
    geconstateerd?: true
    documentDatum?: true
    documentNummer?: true
    geometry?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    nummeraanduidingId?: true
    _all?: true
  }

  export type StandplaatsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Standplaats to aggregate.
     */
    where?: StandplaatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Standplaats to fetch.
     */
    orderBy?: StandplaatsOrderByWithRelationInput | StandplaatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StandplaatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Standplaats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Standplaats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Standplaats
    **/
    _count?: true | StandplaatsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StandplaatsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StandplaatsMaxAggregateInputType
  }

  export type GetStandplaatsAggregateType<T extends StandplaatsAggregateArgs> = {
        [P in keyof T & keyof AggregateStandplaats]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStandplaats[P]>
      : GetScalarType<T[P], AggregateStandplaats[P]>
  }




  export type StandplaatsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StandplaatsWhereInput
    orderBy?: StandplaatsOrderByWithAggregationInput | StandplaatsOrderByWithAggregationInput[]
    by: StandplaatsScalarFieldEnum[] | StandplaatsScalarFieldEnum
    having?: StandplaatsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StandplaatsCountAggregateInputType | true
    _min?: StandplaatsMinAggregateInputType
    _max?: StandplaatsMaxAggregateInputType
  }

  export type StandplaatsGroupByOutputType = {
    identificatie: string
    beginGeldigheid: Date
    eindGeldigheid: Date | null
    geconstateerd: boolean
    documentDatum: Date
    documentNummer: string
    geometry: JsonValue | null
    status: string
    createdAt: Date
    updatedAt: Date
    nummeraanduidingId: string
    _count: StandplaatsCountAggregateOutputType | null
    _min: StandplaatsMinAggregateOutputType | null
    _max: StandplaatsMaxAggregateOutputType | null
  }

  type GetStandplaatsGroupByPayload<T extends StandplaatsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StandplaatsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StandplaatsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StandplaatsGroupByOutputType[P]>
            : GetScalarType<T[P], StandplaatsGroupByOutputType[P]>
        }
      >
    >


  export type StandplaatsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identificatie?: boolean
    beginGeldigheid?: boolean
    eindGeldigheid?: boolean
    geconstateerd?: boolean
    documentDatum?: boolean
    documentNummer?: boolean
    geometry?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    nummeraanduidingId?: boolean
    nummeraanduiding?: boolean | NummeraanduidingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["standplaats"]>

  export type StandplaatsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identificatie?: boolean
    beginGeldigheid?: boolean
    eindGeldigheid?: boolean
    geconstateerd?: boolean
    documentDatum?: boolean
    documentNummer?: boolean
    geometry?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    nummeraanduidingId?: boolean
    nummeraanduiding?: boolean | NummeraanduidingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["standplaats"]>

  export type StandplaatsSelectScalar = {
    identificatie?: boolean
    beginGeldigheid?: boolean
    eindGeldigheid?: boolean
    geconstateerd?: boolean
    documentDatum?: boolean
    documentNummer?: boolean
    geometry?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    nummeraanduidingId?: boolean
  }

  export type StandplaatsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nummeraanduiding?: boolean | NummeraanduidingDefaultArgs<ExtArgs>
  }
  export type StandplaatsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nummeraanduiding?: boolean | NummeraanduidingDefaultArgs<ExtArgs>
  }

  export type $StandplaatsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Standplaats"
    objects: {
      nummeraanduiding: Prisma.$NummeraanduidingPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      identificatie: string
      beginGeldigheid: Date
      eindGeldigheid: Date | null
      geconstateerd: boolean
      documentDatum: Date
      documentNummer: string
      geometry: Prisma.JsonValue | null
      status: string
      createdAt: Date
      updatedAt: Date
      nummeraanduidingId: string
    }, ExtArgs["result"]["standplaats"]>
    composites: {}
  }

  type StandplaatsGetPayload<S extends boolean | null | undefined | StandplaatsDefaultArgs> = $Result.GetResult<Prisma.$StandplaatsPayload, S>

  type StandplaatsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StandplaatsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StandplaatsCountAggregateInputType | true
    }

  export interface StandplaatsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Standplaats'], meta: { name: 'Standplaats' } }
    /**
     * Find zero or one Standplaats that matches the filter.
     * @param {StandplaatsFindUniqueArgs} args - Arguments to find a Standplaats
     * @example
     * // Get one Standplaats
     * const standplaats = await prisma.standplaats.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StandplaatsFindUniqueArgs>(args: SelectSubset<T, StandplaatsFindUniqueArgs<ExtArgs>>): Prisma__StandplaatsClient<$Result.GetResult<Prisma.$StandplaatsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Standplaats that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StandplaatsFindUniqueOrThrowArgs} args - Arguments to find a Standplaats
     * @example
     * // Get one Standplaats
     * const standplaats = await prisma.standplaats.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StandplaatsFindUniqueOrThrowArgs>(args: SelectSubset<T, StandplaatsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StandplaatsClient<$Result.GetResult<Prisma.$StandplaatsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Standplaats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandplaatsFindFirstArgs} args - Arguments to find a Standplaats
     * @example
     * // Get one Standplaats
     * const standplaats = await prisma.standplaats.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StandplaatsFindFirstArgs>(args?: SelectSubset<T, StandplaatsFindFirstArgs<ExtArgs>>): Prisma__StandplaatsClient<$Result.GetResult<Prisma.$StandplaatsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Standplaats that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandplaatsFindFirstOrThrowArgs} args - Arguments to find a Standplaats
     * @example
     * // Get one Standplaats
     * const standplaats = await prisma.standplaats.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StandplaatsFindFirstOrThrowArgs>(args?: SelectSubset<T, StandplaatsFindFirstOrThrowArgs<ExtArgs>>): Prisma__StandplaatsClient<$Result.GetResult<Prisma.$StandplaatsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Standplaats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandplaatsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Standplaats
     * const standplaats = await prisma.standplaats.findMany()
     * 
     * // Get first 10 Standplaats
     * const standplaats = await prisma.standplaats.findMany({ take: 10 })
     * 
     * // Only select the `identificatie`
     * const standplaatsWithIdentificatieOnly = await prisma.standplaats.findMany({ select: { identificatie: true } })
     * 
     */
    findMany<T extends StandplaatsFindManyArgs>(args?: SelectSubset<T, StandplaatsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StandplaatsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Standplaats.
     * @param {StandplaatsCreateArgs} args - Arguments to create a Standplaats.
     * @example
     * // Create one Standplaats
     * const Standplaats = await prisma.standplaats.create({
     *   data: {
     *     // ... data to create a Standplaats
     *   }
     * })
     * 
     */
    create<T extends StandplaatsCreateArgs>(args: SelectSubset<T, StandplaatsCreateArgs<ExtArgs>>): Prisma__StandplaatsClient<$Result.GetResult<Prisma.$StandplaatsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Standplaats.
     * @param {StandplaatsCreateManyArgs} args - Arguments to create many Standplaats.
     * @example
     * // Create many Standplaats
     * const standplaats = await prisma.standplaats.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StandplaatsCreateManyArgs>(args?: SelectSubset<T, StandplaatsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Standplaats and returns the data saved in the database.
     * @param {StandplaatsCreateManyAndReturnArgs} args - Arguments to create many Standplaats.
     * @example
     * // Create many Standplaats
     * const standplaats = await prisma.standplaats.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Standplaats and only return the `identificatie`
     * const standplaatsWithIdentificatieOnly = await prisma.standplaats.createManyAndReturn({ 
     *   select: { identificatie: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StandplaatsCreateManyAndReturnArgs>(args?: SelectSubset<T, StandplaatsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StandplaatsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Standplaats.
     * @param {StandplaatsDeleteArgs} args - Arguments to delete one Standplaats.
     * @example
     * // Delete one Standplaats
     * const Standplaats = await prisma.standplaats.delete({
     *   where: {
     *     // ... filter to delete one Standplaats
     *   }
     * })
     * 
     */
    delete<T extends StandplaatsDeleteArgs>(args: SelectSubset<T, StandplaatsDeleteArgs<ExtArgs>>): Prisma__StandplaatsClient<$Result.GetResult<Prisma.$StandplaatsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Standplaats.
     * @param {StandplaatsUpdateArgs} args - Arguments to update one Standplaats.
     * @example
     * // Update one Standplaats
     * const standplaats = await prisma.standplaats.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StandplaatsUpdateArgs>(args: SelectSubset<T, StandplaatsUpdateArgs<ExtArgs>>): Prisma__StandplaatsClient<$Result.GetResult<Prisma.$StandplaatsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Standplaats.
     * @param {StandplaatsDeleteManyArgs} args - Arguments to filter Standplaats to delete.
     * @example
     * // Delete a few Standplaats
     * const { count } = await prisma.standplaats.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StandplaatsDeleteManyArgs>(args?: SelectSubset<T, StandplaatsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Standplaats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandplaatsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Standplaats
     * const standplaats = await prisma.standplaats.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StandplaatsUpdateManyArgs>(args: SelectSubset<T, StandplaatsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Standplaats.
     * @param {StandplaatsUpsertArgs} args - Arguments to update or create a Standplaats.
     * @example
     * // Update or create a Standplaats
     * const standplaats = await prisma.standplaats.upsert({
     *   create: {
     *     // ... data to create a Standplaats
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Standplaats we want to update
     *   }
     * })
     */
    upsert<T extends StandplaatsUpsertArgs>(args: SelectSubset<T, StandplaatsUpsertArgs<ExtArgs>>): Prisma__StandplaatsClient<$Result.GetResult<Prisma.$StandplaatsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Standplaats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandplaatsCountArgs} args - Arguments to filter Standplaats to count.
     * @example
     * // Count the number of Standplaats
     * const count = await prisma.standplaats.count({
     *   where: {
     *     // ... the filter for the Standplaats we want to count
     *   }
     * })
    **/
    count<T extends StandplaatsCountArgs>(
      args?: Subset<T, StandplaatsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StandplaatsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Standplaats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandplaatsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StandplaatsAggregateArgs>(args: Subset<T, StandplaatsAggregateArgs>): Prisma.PrismaPromise<GetStandplaatsAggregateType<T>>

    /**
     * Group by Standplaats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandplaatsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StandplaatsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StandplaatsGroupByArgs['orderBy'] }
        : { orderBy?: StandplaatsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StandplaatsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStandplaatsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Standplaats model
   */
  readonly fields: StandplaatsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Standplaats.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StandplaatsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    nummeraanduiding<T extends NummeraanduidingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NummeraanduidingDefaultArgs<ExtArgs>>): Prisma__NummeraanduidingClient<$Result.GetResult<Prisma.$NummeraanduidingPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Standplaats model
   */ 
  interface StandplaatsFieldRefs {
    readonly identificatie: FieldRef<"Standplaats", 'String'>
    readonly beginGeldigheid: FieldRef<"Standplaats", 'DateTime'>
    readonly eindGeldigheid: FieldRef<"Standplaats", 'DateTime'>
    readonly geconstateerd: FieldRef<"Standplaats", 'Boolean'>
    readonly documentDatum: FieldRef<"Standplaats", 'DateTime'>
    readonly documentNummer: FieldRef<"Standplaats", 'String'>
    readonly geometry: FieldRef<"Standplaats", 'Json'>
    readonly status: FieldRef<"Standplaats", 'String'>
    readonly createdAt: FieldRef<"Standplaats", 'DateTime'>
    readonly updatedAt: FieldRef<"Standplaats", 'DateTime'>
    readonly nummeraanduidingId: FieldRef<"Standplaats", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Standplaats findUnique
   */
  export type StandplaatsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Standplaats
     */
    select?: StandplaatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandplaatsInclude<ExtArgs> | null
    /**
     * Filter, which Standplaats to fetch.
     */
    where: StandplaatsWhereUniqueInput
  }

  /**
   * Standplaats findUniqueOrThrow
   */
  export type StandplaatsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Standplaats
     */
    select?: StandplaatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandplaatsInclude<ExtArgs> | null
    /**
     * Filter, which Standplaats to fetch.
     */
    where: StandplaatsWhereUniqueInput
  }

  /**
   * Standplaats findFirst
   */
  export type StandplaatsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Standplaats
     */
    select?: StandplaatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandplaatsInclude<ExtArgs> | null
    /**
     * Filter, which Standplaats to fetch.
     */
    where?: StandplaatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Standplaats to fetch.
     */
    orderBy?: StandplaatsOrderByWithRelationInput | StandplaatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Standplaats.
     */
    cursor?: StandplaatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Standplaats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Standplaats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Standplaats.
     */
    distinct?: StandplaatsScalarFieldEnum | StandplaatsScalarFieldEnum[]
  }

  /**
   * Standplaats findFirstOrThrow
   */
  export type StandplaatsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Standplaats
     */
    select?: StandplaatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandplaatsInclude<ExtArgs> | null
    /**
     * Filter, which Standplaats to fetch.
     */
    where?: StandplaatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Standplaats to fetch.
     */
    orderBy?: StandplaatsOrderByWithRelationInput | StandplaatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Standplaats.
     */
    cursor?: StandplaatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Standplaats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Standplaats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Standplaats.
     */
    distinct?: StandplaatsScalarFieldEnum | StandplaatsScalarFieldEnum[]
  }

  /**
   * Standplaats findMany
   */
  export type StandplaatsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Standplaats
     */
    select?: StandplaatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandplaatsInclude<ExtArgs> | null
    /**
     * Filter, which Standplaats to fetch.
     */
    where?: StandplaatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Standplaats to fetch.
     */
    orderBy?: StandplaatsOrderByWithRelationInput | StandplaatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Standplaats.
     */
    cursor?: StandplaatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Standplaats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Standplaats.
     */
    skip?: number
    distinct?: StandplaatsScalarFieldEnum | StandplaatsScalarFieldEnum[]
  }

  /**
   * Standplaats create
   */
  export type StandplaatsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Standplaats
     */
    select?: StandplaatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandplaatsInclude<ExtArgs> | null
    /**
     * The data needed to create a Standplaats.
     */
    data: XOR<StandplaatsCreateInput, StandplaatsUncheckedCreateInput>
  }

  /**
   * Standplaats createMany
   */
  export type StandplaatsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Standplaats.
     */
    data: StandplaatsCreateManyInput | StandplaatsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Standplaats createManyAndReturn
   */
  export type StandplaatsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Standplaats
     */
    select?: StandplaatsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Standplaats.
     */
    data: StandplaatsCreateManyInput | StandplaatsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandplaatsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Standplaats update
   */
  export type StandplaatsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Standplaats
     */
    select?: StandplaatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandplaatsInclude<ExtArgs> | null
    /**
     * The data needed to update a Standplaats.
     */
    data: XOR<StandplaatsUpdateInput, StandplaatsUncheckedUpdateInput>
    /**
     * Choose, which Standplaats to update.
     */
    where: StandplaatsWhereUniqueInput
  }

  /**
   * Standplaats updateMany
   */
  export type StandplaatsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Standplaats.
     */
    data: XOR<StandplaatsUpdateManyMutationInput, StandplaatsUncheckedUpdateManyInput>
    /**
     * Filter which Standplaats to update
     */
    where?: StandplaatsWhereInput
  }

  /**
   * Standplaats upsert
   */
  export type StandplaatsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Standplaats
     */
    select?: StandplaatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandplaatsInclude<ExtArgs> | null
    /**
     * The filter to search for the Standplaats to update in case it exists.
     */
    where: StandplaatsWhereUniqueInput
    /**
     * In case the Standplaats found by the `where` argument doesn't exist, create a new Standplaats with this data.
     */
    create: XOR<StandplaatsCreateInput, StandplaatsUncheckedCreateInput>
    /**
     * In case the Standplaats was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StandplaatsUpdateInput, StandplaatsUncheckedUpdateInput>
  }

  /**
   * Standplaats delete
   */
  export type StandplaatsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Standplaats
     */
    select?: StandplaatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandplaatsInclude<ExtArgs> | null
    /**
     * Filter which Standplaats to delete.
     */
    where: StandplaatsWhereUniqueInput
  }

  /**
   * Standplaats deleteMany
   */
  export type StandplaatsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Standplaats to delete
     */
    where?: StandplaatsWhereInput
  }

  /**
   * Standplaats without action
   */
  export type StandplaatsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Standplaats
     */
    select?: StandplaatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StandplaatsInclude<ExtArgs> | null
  }


  /**
   * Model StatisticsCache
   */

  export type AggregateStatisticsCache = {
    _count: StatisticsCacheCountAggregateOutputType | null
    _min: StatisticsCacheMinAggregateOutputType | null
    _max: StatisticsCacheMaxAggregateOutputType | null
  }

  export type StatisticsCacheMinAggregateOutputType = {
    id: string | null
    type: string | null
    filterHash: string | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type StatisticsCacheMaxAggregateOutputType = {
    id: string | null
    type: string | null
    filterHash: string | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type StatisticsCacheCountAggregateOutputType = {
    id: number
    type: number
    filterHash: number
    data: number
    createdAt: number
    expiresAt: number
    _all: number
  }


  export type StatisticsCacheMinAggregateInputType = {
    id?: true
    type?: true
    filterHash?: true
    createdAt?: true
    expiresAt?: true
  }

  export type StatisticsCacheMaxAggregateInputType = {
    id?: true
    type?: true
    filterHash?: true
    createdAt?: true
    expiresAt?: true
  }

  export type StatisticsCacheCountAggregateInputType = {
    id?: true
    type?: true
    filterHash?: true
    data?: true
    createdAt?: true
    expiresAt?: true
    _all?: true
  }

  export type StatisticsCacheAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StatisticsCache to aggregate.
     */
    where?: StatisticsCacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StatisticsCaches to fetch.
     */
    orderBy?: StatisticsCacheOrderByWithRelationInput | StatisticsCacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StatisticsCacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StatisticsCaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StatisticsCaches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StatisticsCaches
    **/
    _count?: true | StatisticsCacheCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StatisticsCacheMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StatisticsCacheMaxAggregateInputType
  }

  export type GetStatisticsCacheAggregateType<T extends StatisticsCacheAggregateArgs> = {
        [P in keyof T & keyof AggregateStatisticsCache]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStatisticsCache[P]>
      : GetScalarType<T[P], AggregateStatisticsCache[P]>
  }




  export type StatisticsCacheGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StatisticsCacheWhereInput
    orderBy?: StatisticsCacheOrderByWithAggregationInput | StatisticsCacheOrderByWithAggregationInput[]
    by: StatisticsCacheScalarFieldEnum[] | StatisticsCacheScalarFieldEnum
    having?: StatisticsCacheScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StatisticsCacheCountAggregateInputType | true
    _min?: StatisticsCacheMinAggregateInputType
    _max?: StatisticsCacheMaxAggregateInputType
  }

  export type StatisticsCacheGroupByOutputType = {
    id: string
    type: string
    filterHash: string
    data: JsonValue
    createdAt: Date
    expiresAt: Date
    _count: StatisticsCacheCountAggregateOutputType | null
    _min: StatisticsCacheMinAggregateOutputType | null
    _max: StatisticsCacheMaxAggregateOutputType | null
  }

  type GetStatisticsCacheGroupByPayload<T extends StatisticsCacheGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StatisticsCacheGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StatisticsCacheGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StatisticsCacheGroupByOutputType[P]>
            : GetScalarType<T[P], StatisticsCacheGroupByOutputType[P]>
        }
      >
    >


  export type StatisticsCacheSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    filterHash?: boolean
    data?: boolean
    createdAt?: boolean
    expiresAt?: boolean
  }, ExtArgs["result"]["statisticsCache"]>

  export type StatisticsCacheSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    filterHash?: boolean
    data?: boolean
    createdAt?: boolean
    expiresAt?: boolean
  }, ExtArgs["result"]["statisticsCache"]>

  export type StatisticsCacheSelectScalar = {
    id?: boolean
    type?: boolean
    filterHash?: boolean
    data?: boolean
    createdAt?: boolean
    expiresAt?: boolean
  }


  export type $StatisticsCachePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StatisticsCache"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      filterHash: string
      data: Prisma.JsonValue
      createdAt: Date
      expiresAt: Date
    }, ExtArgs["result"]["statisticsCache"]>
    composites: {}
  }

  type StatisticsCacheGetPayload<S extends boolean | null | undefined | StatisticsCacheDefaultArgs> = $Result.GetResult<Prisma.$StatisticsCachePayload, S>

  type StatisticsCacheCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StatisticsCacheFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StatisticsCacheCountAggregateInputType | true
    }

  export interface StatisticsCacheDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StatisticsCache'], meta: { name: 'StatisticsCache' } }
    /**
     * Find zero or one StatisticsCache that matches the filter.
     * @param {StatisticsCacheFindUniqueArgs} args - Arguments to find a StatisticsCache
     * @example
     * // Get one StatisticsCache
     * const statisticsCache = await prisma.statisticsCache.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StatisticsCacheFindUniqueArgs>(args: SelectSubset<T, StatisticsCacheFindUniqueArgs<ExtArgs>>): Prisma__StatisticsCacheClient<$Result.GetResult<Prisma.$StatisticsCachePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StatisticsCache that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StatisticsCacheFindUniqueOrThrowArgs} args - Arguments to find a StatisticsCache
     * @example
     * // Get one StatisticsCache
     * const statisticsCache = await prisma.statisticsCache.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StatisticsCacheFindUniqueOrThrowArgs>(args: SelectSubset<T, StatisticsCacheFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StatisticsCacheClient<$Result.GetResult<Prisma.$StatisticsCachePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StatisticsCache that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatisticsCacheFindFirstArgs} args - Arguments to find a StatisticsCache
     * @example
     * // Get one StatisticsCache
     * const statisticsCache = await prisma.statisticsCache.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StatisticsCacheFindFirstArgs>(args?: SelectSubset<T, StatisticsCacheFindFirstArgs<ExtArgs>>): Prisma__StatisticsCacheClient<$Result.GetResult<Prisma.$StatisticsCachePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StatisticsCache that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatisticsCacheFindFirstOrThrowArgs} args - Arguments to find a StatisticsCache
     * @example
     * // Get one StatisticsCache
     * const statisticsCache = await prisma.statisticsCache.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StatisticsCacheFindFirstOrThrowArgs>(args?: SelectSubset<T, StatisticsCacheFindFirstOrThrowArgs<ExtArgs>>): Prisma__StatisticsCacheClient<$Result.GetResult<Prisma.$StatisticsCachePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StatisticsCaches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatisticsCacheFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StatisticsCaches
     * const statisticsCaches = await prisma.statisticsCache.findMany()
     * 
     * // Get first 10 StatisticsCaches
     * const statisticsCaches = await prisma.statisticsCache.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const statisticsCacheWithIdOnly = await prisma.statisticsCache.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StatisticsCacheFindManyArgs>(args?: SelectSubset<T, StatisticsCacheFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StatisticsCachePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StatisticsCache.
     * @param {StatisticsCacheCreateArgs} args - Arguments to create a StatisticsCache.
     * @example
     * // Create one StatisticsCache
     * const StatisticsCache = await prisma.statisticsCache.create({
     *   data: {
     *     // ... data to create a StatisticsCache
     *   }
     * })
     * 
     */
    create<T extends StatisticsCacheCreateArgs>(args: SelectSubset<T, StatisticsCacheCreateArgs<ExtArgs>>): Prisma__StatisticsCacheClient<$Result.GetResult<Prisma.$StatisticsCachePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StatisticsCaches.
     * @param {StatisticsCacheCreateManyArgs} args - Arguments to create many StatisticsCaches.
     * @example
     * // Create many StatisticsCaches
     * const statisticsCache = await prisma.statisticsCache.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StatisticsCacheCreateManyArgs>(args?: SelectSubset<T, StatisticsCacheCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StatisticsCaches and returns the data saved in the database.
     * @param {StatisticsCacheCreateManyAndReturnArgs} args - Arguments to create many StatisticsCaches.
     * @example
     * // Create many StatisticsCaches
     * const statisticsCache = await prisma.statisticsCache.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StatisticsCaches and only return the `id`
     * const statisticsCacheWithIdOnly = await prisma.statisticsCache.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StatisticsCacheCreateManyAndReturnArgs>(args?: SelectSubset<T, StatisticsCacheCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StatisticsCachePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StatisticsCache.
     * @param {StatisticsCacheDeleteArgs} args - Arguments to delete one StatisticsCache.
     * @example
     * // Delete one StatisticsCache
     * const StatisticsCache = await prisma.statisticsCache.delete({
     *   where: {
     *     // ... filter to delete one StatisticsCache
     *   }
     * })
     * 
     */
    delete<T extends StatisticsCacheDeleteArgs>(args: SelectSubset<T, StatisticsCacheDeleteArgs<ExtArgs>>): Prisma__StatisticsCacheClient<$Result.GetResult<Prisma.$StatisticsCachePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StatisticsCache.
     * @param {StatisticsCacheUpdateArgs} args - Arguments to update one StatisticsCache.
     * @example
     * // Update one StatisticsCache
     * const statisticsCache = await prisma.statisticsCache.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StatisticsCacheUpdateArgs>(args: SelectSubset<T, StatisticsCacheUpdateArgs<ExtArgs>>): Prisma__StatisticsCacheClient<$Result.GetResult<Prisma.$StatisticsCachePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StatisticsCaches.
     * @param {StatisticsCacheDeleteManyArgs} args - Arguments to filter StatisticsCaches to delete.
     * @example
     * // Delete a few StatisticsCaches
     * const { count } = await prisma.statisticsCache.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StatisticsCacheDeleteManyArgs>(args?: SelectSubset<T, StatisticsCacheDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StatisticsCaches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatisticsCacheUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StatisticsCaches
     * const statisticsCache = await prisma.statisticsCache.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StatisticsCacheUpdateManyArgs>(args: SelectSubset<T, StatisticsCacheUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StatisticsCache.
     * @param {StatisticsCacheUpsertArgs} args - Arguments to update or create a StatisticsCache.
     * @example
     * // Update or create a StatisticsCache
     * const statisticsCache = await prisma.statisticsCache.upsert({
     *   create: {
     *     // ... data to create a StatisticsCache
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StatisticsCache we want to update
     *   }
     * })
     */
    upsert<T extends StatisticsCacheUpsertArgs>(args: SelectSubset<T, StatisticsCacheUpsertArgs<ExtArgs>>): Prisma__StatisticsCacheClient<$Result.GetResult<Prisma.$StatisticsCachePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StatisticsCaches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatisticsCacheCountArgs} args - Arguments to filter StatisticsCaches to count.
     * @example
     * // Count the number of StatisticsCaches
     * const count = await prisma.statisticsCache.count({
     *   where: {
     *     // ... the filter for the StatisticsCaches we want to count
     *   }
     * })
    **/
    count<T extends StatisticsCacheCountArgs>(
      args?: Subset<T, StatisticsCacheCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StatisticsCacheCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StatisticsCache.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatisticsCacheAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StatisticsCacheAggregateArgs>(args: Subset<T, StatisticsCacheAggregateArgs>): Prisma.PrismaPromise<GetStatisticsCacheAggregateType<T>>

    /**
     * Group by StatisticsCache.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatisticsCacheGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StatisticsCacheGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StatisticsCacheGroupByArgs['orderBy'] }
        : { orderBy?: StatisticsCacheGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StatisticsCacheGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStatisticsCacheGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StatisticsCache model
   */
  readonly fields: StatisticsCacheFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StatisticsCache.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StatisticsCacheClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StatisticsCache model
   */ 
  interface StatisticsCacheFieldRefs {
    readonly id: FieldRef<"StatisticsCache", 'String'>
    readonly type: FieldRef<"StatisticsCache", 'String'>
    readonly filterHash: FieldRef<"StatisticsCache", 'String'>
    readonly data: FieldRef<"StatisticsCache", 'Json'>
    readonly createdAt: FieldRef<"StatisticsCache", 'DateTime'>
    readonly expiresAt: FieldRef<"StatisticsCache", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StatisticsCache findUnique
   */
  export type StatisticsCacheFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatisticsCache
     */
    select?: StatisticsCacheSelect<ExtArgs> | null
    /**
     * Filter, which StatisticsCache to fetch.
     */
    where: StatisticsCacheWhereUniqueInput
  }

  /**
   * StatisticsCache findUniqueOrThrow
   */
  export type StatisticsCacheFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatisticsCache
     */
    select?: StatisticsCacheSelect<ExtArgs> | null
    /**
     * Filter, which StatisticsCache to fetch.
     */
    where: StatisticsCacheWhereUniqueInput
  }

  /**
   * StatisticsCache findFirst
   */
  export type StatisticsCacheFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatisticsCache
     */
    select?: StatisticsCacheSelect<ExtArgs> | null
    /**
     * Filter, which StatisticsCache to fetch.
     */
    where?: StatisticsCacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StatisticsCaches to fetch.
     */
    orderBy?: StatisticsCacheOrderByWithRelationInput | StatisticsCacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StatisticsCaches.
     */
    cursor?: StatisticsCacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StatisticsCaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StatisticsCaches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StatisticsCaches.
     */
    distinct?: StatisticsCacheScalarFieldEnum | StatisticsCacheScalarFieldEnum[]
  }

  /**
   * StatisticsCache findFirstOrThrow
   */
  export type StatisticsCacheFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatisticsCache
     */
    select?: StatisticsCacheSelect<ExtArgs> | null
    /**
     * Filter, which StatisticsCache to fetch.
     */
    where?: StatisticsCacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StatisticsCaches to fetch.
     */
    orderBy?: StatisticsCacheOrderByWithRelationInput | StatisticsCacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StatisticsCaches.
     */
    cursor?: StatisticsCacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StatisticsCaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StatisticsCaches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StatisticsCaches.
     */
    distinct?: StatisticsCacheScalarFieldEnum | StatisticsCacheScalarFieldEnum[]
  }

  /**
   * StatisticsCache findMany
   */
  export type StatisticsCacheFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatisticsCache
     */
    select?: StatisticsCacheSelect<ExtArgs> | null
    /**
     * Filter, which StatisticsCaches to fetch.
     */
    where?: StatisticsCacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StatisticsCaches to fetch.
     */
    orderBy?: StatisticsCacheOrderByWithRelationInput | StatisticsCacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StatisticsCaches.
     */
    cursor?: StatisticsCacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StatisticsCaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StatisticsCaches.
     */
    skip?: number
    distinct?: StatisticsCacheScalarFieldEnum | StatisticsCacheScalarFieldEnum[]
  }

  /**
   * StatisticsCache create
   */
  export type StatisticsCacheCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatisticsCache
     */
    select?: StatisticsCacheSelect<ExtArgs> | null
    /**
     * The data needed to create a StatisticsCache.
     */
    data: XOR<StatisticsCacheCreateInput, StatisticsCacheUncheckedCreateInput>
  }

  /**
   * StatisticsCache createMany
   */
  export type StatisticsCacheCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StatisticsCaches.
     */
    data: StatisticsCacheCreateManyInput | StatisticsCacheCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StatisticsCache createManyAndReturn
   */
  export type StatisticsCacheCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatisticsCache
     */
    select?: StatisticsCacheSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StatisticsCaches.
     */
    data: StatisticsCacheCreateManyInput | StatisticsCacheCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StatisticsCache update
   */
  export type StatisticsCacheUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatisticsCache
     */
    select?: StatisticsCacheSelect<ExtArgs> | null
    /**
     * The data needed to update a StatisticsCache.
     */
    data: XOR<StatisticsCacheUpdateInput, StatisticsCacheUncheckedUpdateInput>
    /**
     * Choose, which StatisticsCache to update.
     */
    where: StatisticsCacheWhereUniqueInput
  }

  /**
   * StatisticsCache updateMany
   */
  export type StatisticsCacheUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StatisticsCaches.
     */
    data: XOR<StatisticsCacheUpdateManyMutationInput, StatisticsCacheUncheckedUpdateManyInput>
    /**
     * Filter which StatisticsCaches to update
     */
    where?: StatisticsCacheWhereInput
  }

  /**
   * StatisticsCache upsert
   */
  export type StatisticsCacheUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatisticsCache
     */
    select?: StatisticsCacheSelect<ExtArgs> | null
    /**
     * The filter to search for the StatisticsCache to update in case it exists.
     */
    where: StatisticsCacheWhereUniqueInput
    /**
     * In case the StatisticsCache found by the `where` argument doesn't exist, create a new StatisticsCache with this data.
     */
    create: XOR<StatisticsCacheCreateInput, StatisticsCacheUncheckedCreateInput>
    /**
     * In case the StatisticsCache was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StatisticsCacheUpdateInput, StatisticsCacheUncheckedUpdateInput>
  }

  /**
   * StatisticsCache delete
   */
  export type StatisticsCacheDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatisticsCache
     */
    select?: StatisticsCacheSelect<ExtArgs> | null
    /**
     * Filter which StatisticsCache to delete.
     */
    where: StatisticsCacheWhereUniqueInput
  }

  /**
   * StatisticsCache deleteMany
   */
  export type StatisticsCacheDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StatisticsCaches to delete
     */
    where?: StatisticsCacheWhereInput
  }

  /**
   * StatisticsCache without action
   */
  export type StatisticsCacheDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatisticsCache
     */
    select?: StatisticsCacheSelect<ExtArgs> | null
  }


  /**
   * Model AddressCache
   */

  export type AggregateAddressCache = {
    _count: AddressCacheCountAggregateOutputType | null
    _min: AddressCacheMinAggregateOutputType | null
    _max: AddressCacheMaxAggregateOutputType | null
  }

  export type AddressCacheMinAggregateOutputType = {
    id: string | null
    queryHash: string | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type AddressCacheMaxAggregateOutputType = {
    id: string | null
    queryHash: string | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type AddressCacheCountAggregateOutputType = {
    id: number
    queryHash: number
    data: number
    createdAt: number
    expiresAt: number
    _all: number
  }


  export type AddressCacheMinAggregateInputType = {
    id?: true
    queryHash?: true
    createdAt?: true
    expiresAt?: true
  }

  export type AddressCacheMaxAggregateInputType = {
    id?: true
    queryHash?: true
    createdAt?: true
    expiresAt?: true
  }

  export type AddressCacheCountAggregateInputType = {
    id?: true
    queryHash?: true
    data?: true
    createdAt?: true
    expiresAt?: true
    _all?: true
  }

  export type AddressCacheAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AddressCache to aggregate.
     */
    where?: AddressCacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddressCaches to fetch.
     */
    orderBy?: AddressCacheOrderByWithRelationInput | AddressCacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AddressCacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddressCaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddressCaches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AddressCaches
    **/
    _count?: true | AddressCacheCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AddressCacheMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AddressCacheMaxAggregateInputType
  }

  export type GetAddressCacheAggregateType<T extends AddressCacheAggregateArgs> = {
        [P in keyof T & keyof AggregateAddressCache]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddressCache[P]>
      : GetScalarType<T[P], AggregateAddressCache[P]>
  }




  export type AddressCacheGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddressCacheWhereInput
    orderBy?: AddressCacheOrderByWithAggregationInput | AddressCacheOrderByWithAggregationInput[]
    by: AddressCacheScalarFieldEnum[] | AddressCacheScalarFieldEnum
    having?: AddressCacheScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AddressCacheCountAggregateInputType | true
    _min?: AddressCacheMinAggregateInputType
    _max?: AddressCacheMaxAggregateInputType
  }

  export type AddressCacheGroupByOutputType = {
    id: string
    queryHash: string
    data: JsonValue
    createdAt: Date
    expiresAt: Date
    _count: AddressCacheCountAggregateOutputType | null
    _min: AddressCacheMinAggregateOutputType | null
    _max: AddressCacheMaxAggregateOutputType | null
  }

  type GetAddressCacheGroupByPayload<T extends AddressCacheGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AddressCacheGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AddressCacheGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AddressCacheGroupByOutputType[P]>
            : GetScalarType<T[P], AddressCacheGroupByOutputType[P]>
        }
      >
    >


  export type AddressCacheSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    queryHash?: boolean
    data?: boolean
    createdAt?: boolean
    expiresAt?: boolean
  }, ExtArgs["result"]["addressCache"]>

  export type AddressCacheSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    queryHash?: boolean
    data?: boolean
    createdAt?: boolean
    expiresAt?: boolean
  }, ExtArgs["result"]["addressCache"]>

  export type AddressCacheSelectScalar = {
    id?: boolean
    queryHash?: boolean
    data?: boolean
    createdAt?: boolean
    expiresAt?: boolean
  }


  export type $AddressCachePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AddressCache"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      queryHash: string
      data: Prisma.JsonValue
      createdAt: Date
      expiresAt: Date
    }, ExtArgs["result"]["addressCache"]>
    composites: {}
  }

  type AddressCacheGetPayload<S extends boolean | null | undefined | AddressCacheDefaultArgs> = $Result.GetResult<Prisma.$AddressCachePayload, S>

  type AddressCacheCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AddressCacheFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AddressCacheCountAggregateInputType | true
    }

  export interface AddressCacheDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AddressCache'], meta: { name: 'AddressCache' } }
    /**
     * Find zero or one AddressCache that matches the filter.
     * @param {AddressCacheFindUniqueArgs} args - Arguments to find a AddressCache
     * @example
     * // Get one AddressCache
     * const addressCache = await prisma.addressCache.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AddressCacheFindUniqueArgs>(args: SelectSubset<T, AddressCacheFindUniqueArgs<ExtArgs>>): Prisma__AddressCacheClient<$Result.GetResult<Prisma.$AddressCachePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AddressCache that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AddressCacheFindUniqueOrThrowArgs} args - Arguments to find a AddressCache
     * @example
     * // Get one AddressCache
     * const addressCache = await prisma.addressCache.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AddressCacheFindUniqueOrThrowArgs>(args: SelectSubset<T, AddressCacheFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AddressCacheClient<$Result.GetResult<Prisma.$AddressCachePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AddressCache that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressCacheFindFirstArgs} args - Arguments to find a AddressCache
     * @example
     * // Get one AddressCache
     * const addressCache = await prisma.addressCache.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AddressCacheFindFirstArgs>(args?: SelectSubset<T, AddressCacheFindFirstArgs<ExtArgs>>): Prisma__AddressCacheClient<$Result.GetResult<Prisma.$AddressCachePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AddressCache that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressCacheFindFirstOrThrowArgs} args - Arguments to find a AddressCache
     * @example
     * // Get one AddressCache
     * const addressCache = await prisma.addressCache.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AddressCacheFindFirstOrThrowArgs>(args?: SelectSubset<T, AddressCacheFindFirstOrThrowArgs<ExtArgs>>): Prisma__AddressCacheClient<$Result.GetResult<Prisma.$AddressCachePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AddressCaches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressCacheFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AddressCaches
     * const addressCaches = await prisma.addressCache.findMany()
     * 
     * // Get first 10 AddressCaches
     * const addressCaches = await prisma.addressCache.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const addressCacheWithIdOnly = await prisma.addressCache.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AddressCacheFindManyArgs>(args?: SelectSubset<T, AddressCacheFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressCachePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AddressCache.
     * @param {AddressCacheCreateArgs} args - Arguments to create a AddressCache.
     * @example
     * // Create one AddressCache
     * const AddressCache = await prisma.addressCache.create({
     *   data: {
     *     // ... data to create a AddressCache
     *   }
     * })
     * 
     */
    create<T extends AddressCacheCreateArgs>(args: SelectSubset<T, AddressCacheCreateArgs<ExtArgs>>): Prisma__AddressCacheClient<$Result.GetResult<Prisma.$AddressCachePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AddressCaches.
     * @param {AddressCacheCreateManyArgs} args - Arguments to create many AddressCaches.
     * @example
     * // Create many AddressCaches
     * const addressCache = await prisma.addressCache.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AddressCacheCreateManyArgs>(args?: SelectSubset<T, AddressCacheCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AddressCaches and returns the data saved in the database.
     * @param {AddressCacheCreateManyAndReturnArgs} args - Arguments to create many AddressCaches.
     * @example
     * // Create many AddressCaches
     * const addressCache = await prisma.addressCache.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AddressCaches and only return the `id`
     * const addressCacheWithIdOnly = await prisma.addressCache.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AddressCacheCreateManyAndReturnArgs>(args?: SelectSubset<T, AddressCacheCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressCachePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AddressCache.
     * @param {AddressCacheDeleteArgs} args - Arguments to delete one AddressCache.
     * @example
     * // Delete one AddressCache
     * const AddressCache = await prisma.addressCache.delete({
     *   where: {
     *     // ... filter to delete one AddressCache
     *   }
     * })
     * 
     */
    delete<T extends AddressCacheDeleteArgs>(args: SelectSubset<T, AddressCacheDeleteArgs<ExtArgs>>): Prisma__AddressCacheClient<$Result.GetResult<Prisma.$AddressCachePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AddressCache.
     * @param {AddressCacheUpdateArgs} args - Arguments to update one AddressCache.
     * @example
     * // Update one AddressCache
     * const addressCache = await prisma.addressCache.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AddressCacheUpdateArgs>(args: SelectSubset<T, AddressCacheUpdateArgs<ExtArgs>>): Prisma__AddressCacheClient<$Result.GetResult<Prisma.$AddressCachePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AddressCaches.
     * @param {AddressCacheDeleteManyArgs} args - Arguments to filter AddressCaches to delete.
     * @example
     * // Delete a few AddressCaches
     * const { count } = await prisma.addressCache.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AddressCacheDeleteManyArgs>(args?: SelectSubset<T, AddressCacheDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AddressCaches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressCacheUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AddressCaches
     * const addressCache = await prisma.addressCache.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AddressCacheUpdateManyArgs>(args: SelectSubset<T, AddressCacheUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AddressCache.
     * @param {AddressCacheUpsertArgs} args - Arguments to update or create a AddressCache.
     * @example
     * // Update or create a AddressCache
     * const addressCache = await prisma.addressCache.upsert({
     *   create: {
     *     // ... data to create a AddressCache
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AddressCache we want to update
     *   }
     * })
     */
    upsert<T extends AddressCacheUpsertArgs>(args: SelectSubset<T, AddressCacheUpsertArgs<ExtArgs>>): Prisma__AddressCacheClient<$Result.GetResult<Prisma.$AddressCachePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AddressCaches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressCacheCountArgs} args - Arguments to filter AddressCaches to count.
     * @example
     * // Count the number of AddressCaches
     * const count = await prisma.addressCache.count({
     *   where: {
     *     // ... the filter for the AddressCaches we want to count
     *   }
     * })
    **/
    count<T extends AddressCacheCountArgs>(
      args?: Subset<T, AddressCacheCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AddressCacheCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AddressCache.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressCacheAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AddressCacheAggregateArgs>(args: Subset<T, AddressCacheAggregateArgs>): Prisma.PrismaPromise<GetAddressCacheAggregateType<T>>

    /**
     * Group by AddressCache.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressCacheGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AddressCacheGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AddressCacheGroupByArgs['orderBy'] }
        : { orderBy?: AddressCacheGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AddressCacheGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAddressCacheGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AddressCache model
   */
  readonly fields: AddressCacheFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AddressCache.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AddressCacheClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AddressCache model
   */ 
  interface AddressCacheFieldRefs {
    readonly id: FieldRef<"AddressCache", 'String'>
    readonly queryHash: FieldRef<"AddressCache", 'String'>
    readonly data: FieldRef<"AddressCache", 'Json'>
    readonly createdAt: FieldRef<"AddressCache", 'DateTime'>
    readonly expiresAt: FieldRef<"AddressCache", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AddressCache findUnique
   */
  export type AddressCacheFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddressCache
     */
    select?: AddressCacheSelect<ExtArgs> | null
    /**
     * Filter, which AddressCache to fetch.
     */
    where: AddressCacheWhereUniqueInput
  }

  /**
   * AddressCache findUniqueOrThrow
   */
  export type AddressCacheFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddressCache
     */
    select?: AddressCacheSelect<ExtArgs> | null
    /**
     * Filter, which AddressCache to fetch.
     */
    where: AddressCacheWhereUniqueInput
  }

  /**
   * AddressCache findFirst
   */
  export type AddressCacheFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddressCache
     */
    select?: AddressCacheSelect<ExtArgs> | null
    /**
     * Filter, which AddressCache to fetch.
     */
    where?: AddressCacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddressCaches to fetch.
     */
    orderBy?: AddressCacheOrderByWithRelationInput | AddressCacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AddressCaches.
     */
    cursor?: AddressCacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddressCaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddressCaches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AddressCaches.
     */
    distinct?: AddressCacheScalarFieldEnum | AddressCacheScalarFieldEnum[]
  }

  /**
   * AddressCache findFirstOrThrow
   */
  export type AddressCacheFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddressCache
     */
    select?: AddressCacheSelect<ExtArgs> | null
    /**
     * Filter, which AddressCache to fetch.
     */
    where?: AddressCacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddressCaches to fetch.
     */
    orderBy?: AddressCacheOrderByWithRelationInput | AddressCacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AddressCaches.
     */
    cursor?: AddressCacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddressCaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddressCaches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AddressCaches.
     */
    distinct?: AddressCacheScalarFieldEnum | AddressCacheScalarFieldEnum[]
  }

  /**
   * AddressCache findMany
   */
  export type AddressCacheFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddressCache
     */
    select?: AddressCacheSelect<ExtArgs> | null
    /**
     * Filter, which AddressCaches to fetch.
     */
    where?: AddressCacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddressCaches to fetch.
     */
    orderBy?: AddressCacheOrderByWithRelationInput | AddressCacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AddressCaches.
     */
    cursor?: AddressCacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddressCaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddressCaches.
     */
    skip?: number
    distinct?: AddressCacheScalarFieldEnum | AddressCacheScalarFieldEnum[]
  }

  /**
   * AddressCache create
   */
  export type AddressCacheCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddressCache
     */
    select?: AddressCacheSelect<ExtArgs> | null
    /**
     * The data needed to create a AddressCache.
     */
    data: XOR<AddressCacheCreateInput, AddressCacheUncheckedCreateInput>
  }

  /**
   * AddressCache createMany
   */
  export type AddressCacheCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AddressCaches.
     */
    data: AddressCacheCreateManyInput | AddressCacheCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AddressCache createManyAndReturn
   */
  export type AddressCacheCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddressCache
     */
    select?: AddressCacheSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AddressCaches.
     */
    data: AddressCacheCreateManyInput | AddressCacheCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AddressCache update
   */
  export type AddressCacheUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddressCache
     */
    select?: AddressCacheSelect<ExtArgs> | null
    /**
     * The data needed to update a AddressCache.
     */
    data: XOR<AddressCacheUpdateInput, AddressCacheUncheckedUpdateInput>
    /**
     * Choose, which AddressCache to update.
     */
    where: AddressCacheWhereUniqueInput
  }

  /**
   * AddressCache updateMany
   */
  export type AddressCacheUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AddressCaches.
     */
    data: XOR<AddressCacheUpdateManyMutationInput, AddressCacheUncheckedUpdateManyInput>
    /**
     * Filter which AddressCaches to update
     */
    where?: AddressCacheWhereInput
  }

  /**
   * AddressCache upsert
   */
  export type AddressCacheUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddressCache
     */
    select?: AddressCacheSelect<ExtArgs> | null
    /**
     * The filter to search for the AddressCache to update in case it exists.
     */
    where: AddressCacheWhereUniqueInput
    /**
     * In case the AddressCache found by the `where` argument doesn't exist, create a new AddressCache with this data.
     */
    create: XOR<AddressCacheCreateInput, AddressCacheUncheckedCreateInput>
    /**
     * In case the AddressCache was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AddressCacheUpdateInput, AddressCacheUncheckedUpdateInput>
  }

  /**
   * AddressCache delete
   */
  export type AddressCacheDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddressCache
     */
    select?: AddressCacheSelect<ExtArgs> | null
    /**
     * Filter which AddressCache to delete.
     */
    where: AddressCacheWhereUniqueInput
  }

  /**
   * AddressCache deleteMany
   */
  export type AddressCacheDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AddressCaches to delete
     */
    where?: AddressCacheWhereInput
  }

  /**
   * AddressCache without action
   */
  export type AddressCacheDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddressCache
     */
    select?: AddressCacheSelect<ExtArgs> | null
  }


  /**
   * Model ExportJob
   */

  export type AggregateExportJob = {
    _count: ExportJobCountAggregateOutputType | null
    _avg: ExportJobAvgAggregateOutputType | null
    _sum: ExportJobSumAggregateOutputType | null
    _min: ExportJobMinAggregateOutputType | null
    _max: ExportJobMaxAggregateOutputType | null
  }

  export type ExportJobAvgAggregateOutputType = {
    count: number | null
    processedCount: number | null
    percentComplete: number | null
  }

  export type ExportJobSumAggregateOutputType = {
    count: number | null
    processedCount: number | null
    percentComplete: number | null
  }

  export type ExportJobMinAggregateOutputType = {
    id: string | null
    status: string | null
    format: string | null
    count: number | null
    processedCount: number | null
    percentComplete: number | null
    blobUrl: string | null
    error: string | null
    createdAt: Date | null
    startedAt: Date | null
    completedAt: Date | null
    userId: string | null
  }

  export type ExportJobMaxAggregateOutputType = {
    id: string | null
    status: string | null
    format: string | null
    count: number | null
    processedCount: number | null
    percentComplete: number | null
    blobUrl: string | null
    error: string | null
    createdAt: Date | null
    startedAt: Date | null
    completedAt: Date | null
    userId: string | null
  }

  export type ExportJobCountAggregateOutputType = {
    id: number
    status: number
    format: number
    count: number
    processedCount: number
    percentComplete: number
    filters: number
    blobUrl: number
    error: number
    createdAt: number
    startedAt: number
    completedAt: number
    userId: number
    _all: number
  }


  export type ExportJobAvgAggregateInputType = {
    count?: true
    processedCount?: true
    percentComplete?: true
  }

  export type ExportJobSumAggregateInputType = {
    count?: true
    processedCount?: true
    percentComplete?: true
  }

  export type ExportJobMinAggregateInputType = {
    id?: true
    status?: true
    format?: true
    count?: true
    processedCount?: true
    percentComplete?: true
    blobUrl?: true
    error?: true
    createdAt?: true
    startedAt?: true
    completedAt?: true
    userId?: true
  }

  export type ExportJobMaxAggregateInputType = {
    id?: true
    status?: true
    format?: true
    count?: true
    processedCount?: true
    percentComplete?: true
    blobUrl?: true
    error?: true
    createdAt?: true
    startedAt?: true
    completedAt?: true
    userId?: true
  }

  export type ExportJobCountAggregateInputType = {
    id?: true
    status?: true
    format?: true
    count?: true
    processedCount?: true
    percentComplete?: true
    filters?: true
    blobUrl?: true
    error?: true
    createdAt?: true
    startedAt?: true
    completedAt?: true
    userId?: true
    _all?: true
  }

  export type ExportJobAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExportJob to aggregate.
     */
    where?: ExportJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExportJobs to fetch.
     */
    orderBy?: ExportJobOrderByWithRelationInput | ExportJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExportJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExportJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExportJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExportJobs
    **/
    _count?: true | ExportJobCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExportJobAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExportJobSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExportJobMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExportJobMaxAggregateInputType
  }

  export type GetExportJobAggregateType<T extends ExportJobAggregateArgs> = {
        [P in keyof T & keyof AggregateExportJob]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExportJob[P]>
      : GetScalarType<T[P], AggregateExportJob[P]>
  }




  export type ExportJobGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExportJobWhereInput
    orderBy?: ExportJobOrderByWithAggregationInput | ExportJobOrderByWithAggregationInput[]
    by: ExportJobScalarFieldEnum[] | ExportJobScalarFieldEnum
    having?: ExportJobScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExportJobCountAggregateInputType | true
    _avg?: ExportJobAvgAggregateInputType
    _sum?: ExportJobSumAggregateInputType
    _min?: ExportJobMinAggregateInputType
    _max?: ExportJobMaxAggregateInputType
  }

  export type ExportJobGroupByOutputType = {
    id: string
    status: string
    format: string
    count: number
    processedCount: number | null
    percentComplete: number | null
    filters: JsonValue
    blobUrl: string | null
    error: string | null
    createdAt: Date
    startedAt: Date | null
    completedAt: Date | null
    userId: string | null
    _count: ExportJobCountAggregateOutputType | null
    _avg: ExportJobAvgAggregateOutputType | null
    _sum: ExportJobSumAggregateOutputType | null
    _min: ExportJobMinAggregateOutputType | null
    _max: ExportJobMaxAggregateOutputType | null
  }

  type GetExportJobGroupByPayload<T extends ExportJobGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExportJobGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExportJobGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExportJobGroupByOutputType[P]>
            : GetScalarType<T[P], ExportJobGroupByOutputType[P]>
        }
      >
    >


  export type ExportJobSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    format?: boolean
    count?: boolean
    processedCount?: boolean
    percentComplete?: boolean
    filters?: boolean
    blobUrl?: boolean
    error?: boolean
    createdAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    userId?: boolean
  }, ExtArgs["result"]["exportJob"]>

  export type ExportJobSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    format?: boolean
    count?: boolean
    processedCount?: boolean
    percentComplete?: boolean
    filters?: boolean
    blobUrl?: boolean
    error?: boolean
    createdAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    userId?: boolean
  }, ExtArgs["result"]["exportJob"]>

  export type ExportJobSelectScalar = {
    id?: boolean
    status?: boolean
    format?: boolean
    count?: boolean
    processedCount?: boolean
    percentComplete?: boolean
    filters?: boolean
    blobUrl?: boolean
    error?: boolean
    createdAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    userId?: boolean
  }


  export type $ExportJobPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExportJob"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      status: string
      format: string
      count: number
      processedCount: number | null
      percentComplete: number | null
      filters: Prisma.JsonValue
      blobUrl: string | null
      error: string | null
      createdAt: Date
      startedAt: Date | null
      completedAt: Date | null
      userId: string | null
    }, ExtArgs["result"]["exportJob"]>
    composites: {}
  }

  type ExportJobGetPayload<S extends boolean | null | undefined | ExportJobDefaultArgs> = $Result.GetResult<Prisma.$ExportJobPayload, S>

  type ExportJobCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ExportJobFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ExportJobCountAggregateInputType | true
    }

  export interface ExportJobDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExportJob'], meta: { name: 'ExportJob' } }
    /**
     * Find zero or one ExportJob that matches the filter.
     * @param {ExportJobFindUniqueArgs} args - Arguments to find a ExportJob
     * @example
     * // Get one ExportJob
     * const exportJob = await prisma.exportJob.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExportJobFindUniqueArgs>(args: SelectSubset<T, ExportJobFindUniqueArgs<ExtArgs>>): Prisma__ExportJobClient<$Result.GetResult<Prisma.$ExportJobPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ExportJob that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ExportJobFindUniqueOrThrowArgs} args - Arguments to find a ExportJob
     * @example
     * // Get one ExportJob
     * const exportJob = await prisma.exportJob.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExportJobFindUniqueOrThrowArgs>(args: SelectSubset<T, ExportJobFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExportJobClient<$Result.GetResult<Prisma.$ExportJobPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ExportJob that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExportJobFindFirstArgs} args - Arguments to find a ExportJob
     * @example
     * // Get one ExportJob
     * const exportJob = await prisma.exportJob.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExportJobFindFirstArgs>(args?: SelectSubset<T, ExportJobFindFirstArgs<ExtArgs>>): Prisma__ExportJobClient<$Result.GetResult<Prisma.$ExportJobPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ExportJob that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExportJobFindFirstOrThrowArgs} args - Arguments to find a ExportJob
     * @example
     * // Get one ExportJob
     * const exportJob = await prisma.exportJob.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExportJobFindFirstOrThrowArgs>(args?: SelectSubset<T, ExportJobFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExportJobClient<$Result.GetResult<Prisma.$ExportJobPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ExportJobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExportJobFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExportJobs
     * const exportJobs = await prisma.exportJob.findMany()
     * 
     * // Get first 10 ExportJobs
     * const exportJobs = await prisma.exportJob.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const exportJobWithIdOnly = await prisma.exportJob.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExportJobFindManyArgs>(args?: SelectSubset<T, ExportJobFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExportJobPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ExportJob.
     * @param {ExportJobCreateArgs} args - Arguments to create a ExportJob.
     * @example
     * // Create one ExportJob
     * const ExportJob = await prisma.exportJob.create({
     *   data: {
     *     // ... data to create a ExportJob
     *   }
     * })
     * 
     */
    create<T extends ExportJobCreateArgs>(args: SelectSubset<T, ExportJobCreateArgs<ExtArgs>>): Prisma__ExportJobClient<$Result.GetResult<Prisma.$ExportJobPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ExportJobs.
     * @param {ExportJobCreateManyArgs} args - Arguments to create many ExportJobs.
     * @example
     * // Create many ExportJobs
     * const exportJob = await prisma.exportJob.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExportJobCreateManyArgs>(args?: SelectSubset<T, ExportJobCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExportJobs and returns the data saved in the database.
     * @param {ExportJobCreateManyAndReturnArgs} args - Arguments to create many ExportJobs.
     * @example
     * // Create many ExportJobs
     * const exportJob = await prisma.exportJob.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExportJobs and only return the `id`
     * const exportJobWithIdOnly = await prisma.exportJob.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExportJobCreateManyAndReturnArgs>(args?: SelectSubset<T, ExportJobCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExportJobPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ExportJob.
     * @param {ExportJobDeleteArgs} args - Arguments to delete one ExportJob.
     * @example
     * // Delete one ExportJob
     * const ExportJob = await prisma.exportJob.delete({
     *   where: {
     *     // ... filter to delete one ExportJob
     *   }
     * })
     * 
     */
    delete<T extends ExportJobDeleteArgs>(args: SelectSubset<T, ExportJobDeleteArgs<ExtArgs>>): Prisma__ExportJobClient<$Result.GetResult<Prisma.$ExportJobPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ExportJob.
     * @param {ExportJobUpdateArgs} args - Arguments to update one ExportJob.
     * @example
     * // Update one ExportJob
     * const exportJob = await prisma.exportJob.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExportJobUpdateArgs>(args: SelectSubset<T, ExportJobUpdateArgs<ExtArgs>>): Prisma__ExportJobClient<$Result.GetResult<Prisma.$ExportJobPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ExportJobs.
     * @param {ExportJobDeleteManyArgs} args - Arguments to filter ExportJobs to delete.
     * @example
     * // Delete a few ExportJobs
     * const { count } = await prisma.exportJob.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExportJobDeleteManyArgs>(args?: SelectSubset<T, ExportJobDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExportJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExportJobUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExportJobs
     * const exportJob = await prisma.exportJob.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExportJobUpdateManyArgs>(args: SelectSubset<T, ExportJobUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ExportJob.
     * @param {ExportJobUpsertArgs} args - Arguments to update or create a ExportJob.
     * @example
     * // Update or create a ExportJob
     * const exportJob = await prisma.exportJob.upsert({
     *   create: {
     *     // ... data to create a ExportJob
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExportJob we want to update
     *   }
     * })
     */
    upsert<T extends ExportJobUpsertArgs>(args: SelectSubset<T, ExportJobUpsertArgs<ExtArgs>>): Prisma__ExportJobClient<$Result.GetResult<Prisma.$ExportJobPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ExportJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExportJobCountArgs} args - Arguments to filter ExportJobs to count.
     * @example
     * // Count the number of ExportJobs
     * const count = await prisma.exportJob.count({
     *   where: {
     *     // ... the filter for the ExportJobs we want to count
     *   }
     * })
    **/
    count<T extends ExportJobCountArgs>(
      args?: Subset<T, ExportJobCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExportJobCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExportJob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExportJobAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExportJobAggregateArgs>(args: Subset<T, ExportJobAggregateArgs>): Prisma.PrismaPromise<GetExportJobAggregateType<T>>

    /**
     * Group by ExportJob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExportJobGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExportJobGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExportJobGroupByArgs['orderBy'] }
        : { orderBy?: ExportJobGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExportJobGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExportJobGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExportJob model
   */
  readonly fields: ExportJobFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExportJob.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExportJobClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExportJob model
   */ 
  interface ExportJobFieldRefs {
    readonly id: FieldRef<"ExportJob", 'String'>
    readonly status: FieldRef<"ExportJob", 'String'>
    readonly format: FieldRef<"ExportJob", 'String'>
    readonly count: FieldRef<"ExportJob", 'Int'>
    readonly processedCount: FieldRef<"ExportJob", 'Int'>
    readonly percentComplete: FieldRef<"ExportJob", 'Int'>
    readonly filters: FieldRef<"ExportJob", 'Json'>
    readonly blobUrl: FieldRef<"ExportJob", 'String'>
    readonly error: FieldRef<"ExportJob", 'String'>
    readonly createdAt: FieldRef<"ExportJob", 'DateTime'>
    readonly startedAt: FieldRef<"ExportJob", 'DateTime'>
    readonly completedAt: FieldRef<"ExportJob", 'DateTime'>
    readonly userId: FieldRef<"ExportJob", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ExportJob findUnique
   */
  export type ExportJobFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportJob
     */
    select?: ExportJobSelect<ExtArgs> | null
    /**
     * Filter, which ExportJob to fetch.
     */
    where: ExportJobWhereUniqueInput
  }

  /**
   * ExportJob findUniqueOrThrow
   */
  export type ExportJobFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportJob
     */
    select?: ExportJobSelect<ExtArgs> | null
    /**
     * Filter, which ExportJob to fetch.
     */
    where: ExportJobWhereUniqueInput
  }

  /**
   * ExportJob findFirst
   */
  export type ExportJobFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportJob
     */
    select?: ExportJobSelect<ExtArgs> | null
    /**
     * Filter, which ExportJob to fetch.
     */
    where?: ExportJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExportJobs to fetch.
     */
    orderBy?: ExportJobOrderByWithRelationInput | ExportJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExportJobs.
     */
    cursor?: ExportJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExportJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExportJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExportJobs.
     */
    distinct?: ExportJobScalarFieldEnum | ExportJobScalarFieldEnum[]
  }

  /**
   * ExportJob findFirstOrThrow
   */
  export type ExportJobFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportJob
     */
    select?: ExportJobSelect<ExtArgs> | null
    /**
     * Filter, which ExportJob to fetch.
     */
    where?: ExportJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExportJobs to fetch.
     */
    orderBy?: ExportJobOrderByWithRelationInput | ExportJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExportJobs.
     */
    cursor?: ExportJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExportJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExportJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExportJobs.
     */
    distinct?: ExportJobScalarFieldEnum | ExportJobScalarFieldEnum[]
  }

  /**
   * ExportJob findMany
   */
  export type ExportJobFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportJob
     */
    select?: ExportJobSelect<ExtArgs> | null
    /**
     * Filter, which ExportJobs to fetch.
     */
    where?: ExportJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExportJobs to fetch.
     */
    orderBy?: ExportJobOrderByWithRelationInput | ExportJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExportJobs.
     */
    cursor?: ExportJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExportJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExportJobs.
     */
    skip?: number
    distinct?: ExportJobScalarFieldEnum | ExportJobScalarFieldEnum[]
  }

  /**
   * ExportJob create
   */
  export type ExportJobCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportJob
     */
    select?: ExportJobSelect<ExtArgs> | null
    /**
     * The data needed to create a ExportJob.
     */
    data: XOR<ExportJobCreateInput, ExportJobUncheckedCreateInput>
  }

  /**
   * ExportJob createMany
   */
  export type ExportJobCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExportJobs.
     */
    data: ExportJobCreateManyInput | ExportJobCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExportJob createManyAndReturn
   */
  export type ExportJobCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportJob
     */
    select?: ExportJobSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ExportJobs.
     */
    data: ExportJobCreateManyInput | ExportJobCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExportJob update
   */
  export type ExportJobUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportJob
     */
    select?: ExportJobSelect<ExtArgs> | null
    /**
     * The data needed to update a ExportJob.
     */
    data: XOR<ExportJobUpdateInput, ExportJobUncheckedUpdateInput>
    /**
     * Choose, which ExportJob to update.
     */
    where: ExportJobWhereUniqueInput
  }

  /**
   * ExportJob updateMany
   */
  export type ExportJobUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExportJobs.
     */
    data: XOR<ExportJobUpdateManyMutationInput, ExportJobUncheckedUpdateManyInput>
    /**
     * Filter which ExportJobs to update
     */
    where?: ExportJobWhereInput
  }

  /**
   * ExportJob upsert
   */
  export type ExportJobUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportJob
     */
    select?: ExportJobSelect<ExtArgs> | null
    /**
     * The filter to search for the ExportJob to update in case it exists.
     */
    where: ExportJobWhereUniqueInput
    /**
     * In case the ExportJob found by the `where` argument doesn't exist, create a new ExportJob with this data.
     */
    create: XOR<ExportJobCreateInput, ExportJobUncheckedCreateInput>
    /**
     * In case the ExportJob was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExportJobUpdateInput, ExportJobUncheckedUpdateInput>
  }

  /**
   * ExportJob delete
   */
  export type ExportJobDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportJob
     */
    select?: ExportJobSelect<ExtArgs> | null
    /**
     * Filter which ExportJob to delete.
     */
    where: ExportJobWhereUniqueInput
  }

  /**
   * ExportJob deleteMany
   */
  export type ExportJobDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExportJobs to delete
     */
    where?: ExportJobWhereInput
  }

  /**
   * ExportJob without action
   */
  export type ExportJobDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExportJob
     */
    select?: ExportJobSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const WoonplaatsScalarFieldEnum: {
    identificatie: 'identificatie',
    beginGeldigheid: 'beginGeldigheid',
    eindGeldigheid: 'eindGeldigheid',
    geconstateerd: 'geconstateerd',
    documentDatum: 'documentDatum',
    documentNummer: 'documentNummer',
    geometry: 'geometry',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    naam: 'naam'
  };

  export type WoonplaatsScalarFieldEnum = (typeof WoonplaatsScalarFieldEnum)[keyof typeof WoonplaatsScalarFieldEnum]


  export const OpenbareRuimteScalarFieldEnum: {
    identificatie: 'identificatie',
    beginGeldigheid: 'beginGeldigheid',
    eindGeldigheid: 'eindGeldigheid',
    geconstateerd: 'geconstateerd',
    documentDatum: 'documentDatum',
    documentNummer: 'documentNummer',
    geometry: 'geometry',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    naam: 'naam',
    type: 'type',
    woonplaatsId: 'woonplaatsId'
  };

  export type OpenbareRuimteScalarFieldEnum = (typeof OpenbareRuimteScalarFieldEnum)[keyof typeof OpenbareRuimteScalarFieldEnum]


  export const PandScalarFieldEnum: {
    identificatie: 'identificatie',
    beginGeldigheid: 'beginGeldigheid',
    eindGeldigheid: 'eindGeldigheid',
    geconstateerd: 'geconstateerd',
    documentDatum: 'documentDatum',
    documentNummer: 'documentNummer',
    geometry: 'geometry',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    oorspronkelijkBouwjaar: 'oorspronkelijkBouwjaar'
  };

  export type PandScalarFieldEnum = (typeof PandScalarFieldEnum)[keyof typeof PandScalarFieldEnum]


  export const NummeraanduidingScalarFieldEnum: {
    identificatie: 'identificatie',
    beginGeldigheid: 'beginGeldigheid',
    eindGeldigheid: 'eindGeldigheid',
    geconstateerd: 'geconstateerd',
    documentDatum: 'documentDatum',
    documentNummer: 'documentNummer',
    geometry: 'geometry',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    huisnummer: 'huisnummer',
    huisletter: 'huisletter',
    huisnummertoevoeging: 'huisnummertoevoeging',
    postcode: 'postcode',
    type: 'type',
    openbareRuimteId: 'openbareRuimteId'
  };

  export type NummeraanduidingScalarFieldEnum = (typeof NummeraanduidingScalarFieldEnum)[keyof typeof NummeraanduidingScalarFieldEnum]


  export const VerblijfsobjectScalarFieldEnum: {
    identificatie: 'identificatie',
    beginGeldigheid: 'beginGeldigheid',
    eindGeldigheid: 'eindGeldigheid',
    geconstateerd: 'geconstateerd',
    documentDatum: 'documentDatum',
    documentNummer: 'documentNummer',
    geometry: 'geometry',
    rd_x: 'rd_x',
    rd_y: 'rd_y',
    longitude: 'longitude',
    latitude: 'latitude',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    gebruiksdoel: 'gebruiksdoel',
    oppervlakte: 'oppervlakte',
    nummeraanduidingId: 'nummeraanduidingId',
    pandId: 'pandId'
  };

  export type VerblijfsobjectScalarFieldEnum = (typeof VerblijfsobjectScalarFieldEnum)[keyof typeof VerblijfsobjectScalarFieldEnum]


  export const Spatial_ref_sysScalarFieldEnum: {
    srid: 'srid',
    auth_name: 'auth_name',
    auth_srid: 'auth_srid',
    srtext: 'srtext',
    proj4text: 'proj4text'
  };

  export type Spatial_ref_sysScalarFieldEnum = (typeof Spatial_ref_sysScalarFieldEnum)[keyof typeof Spatial_ref_sysScalarFieldEnum]


  export const ImportJobScalarFieldEnum: {
    id: 'id',
    entityType: 'entityType',
    filePath: 'filePath',
    status: 'status',
    attempts: 'attempts',
    error: 'error',
    createdAt: 'createdAt',
    startedAt: 'startedAt',
    completedAt: 'completedAt'
  };

  export type ImportJobScalarFieldEnum = (typeof ImportJobScalarFieldEnum)[keyof typeof ImportJobScalarFieldEnum]


  export const NummeraanduidingStagingScalarFieldEnum: {
    id: 'id',
    identificatie: 'identificatie',
    huisnummer: 'huisnummer',
    huisletter: 'huisletter',
    huisnummertoevoeging: 'huisnummertoevoeging',
    postcode: 'postcode',
    typeObject: 'typeObject',
    status: 'status',
    geconstateerd: 'geconstateerd',
    documentDatum: 'documentDatum',
    documentNummer: 'documentNummer',
    beginGeldigheid: 'beginGeldigheid',
    tijdstipRegistratie: 'tijdstipRegistratie',
    openbareRuimteId: 'openbareRuimteId',
    processingBatch: 'processingBatch',
    processed: 'processed',
    error: 'error',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NummeraanduidingStagingScalarFieldEnum = (typeof NummeraanduidingStagingScalarFieldEnum)[keyof typeof NummeraanduidingStagingScalarFieldEnum]


  export const LigplaatsScalarFieldEnum: {
    identificatie: 'identificatie',
    beginGeldigheid: 'beginGeldigheid',
    eindGeldigheid: 'eindGeldigheid',
    geconstateerd: 'geconstateerd',
    documentDatum: 'documentDatum',
    documentNummer: 'documentNummer',
    geometry: 'geometry',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    nummeraanduidingId: 'nummeraanduidingId'
  };

  export type LigplaatsScalarFieldEnum = (typeof LigplaatsScalarFieldEnum)[keyof typeof LigplaatsScalarFieldEnum]


  export const StandplaatsScalarFieldEnum: {
    identificatie: 'identificatie',
    beginGeldigheid: 'beginGeldigheid',
    eindGeldigheid: 'eindGeldigheid',
    geconstateerd: 'geconstateerd',
    documentDatum: 'documentDatum',
    documentNummer: 'documentNummer',
    geometry: 'geometry',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    nummeraanduidingId: 'nummeraanduidingId'
  };

  export type StandplaatsScalarFieldEnum = (typeof StandplaatsScalarFieldEnum)[keyof typeof StandplaatsScalarFieldEnum]


  export const StatisticsCacheScalarFieldEnum: {
    id: 'id',
    type: 'type',
    filterHash: 'filterHash',
    data: 'data',
    createdAt: 'createdAt',
    expiresAt: 'expiresAt'
  };

  export type StatisticsCacheScalarFieldEnum = (typeof StatisticsCacheScalarFieldEnum)[keyof typeof StatisticsCacheScalarFieldEnum]


  export const AddressCacheScalarFieldEnum: {
    id: 'id',
    queryHash: 'queryHash',
    data: 'data',
    createdAt: 'createdAt',
    expiresAt: 'expiresAt'
  };

  export type AddressCacheScalarFieldEnum = (typeof AddressCacheScalarFieldEnum)[keyof typeof AddressCacheScalarFieldEnum]


  export const ExportJobScalarFieldEnum: {
    id: 'id',
    status: 'status',
    format: 'format',
    count: 'count',
    processedCount: 'processedCount',
    percentComplete: 'percentComplete',
    filters: 'filters',
    blobUrl: 'blobUrl',
    error: 'error',
    createdAt: 'createdAt',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    userId: 'userId'
  };

  export type ExportJobScalarFieldEnum = (typeof ExportJobScalarFieldEnum)[keyof typeof ExportJobScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type WoonplaatsWhereInput = {
    AND?: WoonplaatsWhereInput | WoonplaatsWhereInput[]
    OR?: WoonplaatsWhereInput[]
    NOT?: WoonplaatsWhereInput | WoonplaatsWhereInput[]
    identificatie?: StringFilter<"Woonplaats"> | string
    beginGeldigheid?: DateTimeFilter<"Woonplaats"> | Date | string
    eindGeldigheid?: DateTimeNullableFilter<"Woonplaats"> | Date | string | null
    geconstateerd?: BoolFilter<"Woonplaats"> | boolean
    documentDatum?: DateTimeFilter<"Woonplaats"> | Date | string
    documentNummer?: StringFilter<"Woonplaats"> | string
    geometry?: JsonNullableFilter<"Woonplaats">
    status?: StringFilter<"Woonplaats"> | string
    createdAt?: DateTimeFilter<"Woonplaats"> | Date | string
    updatedAt?: DateTimeFilter<"Woonplaats"> | Date | string
    naam?: StringFilter<"Woonplaats"> | string
    openbareRuimtes?: OpenbareRuimteListRelationFilter
  }

  export type WoonplaatsOrderByWithRelationInput = {
    identificatie?: SortOrder
    beginGeldigheid?: SortOrder
    eindGeldigheid?: SortOrderInput | SortOrder
    geconstateerd?: SortOrder
    documentDatum?: SortOrder
    documentNummer?: SortOrder
    geometry?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    naam?: SortOrder
    openbareRuimtes?: OpenbareRuimteOrderByRelationAggregateInput
  }

  export type WoonplaatsWhereUniqueInput = Prisma.AtLeast<{
    identificatie?: string
    AND?: WoonplaatsWhereInput | WoonplaatsWhereInput[]
    OR?: WoonplaatsWhereInput[]
    NOT?: WoonplaatsWhereInput | WoonplaatsWhereInput[]
    beginGeldigheid?: DateTimeFilter<"Woonplaats"> | Date | string
    eindGeldigheid?: DateTimeNullableFilter<"Woonplaats"> | Date | string | null
    geconstateerd?: BoolFilter<"Woonplaats"> | boolean
    documentDatum?: DateTimeFilter<"Woonplaats"> | Date | string
    documentNummer?: StringFilter<"Woonplaats"> | string
    geometry?: JsonNullableFilter<"Woonplaats">
    status?: StringFilter<"Woonplaats"> | string
    createdAt?: DateTimeFilter<"Woonplaats"> | Date | string
    updatedAt?: DateTimeFilter<"Woonplaats"> | Date | string
    naam?: StringFilter<"Woonplaats"> | string
    openbareRuimtes?: OpenbareRuimteListRelationFilter
  }, "identificatie">

  export type WoonplaatsOrderByWithAggregationInput = {
    identificatie?: SortOrder
    beginGeldigheid?: SortOrder
    eindGeldigheid?: SortOrderInput | SortOrder
    geconstateerd?: SortOrder
    documentDatum?: SortOrder
    documentNummer?: SortOrder
    geometry?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    naam?: SortOrder
    _count?: WoonplaatsCountOrderByAggregateInput
    _max?: WoonplaatsMaxOrderByAggregateInput
    _min?: WoonplaatsMinOrderByAggregateInput
  }

  export type WoonplaatsScalarWhereWithAggregatesInput = {
    AND?: WoonplaatsScalarWhereWithAggregatesInput | WoonplaatsScalarWhereWithAggregatesInput[]
    OR?: WoonplaatsScalarWhereWithAggregatesInput[]
    NOT?: WoonplaatsScalarWhereWithAggregatesInput | WoonplaatsScalarWhereWithAggregatesInput[]
    identificatie?: StringWithAggregatesFilter<"Woonplaats"> | string
    beginGeldigheid?: DateTimeWithAggregatesFilter<"Woonplaats"> | Date | string
    eindGeldigheid?: DateTimeNullableWithAggregatesFilter<"Woonplaats"> | Date | string | null
    geconstateerd?: BoolWithAggregatesFilter<"Woonplaats"> | boolean
    documentDatum?: DateTimeWithAggregatesFilter<"Woonplaats"> | Date | string
    documentNummer?: StringWithAggregatesFilter<"Woonplaats"> | string
    geometry?: JsonNullableWithAggregatesFilter<"Woonplaats">
    status?: StringWithAggregatesFilter<"Woonplaats"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Woonplaats"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Woonplaats"> | Date | string
    naam?: StringWithAggregatesFilter<"Woonplaats"> | string
  }

  export type OpenbareRuimteWhereInput = {
    AND?: OpenbareRuimteWhereInput | OpenbareRuimteWhereInput[]
    OR?: OpenbareRuimteWhereInput[]
    NOT?: OpenbareRuimteWhereInput | OpenbareRuimteWhereInput[]
    identificatie?: StringFilter<"OpenbareRuimte"> | string
    beginGeldigheid?: DateTimeFilter<"OpenbareRuimte"> | Date | string
    eindGeldigheid?: DateTimeNullableFilter<"OpenbareRuimte"> | Date | string | null
    geconstateerd?: BoolFilter<"OpenbareRuimte"> | boolean
    documentDatum?: DateTimeFilter<"OpenbareRuimte"> | Date | string
    documentNummer?: StringFilter<"OpenbareRuimte"> | string
    geometry?: JsonNullableFilter<"OpenbareRuimte">
    status?: StringFilter<"OpenbareRuimte"> | string
    createdAt?: DateTimeFilter<"OpenbareRuimte"> | Date | string
    updatedAt?: DateTimeFilter<"OpenbareRuimte"> | Date | string
    naam?: StringFilter<"OpenbareRuimte"> | string
    type?: StringFilter<"OpenbareRuimte"> | string
    woonplaatsId?: StringFilter<"OpenbareRuimte"> | string
    nummeraanduidingen?: NummeraanduidingListRelationFilter
    woonplaats?: XOR<WoonplaatsRelationFilter, WoonplaatsWhereInput>
  }

  export type OpenbareRuimteOrderByWithRelationInput = {
    identificatie?: SortOrder
    beginGeldigheid?: SortOrder
    eindGeldigheid?: SortOrderInput | SortOrder
    geconstateerd?: SortOrder
    documentDatum?: SortOrder
    documentNummer?: SortOrder
    geometry?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    naam?: SortOrder
    type?: SortOrder
    woonplaatsId?: SortOrder
    nummeraanduidingen?: NummeraanduidingOrderByRelationAggregateInput
    woonplaats?: WoonplaatsOrderByWithRelationInput
  }

  export type OpenbareRuimteWhereUniqueInput = Prisma.AtLeast<{
    identificatie?: string
    AND?: OpenbareRuimteWhereInput | OpenbareRuimteWhereInput[]
    OR?: OpenbareRuimteWhereInput[]
    NOT?: OpenbareRuimteWhereInput | OpenbareRuimteWhereInput[]
    beginGeldigheid?: DateTimeFilter<"OpenbareRuimte"> | Date | string
    eindGeldigheid?: DateTimeNullableFilter<"OpenbareRuimte"> | Date | string | null
    geconstateerd?: BoolFilter<"OpenbareRuimte"> | boolean
    documentDatum?: DateTimeFilter<"OpenbareRuimte"> | Date | string
    documentNummer?: StringFilter<"OpenbareRuimte"> | string
    geometry?: JsonNullableFilter<"OpenbareRuimte">
    status?: StringFilter<"OpenbareRuimte"> | string
    createdAt?: DateTimeFilter<"OpenbareRuimte"> | Date | string
    updatedAt?: DateTimeFilter<"OpenbareRuimte"> | Date | string
    naam?: StringFilter<"OpenbareRuimte"> | string
    type?: StringFilter<"OpenbareRuimte"> | string
    woonplaatsId?: StringFilter<"OpenbareRuimte"> | string
    nummeraanduidingen?: NummeraanduidingListRelationFilter
    woonplaats?: XOR<WoonplaatsRelationFilter, WoonplaatsWhereInput>
  }, "identificatie">

  export type OpenbareRuimteOrderByWithAggregationInput = {
    identificatie?: SortOrder
    beginGeldigheid?: SortOrder
    eindGeldigheid?: SortOrderInput | SortOrder
    geconstateerd?: SortOrder
    documentDatum?: SortOrder
    documentNummer?: SortOrder
    geometry?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    naam?: SortOrder
    type?: SortOrder
    woonplaatsId?: SortOrder
    _count?: OpenbareRuimteCountOrderByAggregateInput
    _max?: OpenbareRuimteMaxOrderByAggregateInput
    _min?: OpenbareRuimteMinOrderByAggregateInput
  }

  export type OpenbareRuimteScalarWhereWithAggregatesInput = {
    AND?: OpenbareRuimteScalarWhereWithAggregatesInput | OpenbareRuimteScalarWhereWithAggregatesInput[]
    OR?: OpenbareRuimteScalarWhereWithAggregatesInput[]
    NOT?: OpenbareRuimteScalarWhereWithAggregatesInput | OpenbareRuimteScalarWhereWithAggregatesInput[]
    identificatie?: StringWithAggregatesFilter<"OpenbareRuimte"> | string
    beginGeldigheid?: DateTimeWithAggregatesFilter<"OpenbareRuimte"> | Date | string
    eindGeldigheid?: DateTimeNullableWithAggregatesFilter<"OpenbareRuimte"> | Date | string | null
    geconstateerd?: BoolWithAggregatesFilter<"OpenbareRuimte"> | boolean
    documentDatum?: DateTimeWithAggregatesFilter<"OpenbareRuimte"> | Date | string
    documentNummer?: StringWithAggregatesFilter<"OpenbareRuimte"> | string
    geometry?: JsonNullableWithAggregatesFilter<"OpenbareRuimte">
    status?: StringWithAggregatesFilter<"OpenbareRuimte"> | string
    createdAt?: DateTimeWithAggregatesFilter<"OpenbareRuimte"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OpenbareRuimte"> | Date | string
    naam?: StringWithAggregatesFilter<"OpenbareRuimte"> | string
    type?: StringWithAggregatesFilter<"OpenbareRuimte"> | string
    woonplaatsId?: StringWithAggregatesFilter<"OpenbareRuimte"> | string
  }

  export type PandWhereInput = {
    AND?: PandWhereInput | PandWhereInput[]
    OR?: PandWhereInput[]
    NOT?: PandWhereInput | PandWhereInput[]
    identificatie?: StringFilter<"Pand"> | string
    beginGeldigheid?: DateTimeFilter<"Pand"> | Date | string
    eindGeldigheid?: DateTimeNullableFilter<"Pand"> | Date | string | null
    geconstateerd?: BoolFilter<"Pand"> | boolean
    documentDatum?: DateTimeFilter<"Pand"> | Date | string
    documentNummer?: StringFilter<"Pand"> | string
    geometry?: JsonNullableFilter<"Pand">
    status?: StringFilter<"Pand"> | string
    createdAt?: DateTimeFilter<"Pand"> | Date | string
    updatedAt?: DateTimeFilter<"Pand"> | Date | string
    oorspronkelijkBouwjaar?: IntFilter<"Pand"> | number
    verblijfsobjecten?: VerblijfsobjectListRelationFilter
  }

  export type PandOrderByWithRelationInput = {
    identificatie?: SortOrder
    beginGeldigheid?: SortOrder
    eindGeldigheid?: SortOrderInput | SortOrder
    geconstateerd?: SortOrder
    documentDatum?: SortOrder
    documentNummer?: SortOrder
    geometry?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    oorspronkelijkBouwjaar?: SortOrder
    verblijfsobjecten?: VerblijfsobjectOrderByRelationAggregateInput
  }

  export type PandWhereUniqueInput = Prisma.AtLeast<{
    identificatie?: string
    AND?: PandWhereInput | PandWhereInput[]
    OR?: PandWhereInput[]
    NOT?: PandWhereInput | PandWhereInput[]
    beginGeldigheid?: DateTimeFilter<"Pand"> | Date | string
    eindGeldigheid?: DateTimeNullableFilter<"Pand"> | Date | string | null
    geconstateerd?: BoolFilter<"Pand"> | boolean
    documentDatum?: DateTimeFilter<"Pand"> | Date | string
    documentNummer?: StringFilter<"Pand"> | string
    geometry?: JsonNullableFilter<"Pand">
    status?: StringFilter<"Pand"> | string
    createdAt?: DateTimeFilter<"Pand"> | Date | string
    updatedAt?: DateTimeFilter<"Pand"> | Date | string
    oorspronkelijkBouwjaar?: IntFilter<"Pand"> | number
    verblijfsobjecten?: VerblijfsobjectListRelationFilter
  }, "identificatie">

  export type PandOrderByWithAggregationInput = {
    identificatie?: SortOrder
    beginGeldigheid?: SortOrder
    eindGeldigheid?: SortOrderInput | SortOrder
    geconstateerd?: SortOrder
    documentDatum?: SortOrder
    documentNummer?: SortOrder
    geometry?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    oorspronkelijkBouwjaar?: SortOrder
    _count?: PandCountOrderByAggregateInput
    _avg?: PandAvgOrderByAggregateInput
    _max?: PandMaxOrderByAggregateInput
    _min?: PandMinOrderByAggregateInput
    _sum?: PandSumOrderByAggregateInput
  }

  export type PandScalarWhereWithAggregatesInput = {
    AND?: PandScalarWhereWithAggregatesInput | PandScalarWhereWithAggregatesInput[]
    OR?: PandScalarWhereWithAggregatesInput[]
    NOT?: PandScalarWhereWithAggregatesInput | PandScalarWhereWithAggregatesInput[]
    identificatie?: StringWithAggregatesFilter<"Pand"> | string
    beginGeldigheid?: DateTimeWithAggregatesFilter<"Pand"> | Date | string
    eindGeldigheid?: DateTimeNullableWithAggregatesFilter<"Pand"> | Date | string | null
    geconstateerd?: BoolWithAggregatesFilter<"Pand"> | boolean
    documentDatum?: DateTimeWithAggregatesFilter<"Pand"> | Date | string
    documentNummer?: StringWithAggregatesFilter<"Pand"> | string
    geometry?: JsonNullableWithAggregatesFilter<"Pand">
    status?: StringWithAggregatesFilter<"Pand"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Pand"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Pand"> | Date | string
    oorspronkelijkBouwjaar?: IntWithAggregatesFilter<"Pand"> | number
  }

  export type NummeraanduidingWhereInput = {
    AND?: NummeraanduidingWhereInput | NummeraanduidingWhereInput[]
    OR?: NummeraanduidingWhereInput[]
    NOT?: NummeraanduidingWhereInput | NummeraanduidingWhereInput[]
    identificatie?: StringFilter<"Nummeraanduiding"> | string
    beginGeldigheid?: DateTimeFilter<"Nummeraanduiding"> | Date | string
    eindGeldigheid?: DateTimeNullableFilter<"Nummeraanduiding"> | Date | string | null
    geconstateerd?: BoolFilter<"Nummeraanduiding"> | boolean
    documentDatum?: DateTimeFilter<"Nummeraanduiding"> | Date | string
    documentNummer?: StringFilter<"Nummeraanduiding"> | string
    geometry?: JsonNullableFilter<"Nummeraanduiding">
    status?: StringFilter<"Nummeraanduiding"> | string
    createdAt?: DateTimeFilter<"Nummeraanduiding"> | Date | string
    updatedAt?: DateTimeFilter<"Nummeraanduiding"> | Date | string
    huisnummer?: IntFilter<"Nummeraanduiding"> | number
    huisletter?: StringNullableFilter<"Nummeraanduiding"> | string | null
    huisnummertoevoeging?: StringNullableFilter<"Nummeraanduiding"> | string | null
    postcode?: StringNullableFilter<"Nummeraanduiding"> | string | null
    type?: StringFilter<"Nummeraanduiding"> | string
    openbareRuimteId?: StringFilter<"Nummeraanduiding"> | string
    openbareRuimte?: XOR<OpenbareRuimteRelationFilter, OpenbareRuimteWhereInput>
    verblijfsobject?: XOR<VerblijfsobjectNullableRelationFilter, VerblijfsobjectWhereInput> | null
    ligplaats?: XOR<LigplaatsNullableRelationFilter, LigplaatsWhereInput> | null
    standplaats?: XOR<StandplaatsNullableRelationFilter, StandplaatsWhereInput> | null
  }

  export type NummeraanduidingOrderByWithRelationInput = {
    identificatie?: SortOrder
    beginGeldigheid?: SortOrder
    eindGeldigheid?: SortOrderInput | SortOrder
    geconstateerd?: SortOrder
    documentDatum?: SortOrder
    documentNummer?: SortOrder
    geometry?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    huisnummer?: SortOrder
    huisletter?: SortOrderInput | SortOrder
    huisnummertoevoeging?: SortOrderInput | SortOrder
    postcode?: SortOrderInput | SortOrder
    type?: SortOrder
    openbareRuimteId?: SortOrder
    openbareRuimte?: OpenbareRuimteOrderByWithRelationInput
    verblijfsobject?: VerblijfsobjectOrderByWithRelationInput
    ligplaats?: LigplaatsOrderByWithRelationInput
    standplaats?: StandplaatsOrderByWithRelationInput
  }

  export type NummeraanduidingWhereUniqueInput = Prisma.AtLeast<{
    identificatie?: string
    AND?: NummeraanduidingWhereInput | NummeraanduidingWhereInput[]
    OR?: NummeraanduidingWhereInput[]
    NOT?: NummeraanduidingWhereInput | NummeraanduidingWhereInput[]
    beginGeldigheid?: DateTimeFilter<"Nummeraanduiding"> | Date | string
    eindGeldigheid?: DateTimeNullableFilter<"Nummeraanduiding"> | Date | string | null
    geconstateerd?: BoolFilter<"Nummeraanduiding"> | boolean
    documentDatum?: DateTimeFilter<"Nummeraanduiding"> | Date | string
    documentNummer?: StringFilter<"Nummeraanduiding"> | string
    geometry?: JsonNullableFilter<"Nummeraanduiding">
    status?: StringFilter<"Nummeraanduiding"> | string
    createdAt?: DateTimeFilter<"Nummeraanduiding"> | Date | string
    updatedAt?: DateTimeFilter<"Nummeraanduiding"> | Date | string
    huisnummer?: IntFilter<"Nummeraanduiding"> | number
    huisletter?: StringNullableFilter<"Nummeraanduiding"> | string | null
    huisnummertoevoeging?: StringNullableFilter<"Nummeraanduiding"> | string | null
    postcode?: StringNullableFilter<"Nummeraanduiding"> | string | null
    type?: StringFilter<"Nummeraanduiding"> | string
    openbareRuimteId?: StringFilter<"Nummeraanduiding"> | string
    openbareRuimte?: XOR<OpenbareRuimteRelationFilter, OpenbareRuimteWhereInput>
    verblijfsobject?: XOR<VerblijfsobjectNullableRelationFilter, VerblijfsobjectWhereInput> | null
    ligplaats?: XOR<LigplaatsNullableRelationFilter, LigplaatsWhereInput> | null
    standplaats?: XOR<StandplaatsNullableRelationFilter, StandplaatsWhereInput> | null
  }, "identificatie">

  export type NummeraanduidingOrderByWithAggregationInput = {
    identificatie?: SortOrder
    beginGeldigheid?: SortOrder
    eindGeldigheid?: SortOrderInput | SortOrder
    geconstateerd?: SortOrder
    documentDatum?: SortOrder
    documentNummer?: SortOrder
    geometry?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    huisnummer?: SortOrder
    huisletter?: SortOrderInput | SortOrder
    huisnummertoevoeging?: SortOrderInput | SortOrder
    postcode?: SortOrderInput | SortOrder
    type?: SortOrder
    openbareRuimteId?: SortOrder
    _count?: NummeraanduidingCountOrderByAggregateInput
    _avg?: NummeraanduidingAvgOrderByAggregateInput
    _max?: NummeraanduidingMaxOrderByAggregateInput
    _min?: NummeraanduidingMinOrderByAggregateInput
    _sum?: NummeraanduidingSumOrderByAggregateInput
  }

  export type NummeraanduidingScalarWhereWithAggregatesInput = {
    AND?: NummeraanduidingScalarWhereWithAggregatesInput | NummeraanduidingScalarWhereWithAggregatesInput[]
    OR?: NummeraanduidingScalarWhereWithAggregatesInput[]
    NOT?: NummeraanduidingScalarWhereWithAggregatesInput | NummeraanduidingScalarWhereWithAggregatesInput[]
    identificatie?: StringWithAggregatesFilter<"Nummeraanduiding"> | string
    beginGeldigheid?: DateTimeWithAggregatesFilter<"Nummeraanduiding"> | Date | string
    eindGeldigheid?: DateTimeNullableWithAggregatesFilter<"Nummeraanduiding"> | Date | string | null
    geconstateerd?: BoolWithAggregatesFilter<"Nummeraanduiding"> | boolean
    documentDatum?: DateTimeWithAggregatesFilter<"Nummeraanduiding"> | Date | string
    documentNummer?: StringWithAggregatesFilter<"Nummeraanduiding"> | string
    geometry?: JsonNullableWithAggregatesFilter<"Nummeraanduiding">
    status?: StringWithAggregatesFilter<"Nummeraanduiding"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Nummeraanduiding"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Nummeraanduiding"> | Date | string
    huisnummer?: IntWithAggregatesFilter<"Nummeraanduiding"> | number
    huisletter?: StringNullableWithAggregatesFilter<"Nummeraanduiding"> | string | null
    huisnummertoevoeging?: StringNullableWithAggregatesFilter<"Nummeraanduiding"> | string | null
    postcode?: StringNullableWithAggregatesFilter<"Nummeraanduiding"> | string | null
    type?: StringWithAggregatesFilter<"Nummeraanduiding"> | string
    openbareRuimteId?: StringWithAggregatesFilter<"Nummeraanduiding"> | string
  }

  export type VerblijfsobjectWhereInput = {
    AND?: VerblijfsobjectWhereInput | VerblijfsobjectWhereInput[]
    OR?: VerblijfsobjectWhereInput[]
    NOT?: VerblijfsobjectWhereInput | VerblijfsobjectWhereInput[]
    identificatie?: StringFilter<"Verblijfsobject"> | string
    beginGeldigheid?: DateTimeFilter<"Verblijfsobject"> | Date | string
    eindGeldigheid?: DateTimeNullableFilter<"Verblijfsobject"> | Date | string | null
    geconstateerd?: BoolFilter<"Verblijfsobject"> | boolean
    documentDatum?: DateTimeFilter<"Verblijfsobject"> | Date | string
    documentNummer?: StringFilter<"Verblijfsobject"> | string
    geometry?: JsonNullableFilter<"Verblijfsobject">
    rd_x?: FloatNullableFilter<"Verblijfsobject"> | number | null
    rd_y?: FloatNullableFilter<"Verblijfsobject"> | number | null
    longitude?: FloatNullableFilter<"Verblijfsobject"> | number | null
    latitude?: FloatNullableFilter<"Verblijfsobject"> | number | null
    status?: StringFilter<"Verblijfsobject"> | string
    createdAt?: DateTimeFilter<"Verblijfsobject"> | Date | string
    updatedAt?: DateTimeFilter<"Verblijfsobject"> | Date | string
    gebruiksdoel?: StringNullableListFilter<"Verblijfsobject">
    oppervlakte?: IntFilter<"Verblijfsobject"> | number
    nummeraanduidingId?: StringFilter<"Verblijfsobject"> | string
    pandId?: StringFilter<"Verblijfsobject"> | string
    nummeraanduiding?: XOR<NummeraanduidingRelationFilter, NummeraanduidingWhereInput>
    pand?: XOR<PandRelationFilter, PandWhereInput>
  }

  export type VerblijfsobjectOrderByWithRelationInput = {
    identificatie?: SortOrder
    beginGeldigheid?: SortOrder
    eindGeldigheid?: SortOrderInput | SortOrder
    geconstateerd?: SortOrder
    documentDatum?: SortOrder
    documentNummer?: SortOrder
    geometry?: SortOrderInput | SortOrder
    rd_x?: SortOrderInput | SortOrder
    rd_y?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    gebruiksdoel?: SortOrder
    oppervlakte?: SortOrder
    nummeraanduidingId?: SortOrder
    pandId?: SortOrder
    nummeraanduiding?: NummeraanduidingOrderByWithRelationInput
    pand?: PandOrderByWithRelationInput
  }

  export type VerblijfsobjectWhereUniqueInput = Prisma.AtLeast<{
    identificatie?: string
    nummeraanduidingId?: string
    AND?: VerblijfsobjectWhereInput | VerblijfsobjectWhereInput[]
    OR?: VerblijfsobjectWhereInput[]
    NOT?: VerblijfsobjectWhereInput | VerblijfsobjectWhereInput[]
    beginGeldigheid?: DateTimeFilter<"Verblijfsobject"> | Date | string
    eindGeldigheid?: DateTimeNullableFilter<"Verblijfsobject"> | Date | string | null
    geconstateerd?: BoolFilter<"Verblijfsobject"> | boolean
    documentDatum?: DateTimeFilter<"Verblijfsobject"> | Date | string
    documentNummer?: StringFilter<"Verblijfsobject"> | string
    geometry?: JsonNullableFilter<"Verblijfsobject">
    rd_x?: FloatNullableFilter<"Verblijfsobject"> | number | null
    rd_y?: FloatNullableFilter<"Verblijfsobject"> | number | null
    longitude?: FloatNullableFilter<"Verblijfsobject"> | number | null
    latitude?: FloatNullableFilter<"Verblijfsobject"> | number | null
    status?: StringFilter<"Verblijfsobject"> | string
    createdAt?: DateTimeFilter<"Verblijfsobject"> | Date | string
    updatedAt?: DateTimeFilter<"Verblijfsobject"> | Date | string
    gebruiksdoel?: StringNullableListFilter<"Verblijfsobject">
    oppervlakte?: IntFilter<"Verblijfsobject"> | number
    pandId?: StringFilter<"Verblijfsobject"> | string
    nummeraanduiding?: XOR<NummeraanduidingRelationFilter, NummeraanduidingWhereInput>
    pand?: XOR<PandRelationFilter, PandWhereInput>
  }, "identificatie" | "nummeraanduidingId">

  export type VerblijfsobjectOrderByWithAggregationInput = {
    identificatie?: SortOrder
    beginGeldigheid?: SortOrder
    eindGeldigheid?: SortOrderInput | SortOrder
    geconstateerd?: SortOrder
    documentDatum?: SortOrder
    documentNummer?: SortOrder
    geometry?: SortOrderInput | SortOrder
    rd_x?: SortOrderInput | SortOrder
    rd_y?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    gebruiksdoel?: SortOrder
    oppervlakte?: SortOrder
    nummeraanduidingId?: SortOrder
    pandId?: SortOrder
    _count?: VerblijfsobjectCountOrderByAggregateInput
    _avg?: VerblijfsobjectAvgOrderByAggregateInput
    _max?: VerblijfsobjectMaxOrderByAggregateInput
    _min?: VerblijfsobjectMinOrderByAggregateInput
    _sum?: VerblijfsobjectSumOrderByAggregateInput
  }

  export type VerblijfsobjectScalarWhereWithAggregatesInput = {
    AND?: VerblijfsobjectScalarWhereWithAggregatesInput | VerblijfsobjectScalarWhereWithAggregatesInput[]
    OR?: VerblijfsobjectScalarWhereWithAggregatesInput[]
    NOT?: VerblijfsobjectScalarWhereWithAggregatesInput | VerblijfsobjectScalarWhereWithAggregatesInput[]
    identificatie?: StringWithAggregatesFilter<"Verblijfsobject"> | string
    beginGeldigheid?: DateTimeWithAggregatesFilter<"Verblijfsobject"> | Date | string
    eindGeldigheid?: DateTimeNullableWithAggregatesFilter<"Verblijfsobject"> | Date | string | null
    geconstateerd?: BoolWithAggregatesFilter<"Verblijfsobject"> | boolean
    documentDatum?: DateTimeWithAggregatesFilter<"Verblijfsobject"> | Date | string
    documentNummer?: StringWithAggregatesFilter<"Verblijfsobject"> | string
    geometry?: JsonNullableWithAggregatesFilter<"Verblijfsobject">
    rd_x?: FloatNullableWithAggregatesFilter<"Verblijfsobject"> | number | null
    rd_y?: FloatNullableWithAggregatesFilter<"Verblijfsobject"> | number | null
    longitude?: FloatNullableWithAggregatesFilter<"Verblijfsobject"> | number | null
    latitude?: FloatNullableWithAggregatesFilter<"Verblijfsobject"> | number | null
    status?: StringWithAggregatesFilter<"Verblijfsobject"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Verblijfsobject"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Verblijfsobject"> | Date | string
    gebruiksdoel?: StringNullableListFilter<"Verblijfsobject">
    oppervlakte?: IntWithAggregatesFilter<"Verblijfsobject"> | number
    nummeraanduidingId?: StringWithAggregatesFilter<"Verblijfsobject"> | string
    pandId?: StringWithAggregatesFilter<"Verblijfsobject"> | string
  }

  export type spatial_ref_sysWhereInput = {
    AND?: spatial_ref_sysWhereInput | spatial_ref_sysWhereInput[]
    OR?: spatial_ref_sysWhereInput[]
    NOT?: spatial_ref_sysWhereInput | spatial_ref_sysWhereInput[]
    srid?: IntFilter<"spatial_ref_sys"> | number
    auth_name?: StringNullableFilter<"spatial_ref_sys"> | string | null
    auth_srid?: IntNullableFilter<"spatial_ref_sys"> | number | null
    srtext?: StringNullableFilter<"spatial_ref_sys"> | string | null
    proj4text?: StringNullableFilter<"spatial_ref_sys"> | string | null
  }

  export type spatial_ref_sysOrderByWithRelationInput = {
    srid?: SortOrder
    auth_name?: SortOrderInput | SortOrder
    auth_srid?: SortOrderInput | SortOrder
    srtext?: SortOrderInput | SortOrder
    proj4text?: SortOrderInput | SortOrder
  }

  export type spatial_ref_sysWhereUniqueInput = Prisma.AtLeast<{
    srid?: number
    AND?: spatial_ref_sysWhereInput | spatial_ref_sysWhereInput[]
    OR?: spatial_ref_sysWhereInput[]
    NOT?: spatial_ref_sysWhereInput | spatial_ref_sysWhereInput[]
    auth_name?: StringNullableFilter<"spatial_ref_sys"> | string | null
    auth_srid?: IntNullableFilter<"spatial_ref_sys"> | number | null
    srtext?: StringNullableFilter<"spatial_ref_sys"> | string | null
    proj4text?: StringNullableFilter<"spatial_ref_sys"> | string | null
  }, "srid">

  export type spatial_ref_sysOrderByWithAggregationInput = {
    srid?: SortOrder
    auth_name?: SortOrderInput | SortOrder
    auth_srid?: SortOrderInput | SortOrder
    srtext?: SortOrderInput | SortOrder
    proj4text?: SortOrderInput | SortOrder
    _count?: spatial_ref_sysCountOrderByAggregateInput
    _avg?: spatial_ref_sysAvgOrderByAggregateInput
    _max?: spatial_ref_sysMaxOrderByAggregateInput
    _min?: spatial_ref_sysMinOrderByAggregateInput
    _sum?: spatial_ref_sysSumOrderByAggregateInput
  }

  export type spatial_ref_sysScalarWhereWithAggregatesInput = {
    AND?: spatial_ref_sysScalarWhereWithAggregatesInput | spatial_ref_sysScalarWhereWithAggregatesInput[]
    OR?: spatial_ref_sysScalarWhereWithAggregatesInput[]
    NOT?: spatial_ref_sysScalarWhereWithAggregatesInput | spatial_ref_sysScalarWhereWithAggregatesInput[]
    srid?: IntWithAggregatesFilter<"spatial_ref_sys"> | number
    auth_name?: StringNullableWithAggregatesFilter<"spatial_ref_sys"> | string | null
    auth_srid?: IntNullableWithAggregatesFilter<"spatial_ref_sys"> | number | null
    srtext?: StringNullableWithAggregatesFilter<"spatial_ref_sys"> | string | null
    proj4text?: StringNullableWithAggregatesFilter<"spatial_ref_sys"> | string | null
  }

  export type ImportJobWhereInput = {
    AND?: ImportJobWhereInput | ImportJobWhereInput[]
    OR?: ImportJobWhereInput[]
    NOT?: ImportJobWhereInput | ImportJobWhereInput[]
    id?: StringFilter<"ImportJob"> | string
    entityType?: StringFilter<"ImportJob"> | string
    filePath?: StringFilter<"ImportJob"> | string
    status?: StringFilter<"ImportJob"> | string
    attempts?: IntFilter<"ImportJob"> | number
    error?: StringNullableFilter<"ImportJob"> | string | null
    createdAt?: DateTimeFilter<"ImportJob"> | Date | string
    startedAt?: DateTimeNullableFilter<"ImportJob"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"ImportJob"> | Date | string | null
  }

  export type ImportJobOrderByWithRelationInput = {
    id?: SortOrder
    entityType?: SortOrder
    filePath?: SortOrder
    status?: SortOrder
    attempts?: SortOrder
    error?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
  }

  export type ImportJobWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ImportJobWhereInput | ImportJobWhereInput[]
    OR?: ImportJobWhereInput[]
    NOT?: ImportJobWhereInput | ImportJobWhereInput[]
    entityType?: StringFilter<"ImportJob"> | string
    filePath?: StringFilter<"ImportJob"> | string
    status?: StringFilter<"ImportJob"> | string
    attempts?: IntFilter<"ImportJob"> | number
    error?: StringNullableFilter<"ImportJob"> | string | null
    createdAt?: DateTimeFilter<"ImportJob"> | Date | string
    startedAt?: DateTimeNullableFilter<"ImportJob"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"ImportJob"> | Date | string | null
  }, "id">

  export type ImportJobOrderByWithAggregationInput = {
    id?: SortOrder
    entityType?: SortOrder
    filePath?: SortOrder
    status?: SortOrder
    attempts?: SortOrder
    error?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    _count?: ImportJobCountOrderByAggregateInput
    _avg?: ImportJobAvgOrderByAggregateInput
    _max?: ImportJobMaxOrderByAggregateInput
    _min?: ImportJobMinOrderByAggregateInput
    _sum?: ImportJobSumOrderByAggregateInput
  }

  export type ImportJobScalarWhereWithAggregatesInput = {
    AND?: ImportJobScalarWhereWithAggregatesInput | ImportJobScalarWhereWithAggregatesInput[]
    OR?: ImportJobScalarWhereWithAggregatesInput[]
    NOT?: ImportJobScalarWhereWithAggregatesInput | ImportJobScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ImportJob"> | string
    entityType?: StringWithAggregatesFilter<"ImportJob"> | string
    filePath?: StringWithAggregatesFilter<"ImportJob"> | string
    status?: StringWithAggregatesFilter<"ImportJob"> | string
    attempts?: IntWithAggregatesFilter<"ImportJob"> | number
    error?: StringNullableWithAggregatesFilter<"ImportJob"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ImportJob"> | Date | string
    startedAt?: DateTimeNullableWithAggregatesFilter<"ImportJob"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"ImportJob"> | Date | string | null
  }

  export type NummeraanduidingStagingWhereInput = {
    AND?: NummeraanduidingStagingWhereInput | NummeraanduidingStagingWhereInput[]
    OR?: NummeraanduidingStagingWhereInput[]
    NOT?: NummeraanduidingStagingWhereInput | NummeraanduidingStagingWhereInput[]
    id?: IntFilter<"NummeraanduidingStaging"> | number
    identificatie?: StringFilter<"NummeraanduidingStaging"> | string
    huisnummer?: IntFilter<"NummeraanduidingStaging"> | number
    huisletter?: StringNullableFilter<"NummeraanduidingStaging"> | string | null
    huisnummertoevoeging?: StringNullableFilter<"NummeraanduidingStaging"> | string | null
    postcode?: StringNullableFilter<"NummeraanduidingStaging"> | string | null
    typeObject?: StringFilter<"NummeraanduidingStaging"> | string
    status?: StringFilter<"NummeraanduidingStaging"> | string
    geconstateerd?: BoolFilter<"NummeraanduidingStaging"> | boolean
    documentDatum?: DateTimeFilter<"NummeraanduidingStaging"> | Date | string
    documentNummer?: StringFilter<"NummeraanduidingStaging"> | string
    beginGeldigheid?: DateTimeFilter<"NummeraanduidingStaging"> | Date | string
    tijdstipRegistratie?: DateTimeFilter<"NummeraanduidingStaging"> | Date | string
    openbareRuimteId?: StringFilter<"NummeraanduidingStaging"> | string
    processingBatch?: StringNullableFilter<"NummeraanduidingStaging"> | string | null
    processed?: BoolFilter<"NummeraanduidingStaging"> | boolean
    error?: StringNullableFilter<"NummeraanduidingStaging"> | string | null
    createdAt?: DateTimeFilter<"NummeraanduidingStaging"> | Date | string
    updatedAt?: DateTimeFilter<"NummeraanduidingStaging"> | Date | string
  }

  export type NummeraanduidingStagingOrderByWithRelationInput = {
    id?: SortOrder
    identificatie?: SortOrder
    huisnummer?: SortOrder
    huisletter?: SortOrderInput | SortOrder
    huisnummertoevoeging?: SortOrderInput | SortOrder
    postcode?: SortOrderInput | SortOrder
    typeObject?: SortOrder
    status?: SortOrder
    geconstateerd?: SortOrder
    documentDatum?: SortOrder
    documentNummer?: SortOrder
    beginGeldigheid?: SortOrder
    tijdstipRegistratie?: SortOrder
    openbareRuimteId?: SortOrder
    processingBatch?: SortOrderInput | SortOrder
    processed?: SortOrder
    error?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NummeraanduidingStagingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    identificatie?: string
    AND?: NummeraanduidingStagingWhereInput | NummeraanduidingStagingWhereInput[]
    OR?: NummeraanduidingStagingWhereInput[]
    NOT?: NummeraanduidingStagingWhereInput | NummeraanduidingStagingWhereInput[]
    huisnummer?: IntFilter<"NummeraanduidingStaging"> | number
    huisletter?: StringNullableFilter<"NummeraanduidingStaging"> | string | null
    huisnummertoevoeging?: StringNullableFilter<"NummeraanduidingStaging"> | string | null
    postcode?: StringNullableFilter<"NummeraanduidingStaging"> | string | null
    typeObject?: StringFilter<"NummeraanduidingStaging"> | string
    status?: StringFilter<"NummeraanduidingStaging"> | string
    geconstateerd?: BoolFilter<"NummeraanduidingStaging"> | boolean
    documentDatum?: DateTimeFilter<"NummeraanduidingStaging"> | Date | string
    documentNummer?: StringFilter<"NummeraanduidingStaging"> | string
    beginGeldigheid?: DateTimeFilter<"NummeraanduidingStaging"> | Date | string
    tijdstipRegistratie?: DateTimeFilter<"NummeraanduidingStaging"> | Date | string
    openbareRuimteId?: StringFilter<"NummeraanduidingStaging"> | string
    processingBatch?: StringNullableFilter<"NummeraanduidingStaging"> | string | null
    processed?: BoolFilter<"NummeraanduidingStaging"> | boolean
    error?: StringNullableFilter<"NummeraanduidingStaging"> | string | null
    createdAt?: DateTimeFilter<"NummeraanduidingStaging"> | Date | string
    updatedAt?: DateTimeFilter<"NummeraanduidingStaging"> | Date | string
  }, "id" | "identificatie">

  export type NummeraanduidingStagingOrderByWithAggregationInput = {
    id?: SortOrder
    identificatie?: SortOrder
    huisnummer?: SortOrder
    huisletter?: SortOrderInput | SortOrder
    huisnummertoevoeging?: SortOrderInput | SortOrder
    postcode?: SortOrderInput | SortOrder
    typeObject?: SortOrder
    status?: SortOrder
    geconstateerd?: SortOrder
    documentDatum?: SortOrder
    documentNummer?: SortOrder
    beginGeldigheid?: SortOrder
    tijdstipRegistratie?: SortOrder
    openbareRuimteId?: SortOrder
    processingBatch?: SortOrderInput | SortOrder
    processed?: SortOrder
    error?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NummeraanduidingStagingCountOrderByAggregateInput
    _avg?: NummeraanduidingStagingAvgOrderByAggregateInput
    _max?: NummeraanduidingStagingMaxOrderByAggregateInput
    _min?: NummeraanduidingStagingMinOrderByAggregateInput
    _sum?: NummeraanduidingStagingSumOrderByAggregateInput
  }

  export type NummeraanduidingStagingScalarWhereWithAggregatesInput = {
    AND?: NummeraanduidingStagingScalarWhereWithAggregatesInput | NummeraanduidingStagingScalarWhereWithAggregatesInput[]
    OR?: NummeraanduidingStagingScalarWhereWithAggregatesInput[]
    NOT?: NummeraanduidingStagingScalarWhereWithAggregatesInput | NummeraanduidingStagingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"NummeraanduidingStaging"> | number
    identificatie?: StringWithAggregatesFilter<"NummeraanduidingStaging"> | string
    huisnummer?: IntWithAggregatesFilter<"NummeraanduidingStaging"> | number
    huisletter?: StringNullableWithAggregatesFilter<"NummeraanduidingStaging"> | string | null
    huisnummertoevoeging?: StringNullableWithAggregatesFilter<"NummeraanduidingStaging"> | string | null
    postcode?: StringNullableWithAggregatesFilter<"NummeraanduidingStaging"> | string | null
    typeObject?: StringWithAggregatesFilter<"NummeraanduidingStaging"> | string
    status?: StringWithAggregatesFilter<"NummeraanduidingStaging"> | string
    geconstateerd?: BoolWithAggregatesFilter<"NummeraanduidingStaging"> | boolean
    documentDatum?: DateTimeWithAggregatesFilter<"NummeraanduidingStaging"> | Date | string
    documentNummer?: StringWithAggregatesFilter<"NummeraanduidingStaging"> | string
    beginGeldigheid?: DateTimeWithAggregatesFilter<"NummeraanduidingStaging"> | Date | string
    tijdstipRegistratie?: DateTimeWithAggregatesFilter<"NummeraanduidingStaging"> | Date | string
    openbareRuimteId?: StringWithAggregatesFilter<"NummeraanduidingStaging"> | string
    processingBatch?: StringNullableWithAggregatesFilter<"NummeraanduidingStaging"> | string | null
    processed?: BoolWithAggregatesFilter<"NummeraanduidingStaging"> | boolean
    error?: StringNullableWithAggregatesFilter<"NummeraanduidingStaging"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"NummeraanduidingStaging"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"NummeraanduidingStaging"> | Date | string
  }

  export type LigplaatsWhereInput = {
    AND?: LigplaatsWhereInput | LigplaatsWhereInput[]
    OR?: LigplaatsWhereInput[]
    NOT?: LigplaatsWhereInput | LigplaatsWhereInput[]
    identificatie?: StringFilter<"Ligplaats"> | string
    beginGeldigheid?: DateTimeFilter<"Ligplaats"> | Date | string
    eindGeldigheid?: DateTimeNullableFilter<"Ligplaats"> | Date | string | null
    geconstateerd?: BoolFilter<"Ligplaats"> | boolean
    documentDatum?: DateTimeFilter<"Ligplaats"> | Date | string
    documentNummer?: StringFilter<"Ligplaats"> | string
    geometry?: JsonNullableFilter<"Ligplaats">
    status?: StringFilter<"Ligplaats"> | string
    createdAt?: DateTimeFilter<"Ligplaats"> | Date | string
    updatedAt?: DateTimeFilter<"Ligplaats"> | Date | string
    nummeraanduidingId?: StringFilter<"Ligplaats"> | string
    nummeraanduiding?: XOR<NummeraanduidingRelationFilter, NummeraanduidingWhereInput>
  }

  export type LigplaatsOrderByWithRelationInput = {
    identificatie?: SortOrder
    beginGeldigheid?: SortOrder
    eindGeldigheid?: SortOrderInput | SortOrder
    geconstateerd?: SortOrder
    documentDatum?: SortOrder
    documentNummer?: SortOrder
    geometry?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nummeraanduidingId?: SortOrder
    nummeraanduiding?: NummeraanduidingOrderByWithRelationInput
  }

  export type LigplaatsWhereUniqueInput = Prisma.AtLeast<{
    identificatie?: string
    nummeraanduidingId?: string
    AND?: LigplaatsWhereInput | LigplaatsWhereInput[]
    OR?: LigplaatsWhereInput[]
    NOT?: LigplaatsWhereInput | LigplaatsWhereInput[]
    beginGeldigheid?: DateTimeFilter<"Ligplaats"> | Date | string
    eindGeldigheid?: DateTimeNullableFilter<"Ligplaats"> | Date | string | null
    geconstateerd?: BoolFilter<"Ligplaats"> | boolean
    documentDatum?: DateTimeFilter<"Ligplaats"> | Date | string
    documentNummer?: StringFilter<"Ligplaats"> | string
    geometry?: JsonNullableFilter<"Ligplaats">
    status?: StringFilter<"Ligplaats"> | string
    createdAt?: DateTimeFilter<"Ligplaats"> | Date | string
    updatedAt?: DateTimeFilter<"Ligplaats"> | Date | string
    nummeraanduiding?: XOR<NummeraanduidingRelationFilter, NummeraanduidingWhereInput>
  }, "identificatie" | "nummeraanduidingId">

  export type LigplaatsOrderByWithAggregationInput = {
    identificatie?: SortOrder
    beginGeldigheid?: SortOrder
    eindGeldigheid?: SortOrderInput | SortOrder
    geconstateerd?: SortOrder
    documentDatum?: SortOrder
    documentNummer?: SortOrder
    geometry?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nummeraanduidingId?: SortOrder
    _count?: LigplaatsCountOrderByAggregateInput
    _max?: LigplaatsMaxOrderByAggregateInput
    _min?: LigplaatsMinOrderByAggregateInput
  }

  export type LigplaatsScalarWhereWithAggregatesInput = {
    AND?: LigplaatsScalarWhereWithAggregatesInput | LigplaatsScalarWhereWithAggregatesInput[]
    OR?: LigplaatsScalarWhereWithAggregatesInput[]
    NOT?: LigplaatsScalarWhereWithAggregatesInput | LigplaatsScalarWhereWithAggregatesInput[]
    identificatie?: StringWithAggregatesFilter<"Ligplaats"> | string
    beginGeldigheid?: DateTimeWithAggregatesFilter<"Ligplaats"> | Date | string
    eindGeldigheid?: DateTimeNullableWithAggregatesFilter<"Ligplaats"> | Date | string | null
    geconstateerd?: BoolWithAggregatesFilter<"Ligplaats"> | boolean
    documentDatum?: DateTimeWithAggregatesFilter<"Ligplaats"> | Date | string
    documentNummer?: StringWithAggregatesFilter<"Ligplaats"> | string
    geometry?: JsonNullableWithAggregatesFilter<"Ligplaats">
    status?: StringWithAggregatesFilter<"Ligplaats"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Ligplaats"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Ligplaats"> | Date | string
    nummeraanduidingId?: StringWithAggregatesFilter<"Ligplaats"> | string
  }

  export type StandplaatsWhereInput = {
    AND?: StandplaatsWhereInput | StandplaatsWhereInput[]
    OR?: StandplaatsWhereInput[]
    NOT?: StandplaatsWhereInput | StandplaatsWhereInput[]
    identificatie?: StringFilter<"Standplaats"> | string
    beginGeldigheid?: DateTimeFilter<"Standplaats"> | Date | string
    eindGeldigheid?: DateTimeNullableFilter<"Standplaats"> | Date | string | null
    geconstateerd?: BoolFilter<"Standplaats"> | boolean
    documentDatum?: DateTimeFilter<"Standplaats"> | Date | string
    documentNummer?: StringFilter<"Standplaats"> | string
    geometry?: JsonNullableFilter<"Standplaats">
    status?: StringFilter<"Standplaats"> | string
    createdAt?: DateTimeFilter<"Standplaats"> | Date | string
    updatedAt?: DateTimeFilter<"Standplaats"> | Date | string
    nummeraanduidingId?: StringFilter<"Standplaats"> | string
    nummeraanduiding?: XOR<NummeraanduidingRelationFilter, NummeraanduidingWhereInput>
  }

  export type StandplaatsOrderByWithRelationInput = {
    identificatie?: SortOrder
    beginGeldigheid?: SortOrder
    eindGeldigheid?: SortOrderInput | SortOrder
    geconstateerd?: SortOrder
    documentDatum?: SortOrder
    documentNummer?: SortOrder
    geometry?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nummeraanduidingId?: SortOrder
    nummeraanduiding?: NummeraanduidingOrderByWithRelationInput
  }

  export type StandplaatsWhereUniqueInput = Prisma.AtLeast<{
    identificatie?: string
    nummeraanduidingId?: string
    AND?: StandplaatsWhereInput | StandplaatsWhereInput[]
    OR?: StandplaatsWhereInput[]
    NOT?: StandplaatsWhereInput | StandplaatsWhereInput[]
    beginGeldigheid?: DateTimeFilter<"Standplaats"> | Date | string
    eindGeldigheid?: DateTimeNullableFilter<"Standplaats"> | Date | string | null
    geconstateerd?: BoolFilter<"Standplaats"> | boolean
    documentDatum?: DateTimeFilter<"Standplaats"> | Date | string
    documentNummer?: StringFilter<"Standplaats"> | string
    geometry?: JsonNullableFilter<"Standplaats">
    status?: StringFilter<"Standplaats"> | string
    createdAt?: DateTimeFilter<"Standplaats"> | Date | string
    updatedAt?: DateTimeFilter<"Standplaats"> | Date | string
    nummeraanduiding?: XOR<NummeraanduidingRelationFilter, NummeraanduidingWhereInput>
  }, "identificatie" | "nummeraanduidingId">

  export type StandplaatsOrderByWithAggregationInput = {
    identificatie?: SortOrder
    beginGeldigheid?: SortOrder
    eindGeldigheid?: SortOrderInput | SortOrder
    geconstateerd?: SortOrder
    documentDatum?: SortOrder
    documentNummer?: SortOrder
    geometry?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nummeraanduidingId?: SortOrder
    _count?: StandplaatsCountOrderByAggregateInput
    _max?: StandplaatsMaxOrderByAggregateInput
    _min?: StandplaatsMinOrderByAggregateInput
  }

  export type StandplaatsScalarWhereWithAggregatesInput = {
    AND?: StandplaatsScalarWhereWithAggregatesInput | StandplaatsScalarWhereWithAggregatesInput[]
    OR?: StandplaatsScalarWhereWithAggregatesInput[]
    NOT?: StandplaatsScalarWhereWithAggregatesInput | StandplaatsScalarWhereWithAggregatesInput[]
    identificatie?: StringWithAggregatesFilter<"Standplaats"> | string
    beginGeldigheid?: DateTimeWithAggregatesFilter<"Standplaats"> | Date | string
    eindGeldigheid?: DateTimeNullableWithAggregatesFilter<"Standplaats"> | Date | string | null
    geconstateerd?: BoolWithAggregatesFilter<"Standplaats"> | boolean
    documentDatum?: DateTimeWithAggregatesFilter<"Standplaats"> | Date | string
    documentNummer?: StringWithAggregatesFilter<"Standplaats"> | string
    geometry?: JsonNullableWithAggregatesFilter<"Standplaats">
    status?: StringWithAggregatesFilter<"Standplaats"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Standplaats"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Standplaats"> | Date | string
    nummeraanduidingId?: StringWithAggregatesFilter<"Standplaats"> | string
  }

  export type StatisticsCacheWhereInput = {
    AND?: StatisticsCacheWhereInput | StatisticsCacheWhereInput[]
    OR?: StatisticsCacheWhereInput[]
    NOT?: StatisticsCacheWhereInput | StatisticsCacheWhereInput[]
    id?: StringFilter<"StatisticsCache"> | string
    type?: StringFilter<"StatisticsCache"> | string
    filterHash?: StringFilter<"StatisticsCache"> | string
    data?: JsonFilter<"StatisticsCache">
    createdAt?: DateTimeFilter<"StatisticsCache"> | Date | string
    expiresAt?: DateTimeFilter<"StatisticsCache"> | Date | string
  }

  export type StatisticsCacheOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    filterHash?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type StatisticsCacheWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StatisticsCacheWhereInput | StatisticsCacheWhereInput[]
    OR?: StatisticsCacheWhereInput[]
    NOT?: StatisticsCacheWhereInput | StatisticsCacheWhereInput[]
    type?: StringFilter<"StatisticsCache"> | string
    filterHash?: StringFilter<"StatisticsCache"> | string
    data?: JsonFilter<"StatisticsCache">
    createdAt?: DateTimeFilter<"StatisticsCache"> | Date | string
    expiresAt?: DateTimeFilter<"StatisticsCache"> | Date | string
  }, "id">

  export type StatisticsCacheOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    filterHash?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    _count?: StatisticsCacheCountOrderByAggregateInput
    _max?: StatisticsCacheMaxOrderByAggregateInput
    _min?: StatisticsCacheMinOrderByAggregateInput
  }

  export type StatisticsCacheScalarWhereWithAggregatesInput = {
    AND?: StatisticsCacheScalarWhereWithAggregatesInput | StatisticsCacheScalarWhereWithAggregatesInput[]
    OR?: StatisticsCacheScalarWhereWithAggregatesInput[]
    NOT?: StatisticsCacheScalarWhereWithAggregatesInput | StatisticsCacheScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StatisticsCache"> | string
    type?: StringWithAggregatesFilter<"StatisticsCache"> | string
    filterHash?: StringWithAggregatesFilter<"StatisticsCache"> | string
    data?: JsonWithAggregatesFilter<"StatisticsCache">
    createdAt?: DateTimeWithAggregatesFilter<"StatisticsCache"> | Date | string
    expiresAt?: DateTimeWithAggregatesFilter<"StatisticsCache"> | Date | string
  }

  export type AddressCacheWhereInput = {
    AND?: AddressCacheWhereInput | AddressCacheWhereInput[]
    OR?: AddressCacheWhereInput[]
    NOT?: AddressCacheWhereInput | AddressCacheWhereInput[]
    id?: StringFilter<"AddressCache"> | string
    queryHash?: StringFilter<"AddressCache"> | string
    data?: JsonFilter<"AddressCache">
    createdAt?: DateTimeFilter<"AddressCache"> | Date | string
    expiresAt?: DateTimeFilter<"AddressCache"> | Date | string
  }

  export type AddressCacheOrderByWithRelationInput = {
    id?: SortOrder
    queryHash?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type AddressCacheWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    queryHash?: string
    AND?: AddressCacheWhereInput | AddressCacheWhereInput[]
    OR?: AddressCacheWhereInput[]
    NOT?: AddressCacheWhereInput | AddressCacheWhereInput[]
    data?: JsonFilter<"AddressCache">
    createdAt?: DateTimeFilter<"AddressCache"> | Date | string
    expiresAt?: DateTimeFilter<"AddressCache"> | Date | string
  }, "id" | "queryHash">

  export type AddressCacheOrderByWithAggregationInput = {
    id?: SortOrder
    queryHash?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    _count?: AddressCacheCountOrderByAggregateInput
    _max?: AddressCacheMaxOrderByAggregateInput
    _min?: AddressCacheMinOrderByAggregateInput
  }

  export type AddressCacheScalarWhereWithAggregatesInput = {
    AND?: AddressCacheScalarWhereWithAggregatesInput | AddressCacheScalarWhereWithAggregatesInput[]
    OR?: AddressCacheScalarWhereWithAggregatesInput[]
    NOT?: AddressCacheScalarWhereWithAggregatesInput | AddressCacheScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AddressCache"> | string
    queryHash?: StringWithAggregatesFilter<"AddressCache"> | string
    data?: JsonWithAggregatesFilter<"AddressCache">
    createdAt?: DateTimeWithAggregatesFilter<"AddressCache"> | Date | string
    expiresAt?: DateTimeWithAggregatesFilter<"AddressCache"> | Date | string
  }

  export type ExportJobWhereInput = {
    AND?: ExportJobWhereInput | ExportJobWhereInput[]
    OR?: ExportJobWhereInput[]
    NOT?: ExportJobWhereInput | ExportJobWhereInput[]
    id?: StringFilter<"ExportJob"> | string
    status?: StringFilter<"ExportJob"> | string
    format?: StringFilter<"ExportJob"> | string
    count?: IntFilter<"ExportJob"> | number
    processedCount?: IntNullableFilter<"ExportJob"> | number | null
    percentComplete?: IntNullableFilter<"ExportJob"> | number | null
    filters?: JsonFilter<"ExportJob">
    blobUrl?: StringNullableFilter<"ExportJob"> | string | null
    error?: StringNullableFilter<"ExportJob"> | string | null
    createdAt?: DateTimeFilter<"ExportJob"> | Date | string
    startedAt?: DateTimeNullableFilter<"ExportJob"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"ExportJob"> | Date | string | null
    userId?: StringNullableFilter<"ExportJob"> | string | null
  }

  export type ExportJobOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    format?: SortOrder
    count?: SortOrder
    processedCount?: SortOrderInput | SortOrder
    percentComplete?: SortOrderInput | SortOrder
    filters?: SortOrder
    blobUrl?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
  }

  export type ExportJobWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExportJobWhereInput | ExportJobWhereInput[]
    OR?: ExportJobWhereInput[]
    NOT?: ExportJobWhereInput | ExportJobWhereInput[]
    status?: StringFilter<"ExportJob"> | string
    format?: StringFilter<"ExportJob"> | string
    count?: IntFilter<"ExportJob"> | number
    processedCount?: IntNullableFilter<"ExportJob"> | number | null
    percentComplete?: IntNullableFilter<"ExportJob"> | number | null
    filters?: JsonFilter<"ExportJob">
    blobUrl?: StringNullableFilter<"ExportJob"> | string | null
    error?: StringNullableFilter<"ExportJob"> | string | null
    createdAt?: DateTimeFilter<"ExportJob"> | Date | string
    startedAt?: DateTimeNullableFilter<"ExportJob"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"ExportJob"> | Date | string | null
    userId?: StringNullableFilter<"ExportJob"> | string | null
  }, "id">

  export type ExportJobOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    format?: SortOrder
    count?: SortOrder
    processedCount?: SortOrderInput | SortOrder
    percentComplete?: SortOrderInput | SortOrder
    filters?: SortOrder
    blobUrl?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    _count?: ExportJobCountOrderByAggregateInput
    _avg?: ExportJobAvgOrderByAggregateInput
    _max?: ExportJobMaxOrderByAggregateInput
    _min?: ExportJobMinOrderByAggregateInput
    _sum?: ExportJobSumOrderByAggregateInput
  }

  export type ExportJobScalarWhereWithAggregatesInput = {
    AND?: ExportJobScalarWhereWithAggregatesInput | ExportJobScalarWhereWithAggregatesInput[]
    OR?: ExportJobScalarWhereWithAggregatesInput[]
    NOT?: ExportJobScalarWhereWithAggregatesInput | ExportJobScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExportJob"> | string
    status?: StringWithAggregatesFilter<"ExportJob"> | string
    format?: StringWithAggregatesFilter<"ExportJob"> | string
    count?: IntWithAggregatesFilter<"ExportJob"> | number
    processedCount?: IntNullableWithAggregatesFilter<"ExportJob"> | number | null
    percentComplete?: IntNullableWithAggregatesFilter<"ExportJob"> | number | null
    filters?: JsonWithAggregatesFilter<"ExportJob">
    blobUrl?: StringNullableWithAggregatesFilter<"ExportJob"> | string | null
    error?: StringNullableWithAggregatesFilter<"ExportJob"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ExportJob"> | Date | string
    startedAt?: DateTimeNullableWithAggregatesFilter<"ExportJob"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"ExportJob"> | Date | string | null
    userId?: StringNullableWithAggregatesFilter<"ExportJob"> | string | null
  }

  export type WoonplaatsCreateInput = {
    identificatie: string
    beginGeldigheid: Date | string
    eindGeldigheid?: Date | string | null
    geconstateerd?: boolean
    documentDatum: Date | string
    documentNummer: string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    naam: string
    openbareRuimtes?: OpenbareRuimteCreateNestedManyWithoutWoonplaatsInput
  }

  export type WoonplaatsUncheckedCreateInput = {
    identificatie: string
    beginGeldigheid: Date | string
    eindGeldigheid?: Date | string | null
    geconstateerd?: boolean
    documentDatum: Date | string
    documentNummer: string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    naam: string
    openbareRuimtes?: OpenbareRuimteUncheckedCreateNestedManyWithoutWoonplaatsInput
  }

  export type WoonplaatsUpdateInput = {
    identificatie?: StringFieldUpdateOperationsInput | string
    beginGeldigheid?: DateTimeFieldUpdateOperationsInput | Date | string
    eindGeldigheid?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    geconstateerd?: BoolFieldUpdateOperationsInput | boolean
    documentDatum?: DateTimeFieldUpdateOperationsInput | Date | string
    documentNummer?: StringFieldUpdateOperationsInput | string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    naam?: StringFieldUpdateOperationsInput | string
    openbareRuimtes?: OpenbareRuimteUpdateManyWithoutWoonplaatsNestedInput
  }

  export type WoonplaatsUncheckedUpdateInput = {
    identificatie?: StringFieldUpdateOperationsInput | string
    beginGeldigheid?: DateTimeFieldUpdateOperationsInput | Date | string
    eindGeldigheid?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    geconstateerd?: BoolFieldUpdateOperationsInput | boolean
    documentDatum?: DateTimeFieldUpdateOperationsInput | Date | string
    documentNummer?: StringFieldUpdateOperationsInput | string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    naam?: StringFieldUpdateOperationsInput | string
    openbareRuimtes?: OpenbareRuimteUncheckedUpdateManyWithoutWoonplaatsNestedInput
  }

  export type WoonplaatsCreateManyInput = {
    identificatie: string
    beginGeldigheid: Date | string
    eindGeldigheid?: Date | string | null
    geconstateerd?: boolean
    documentDatum: Date | string
    documentNummer: string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    naam: string
  }

  export type WoonplaatsUpdateManyMutationInput = {
    identificatie?: StringFieldUpdateOperationsInput | string
    beginGeldigheid?: DateTimeFieldUpdateOperationsInput | Date | string
    eindGeldigheid?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    geconstateerd?: BoolFieldUpdateOperationsInput | boolean
    documentDatum?: DateTimeFieldUpdateOperationsInput | Date | string
    documentNummer?: StringFieldUpdateOperationsInput | string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    naam?: StringFieldUpdateOperationsInput | string
  }

  export type WoonplaatsUncheckedUpdateManyInput = {
    identificatie?: StringFieldUpdateOperationsInput | string
    beginGeldigheid?: DateTimeFieldUpdateOperationsInput | Date | string
    eindGeldigheid?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    geconstateerd?: BoolFieldUpdateOperationsInput | boolean
    documentDatum?: DateTimeFieldUpdateOperationsInput | Date | string
    documentNummer?: StringFieldUpdateOperationsInput | string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    naam?: StringFieldUpdateOperationsInput | string
  }

  export type OpenbareRuimteCreateInput = {
    identificatie: string
    beginGeldigheid: Date | string
    eindGeldigheid?: Date | string | null
    geconstateerd?: boolean
    documentDatum: Date | string
    documentNummer: string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    naam: string
    type: string
    nummeraanduidingen?: NummeraanduidingCreateNestedManyWithoutOpenbareRuimteInput
    woonplaats: WoonplaatsCreateNestedOneWithoutOpenbareRuimtesInput
  }

  export type OpenbareRuimteUncheckedCreateInput = {
    identificatie: string
    beginGeldigheid: Date | string
    eindGeldigheid?: Date | string | null
    geconstateerd?: boolean
    documentDatum: Date | string
    documentNummer: string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    naam: string
    type: string
    woonplaatsId: string
    nummeraanduidingen?: NummeraanduidingUncheckedCreateNestedManyWithoutOpenbareRuimteInput
  }

  export type OpenbareRuimteUpdateInput = {
    identificatie?: StringFieldUpdateOperationsInput | string
    beginGeldigheid?: DateTimeFieldUpdateOperationsInput | Date | string
    eindGeldigheid?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    geconstateerd?: BoolFieldUpdateOperationsInput | boolean
    documentDatum?: DateTimeFieldUpdateOperationsInput | Date | string
    documentNummer?: StringFieldUpdateOperationsInput | string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    naam?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    nummeraanduidingen?: NummeraanduidingUpdateManyWithoutOpenbareRuimteNestedInput
    woonplaats?: WoonplaatsUpdateOneRequiredWithoutOpenbareRuimtesNestedInput
  }

  export type OpenbareRuimteUncheckedUpdateInput = {
    identificatie?: StringFieldUpdateOperationsInput | string
    beginGeldigheid?: DateTimeFieldUpdateOperationsInput | Date | string
    eindGeldigheid?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    geconstateerd?: BoolFieldUpdateOperationsInput | boolean
    documentDatum?: DateTimeFieldUpdateOperationsInput | Date | string
    documentNummer?: StringFieldUpdateOperationsInput | string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    naam?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    woonplaatsId?: StringFieldUpdateOperationsInput | string
    nummeraanduidingen?: NummeraanduidingUncheckedUpdateManyWithoutOpenbareRuimteNestedInput
  }

  export type OpenbareRuimteCreateManyInput = {
    identificatie: string
    beginGeldigheid: Date | string
    eindGeldigheid?: Date | string | null
    geconstateerd?: boolean
    documentDatum: Date | string
    documentNummer: string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    naam: string
    type: string
    woonplaatsId: string
  }

  export type OpenbareRuimteUpdateManyMutationInput = {
    identificatie?: StringFieldUpdateOperationsInput | string
    beginGeldigheid?: DateTimeFieldUpdateOperationsInput | Date | string
    eindGeldigheid?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    geconstateerd?: BoolFieldUpdateOperationsInput | boolean
    documentDatum?: DateTimeFieldUpdateOperationsInput | Date | string
    documentNummer?: StringFieldUpdateOperationsInput | string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    naam?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type OpenbareRuimteUncheckedUpdateManyInput = {
    identificatie?: StringFieldUpdateOperationsInput | string
    beginGeldigheid?: DateTimeFieldUpdateOperationsInput | Date | string
    eindGeldigheid?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    geconstateerd?: BoolFieldUpdateOperationsInput | boolean
    documentDatum?: DateTimeFieldUpdateOperationsInput | Date | string
    documentNummer?: StringFieldUpdateOperationsInput | string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    naam?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    woonplaatsId?: StringFieldUpdateOperationsInput | string
  }

  export type PandCreateInput = {
    identificatie: string
    beginGeldigheid: Date | string
    eindGeldigheid?: Date | string | null
    geconstateerd?: boolean
    documentDatum: Date | string
    documentNummer: string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    oorspronkelijkBouwjaar: number
    verblijfsobjecten?: VerblijfsobjectCreateNestedManyWithoutPandInput
  }

  export type PandUncheckedCreateInput = {
    identificatie: string
    beginGeldigheid: Date | string
    eindGeldigheid?: Date | string | null
    geconstateerd?: boolean
    documentDatum: Date | string
    documentNummer: string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    oorspronkelijkBouwjaar: number
    verblijfsobjecten?: VerblijfsobjectUncheckedCreateNestedManyWithoutPandInput
  }

  export type PandUpdateInput = {
    identificatie?: StringFieldUpdateOperationsInput | string
    beginGeldigheid?: DateTimeFieldUpdateOperationsInput | Date | string
    eindGeldigheid?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    geconstateerd?: BoolFieldUpdateOperationsInput | boolean
    documentDatum?: DateTimeFieldUpdateOperationsInput | Date | string
    documentNummer?: StringFieldUpdateOperationsInput | string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    oorspronkelijkBouwjaar?: IntFieldUpdateOperationsInput | number
    verblijfsobjecten?: VerblijfsobjectUpdateManyWithoutPandNestedInput
  }

  export type PandUncheckedUpdateInput = {
    identificatie?: StringFieldUpdateOperationsInput | string
    beginGeldigheid?: DateTimeFieldUpdateOperationsInput | Date | string
    eindGeldigheid?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    geconstateerd?: BoolFieldUpdateOperationsInput | boolean
    documentDatum?: DateTimeFieldUpdateOperationsInput | Date | string
    documentNummer?: StringFieldUpdateOperationsInput | string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    oorspronkelijkBouwjaar?: IntFieldUpdateOperationsInput | number
    verblijfsobjecten?: VerblijfsobjectUncheckedUpdateManyWithoutPandNestedInput
  }

  export type PandCreateManyInput = {
    identificatie: string
    beginGeldigheid: Date | string
    eindGeldigheid?: Date | string | null
    geconstateerd?: boolean
    documentDatum: Date | string
    documentNummer: string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    oorspronkelijkBouwjaar: number
  }

  export type PandUpdateManyMutationInput = {
    identificatie?: StringFieldUpdateOperationsInput | string
    beginGeldigheid?: DateTimeFieldUpdateOperationsInput | Date | string
    eindGeldigheid?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    geconstateerd?: BoolFieldUpdateOperationsInput | boolean
    documentDatum?: DateTimeFieldUpdateOperationsInput | Date | string
    documentNummer?: StringFieldUpdateOperationsInput | string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    oorspronkelijkBouwjaar?: IntFieldUpdateOperationsInput | number
  }

  export type PandUncheckedUpdateManyInput = {
    identificatie?: StringFieldUpdateOperationsInput | string
    beginGeldigheid?: DateTimeFieldUpdateOperationsInput | Date | string
    eindGeldigheid?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    geconstateerd?: BoolFieldUpdateOperationsInput | boolean
    documentDatum?: DateTimeFieldUpdateOperationsInput | Date | string
    documentNummer?: StringFieldUpdateOperationsInput | string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    oorspronkelijkBouwjaar?: IntFieldUpdateOperationsInput | number
  }

  export type NummeraanduidingCreateInput = {
    identificatie: string
    beginGeldigheid: Date | string
    eindGeldigheid?: Date | string | null
    geconstateerd?: boolean
    documentDatum: Date | string
    documentNummer: string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    huisnummer: number
    huisletter?: string | null
    huisnummertoevoeging?: string | null
    postcode?: string | null
    type: string
    openbareRuimte: OpenbareRuimteCreateNestedOneWithoutNummeraanduidingenInput
    verblijfsobject?: VerblijfsobjectCreateNestedOneWithoutNummeraanduidingInput
    ligplaats?: LigplaatsCreateNestedOneWithoutNummeraanduidingInput
    standplaats?: StandplaatsCreateNestedOneWithoutNummeraanduidingInput
  }

  export type NummeraanduidingUncheckedCreateInput = {
    identificatie: string
    beginGeldigheid: Date | string
    eindGeldigheid?: Date | string | null
    geconstateerd?: boolean
    documentDatum: Date | string
    documentNummer: string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    huisnummer: number
    huisletter?: string | null
    huisnummertoevoeging?: string | null
    postcode?: string | null
    type: string
    openbareRuimteId: string
    verblijfsobject?: VerblijfsobjectUncheckedCreateNestedOneWithoutNummeraanduidingInput
    ligplaats?: LigplaatsUncheckedCreateNestedOneWithoutNummeraanduidingInput
    standplaats?: StandplaatsUncheckedCreateNestedOneWithoutNummeraanduidingInput
  }

  export type NummeraanduidingUpdateInput = {
    identificatie?: StringFieldUpdateOperationsInput | string
    beginGeldigheid?: DateTimeFieldUpdateOperationsInput | Date | string
    eindGeldigheid?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    geconstateerd?: BoolFieldUpdateOperationsInput | boolean
    documentDatum?: DateTimeFieldUpdateOperationsInput | Date | string
    documentNummer?: StringFieldUpdateOperationsInput | string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    huisnummer?: IntFieldUpdateOperationsInput | number
    huisletter?: NullableStringFieldUpdateOperationsInput | string | null
    huisnummertoevoeging?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    openbareRuimte?: OpenbareRuimteUpdateOneRequiredWithoutNummeraanduidingenNestedInput
    verblijfsobject?: VerblijfsobjectUpdateOneWithoutNummeraanduidingNestedInput
    ligplaats?: LigplaatsUpdateOneWithoutNummeraanduidingNestedInput
    standplaats?: StandplaatsUpdateOneWithoutNummeraanduidingNestedInput
  }

  export type NummeraanduidingUncheckedUpdateInput = {
    identificatie?: StringFieldUpdateOperationsInput | string
    beginGeldigheid?: DateTimeFieldUpdateOperationsInput | Date | string
    eindGeldigheid?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    geconstateerd?: BoolFieldUpdateOperationsInput | boolean
    documentDatum?: DateTimeFieldUpdateOperationsInput | Date | string
    documentNummer?: StringFieldUpdateOperationsInput | string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    huisnummer?: IntFieldUpdateOperationsInput | number
    huisletter?: NullableStringFieldUpdateOperationsInput | string | null
    huisnummertoevoeging?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    openbareRuimteId?: StringFieldUpdateOperationsInput | string
    verblijfsobject?: VerblijfsobjectUncheckedUpdateOneWithoutNummeraanduidingNestedInput
    ligplaats?: LigplaatsUncheckedUpdateOneWithoutNummeraanduidingNestedInput
    standplaats?: StandplaatsUncheckedUpdateOneWithoutNummeraanduidingNestedInput
  }

  export type NummeraanduidingCreateManyInput = {
    identificatie: string
    beginGeldigheid: Date | string
    eindGeldigheid?: Date | string | null
    geconstateerd?: boolean
    documentDatum: Date | string
    documentNummer: string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    huisnummer: number
    huisletter?: string | null
    huisnummertoevoeging?: string | null
    postcode?: string | null
    type: string
    openbareRuimteId: string
  }

  export type NummeraanduidingUpdateManyMutationInput = {
    identificatie?: StringFieldUpdateOperationsInput | string
    beginGeldigheid?: DateTimeFieldUpdateOperationsInput | Date | string
    eindGeldigheid?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    geconstateerd?: BoolFieldUpdateOperationsInput | boolean
    documentDatum?: DateTimeFieldUpdateOperationsInput | Date | string
    documentNummer?: StringFieldUpdateOperationsInput | string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    huisnummer?: IntFieldUpdateOperationsInput | number
    huisletter?: NullableStringFieldUpdateOperationsInput | string | null
    huisnummertoevoeging?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
  }

  export type NummeraanduidingUncheckedUpdateManyInput = {
    identificatie?: StringFieldUpdateOperationsInput | string
    beginGeldigheid?: DateTimeFieldUpdateOperationsInput | Date | string
    eindGeldigheid?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    geconstateerd?: BoolFieldUpdateOperationsInput | boolean
    documentDatum?: DateTimeFieldUpdateOperationsInput | Date | string
    documentNummer?: StringFieldUpdateOperationsInput | string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    huisnummer?: IntFieldUpdateOperationsInput | number
    huisletter?: NullableStringFieldUpdateOperationsInput | string | null
    huisnummertoevoeging?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    openbareRuimteId?: StringFieldUpdateOperationsInput | string
  }

  export type VerblijfsobjectCreateInput = {
    identificatie: string
    beginGeldigheid: Date | string
    eindGeldigheid?: Date | string | null
    geconstateerd?: boolean
    documentDatum: Date | string
    documentNummer: string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    rd_x?: number | null
    rd_y?: number | null
    longitude?: number | null
    latitude?: number | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    gebruiksdoel?: VerblijfsobjectCreategebruiksdoelInput | string[]
    oppervlakte: number
    nummeraanduiding: NummeraanduidingCreateNestedOneWithoutVerblijfsobjectInput
    pand: PandCreateNestedOneWithoutVerblijfsobjectenInput
  }

  export type VerblijfsobjectUncheckedCreateInput = {
    identificatie: string
    beginGeldigheid: Date | string
    eindGeldigheid?: Date | string | null
    geconstateerd?: boolean
    documentDatum: Date | string
    documentNummer: string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    rd_x?: number | null
    rd_y?: number | null
    longitude?: number | null
    latitude?: number | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    gebruiksdoel?: VerblijfsobjectCreategebruiksdoelInput | string[]
    oppervlakte: number
    nummeraanduidingId: string
    pandId: string
  }

  export type VerblijfsobjectUpdateInput = {
    identificatie?: StringFieldUpdateOperationsInput | string
    beginGeldigheid?: DateTimeFieldUpdateOperationsInput | Date | string
    eindGeldigheid?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    geconstateerd?: BoolFieldUpdateOperationsInput | boolean
    documentDatum?: DateTimeFieldUpdateOperationsInput | Date | string
    documentNummer?: StringFieldUpdateOperationsInput | string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    rd_x?: NullableFloatFieldUpdateOperationsInput | number | null
    rd_y?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gebruiksdoel?: VerblijfsobjectUpdategebruiksdoelInput | string[]
    oppervlakte?: IntFieldUpdateOperationsInput | number
    nummeraanduiding?: NummeraanduidingUpdateOneRequiredWithoutVerblijfsobjectNestedInput
    pand?: PandUpdateOneRequiredWithoutVerblijfsobjectenNestedInput
  }

  export type VerblijfsobjectUncheckedUpdateInput = {
    identificatie?: StringFieldUpdateOperationsInput | string
    beginGeldigheid?: DateTimeFieldUpdateOperationsInput | Date | string
    eindGeldigheid?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    geconstateerd?: BoolFieldUpdateOperationsInput | boolean
    documentDatum?: DateTimeFieldUpdateOperationsInput | Date | string
    documentNummer?: StringFieldUpdateOperationsInput | string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    rd_x?: NullableFloatFieldUpdateOperationsInput | number | null
    rd_y?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gebruiksdoel?: VerblijfsobjectUpdategebruiksdoelInput | string[]
    oppervlakte?: IntFieldUpdateOperationsInput | number
    nummeraanduidingId?: StringFieldUpdateOperationsInput | string
    pandId?: StringFieldUpdateOperationsInput | string
  }

  export type VerblijfsobjectCreateManyInput = {
    identificatie: string
    beginGeldigheid: Date | string
    eindGeldigheid?: Date | string | null
    geconstateerd?: boolean
    documentDatum: Date | string
    documentNummer: string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    rd_x?: number | null
    rd_y?: number | null
    longitude?: number | null
    latitude?: number | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    gebruiksdoel?: VerblijfsobjectCreategebruiksdoelInput | string[]
    oppervlakte: number
    nummeraanduidingId: string
    pandId: string
  }

  export type VerblijfsobjectUpdateManyMutationInput = {
    identificatie?: StringFieldUpdateOperationsInput | string
    beginGeldigheid?: DateTimeFieldUpdateOperationsInput | Date | string
    eindGeldigheid?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    geconstateerd?: BoolFieldUpdateOperationsInput | boolean
    documentDatum?: DateTimeFieldUpdateOperationsInput | Date | string
    documentNummer?: StringFieldUpdateOperationsInput | string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    rd_x?: NullableFloatFieldUpdateOperationsInput | number | null
    rd_y?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gebruiksdoel?: VerblijfsobjectUpdategebruiksdoelInput | string[]
    oppervlakte?: IntFieldUpdateOperationsInput | number
  }

  export type VerblijfsobjectUncheckedUpdateManyInput = {
    identificatie?: StringFieldUpdateOperationsInput | string
    beginGeldigheid?: DateTimeFieldUpdateOperationsInput | Date | string
    eindGeldigheid?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    geconstateerd?: BoolFieldUpdateOperationsInput | boolean
    documentDatum?: DateTimeFieldUpdateOperationsInput | Date | string
    documentNummer?: StringFieldUpdateOperationsInput | string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    rd_x?: NullableFloatFieldUpdateOperationsInput | number | null
    rd_y?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gebruiksdoel?: VerblijfsobjectUpdategebruiksdoelInput | string[]
    oppervlakte?: IntFieldUpdateOperationsInput | number
    nummeraanduidingId?: StringFieldUpdateOperationsInput | string
    pandId?: StringFieldUpdateOperationsInput | string
  }

  export type spatial_ref_sysCreateInput = {
    srid: number
    auth_name?: string | null
    auth_srid?: number | null
    srtext?: string | null
    proj4text?: string | null
  }

  export type spatial_ref_sysUncheckedCreateInput = {
    srid: number
    auth_name?: string | null
    auth_srid?: number | null
    srtext?: string | null
    proj4text?: string | null
  }

  export type spatial_ref_sysUpdateInput = {
    srid?: IntFieldUpdateOperationsInput | number
    auth_name?: NullableStringFieldUpdateOperationsInput | string | null
    auth_srid?: NullableIntFieldUpdateOperationsInput | number | null
    srtext?: NullableStringFieldUpdateOperationsInput | string | null
    proj4text?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type spatial_ref_sysUncheckedUpdateInput = {
    srid?: IntFieldUpdateOperationsInput | number
    auth_name?: NullableStringFieldUpdateOperationsInput | string | null
    auth_srid?: NullableIntFieldUpdateOperationsInput | number | null
    srtext?: NullableStringFieldUpdateOperationsInput | string | null
    proj4text?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type spatial_ref_sysCreateManyInput = {
    srid: number
    auth_name?: string | null
    auth_srid?: number | null
    srtext?: string | null
    proj4text?: string | null
  }

  export type spatial_ref_sysUpdateManyMutationInput = {
    srid?: IntFieldUpdateOperationsInput | number
    auth_name?: NullableStringFieldUpdateOperationsInput | string | null
    auth_srid?: NullableIntFieldUpdateOperationsInput | number | null
    srtext?: NullableStringFieldUpdateOperationsInput | string | null
    proj4text?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type spatial_ref_sysUncheckedUpdateManyInput = {
    srid?: IntFieldUpdateOperationsInput | number
    auth_name?: NullableStringFieldUpdateOperationsInput | string | null
    auth_srid?: NullableIntFieldUpdateOperationsInput | number | null
    srtext?: NullableStringFieldUpdateOperationsInput | string | null
    proj4text?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ImportJobCreateInput = {
    id: string
    entityType: string
    filePath: string
    status?: string
    attempts?: number
    error?: string | null
    createdAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
  }

  export type ImportJobUncheckedCreateInput = {
    id: string
    entityType: string
    filePath: string
    status?: string
    attempts?: number
    error?: string | null
    createdAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
  }

  export type ImportJobUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ImportJobUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ImportJobCreateManyInput = {
    id: string
    entityType: string
    filePath: string
    status?: string
    attempts?: number
    error?: string | null
    createdAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
  }

  export type ImportJobUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ImportJobUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NummeraanduidingStagingCreateInput = {
    identificatie: string
    huisnummer: number
    huisletter?: string | null
    huisnummertoevoeging?: string | null
    postcode?: string | null
    typeObject: string
    status: string
    geconstateerd: boolean
    documentDatum: Date | string
    documentNummer: string
    beginGeldigheid: Date | string
    tijdstipRegistratie: Date | string
    openbareRuimteId: string
    processingBatch?: string | null
    processed?: boolean
    error?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NummeraanduidingStagingUncheckedCreateInput = {
    id?: number
    identificatie: string
    huisnummer: number
    huisletter?: string | null
    huisnummertoevoeging?: string | null
    postcode?: string | null
    typeObject: string
    status: string
    geconstateerd: boolean
    documentDatum: Date | string
    documentNummer: string
    beginGeldigheid: Date | string
    tijdstipRegistratie: Date | string
    openbareRuimteId: string
    processingBatch?: string | null
    processed?: boolean
    error?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NummeraanduidingStagingUpdateInput = {
    identificatie?: StringFieldUpdateOperationsInput | string
    huisnummer?: IntFieldUpdateOperationsInput | number
    huisletter?: NullableStringFieldUpdateOperationsInput | string | null
    huisnummertoevoeging?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    typeObject?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    geconstateerd?: BoolFieldUpdateOperationsInput | boolean
    documentDatum?: DateTimeFieldUpdateOperationsInput | Date | string
    documentNummer?: StringFieldUpdateOperationsInput | string
    beginGeldigheid?: DateTimeFieldUpdateOperationsInput | Date | string
    tijdstipRegistratie?: DateTimeFieldUpdateOperationsInput | Date | string
    openbareRuimteId?: StringFieldUpdateOperationsInput | string
    processingBatch?: NullableStringFieldUpdateOperationsInput | string | null
    processed?: BoolFieldUpdateOperationsInput | boolean
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NummeraanduidingStagingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    identificatie?: StringFieldUpdateOperationsInput | string
    huisnummer?: IntFieldUpdateOperationsInput | number
    huisletter?: NullableStringFieldUpdateOperationsInput | string | null
    huisnummertoevoeging?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    typeObject?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    geconstateerd?: BoolFieldUpdateOperationsInput | boolean
    documentDatum?: DateTimeFieldUpdateOperationsInput | Date | string
    documentNummer?: StringFieldUpdateOperationsInput | string
    beginGeldigheid?: DateTimeFieldUpdateOperationsInput | Date | string
    tijdstipRegistratie?: DateTimeFieldUpdateOperationsInput | Date | string
    openbareRuimteId?: StringFieldUpdateOperationsInput | string
    processingBatch?: NullableStringFieldUpdateOperationsInput | string | null
    processed?: BoolFieldUpdateOperationsInput | boolean
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NummeraanduidingStagingCreateManyInput = {
    id?: number
    identificatie: string
    huisnummer: number
    huisletter?: string | null
    huisnummertoevoeging?: string | null
    postcode?: string | null
    typeObject: string
    status: string
    geconstateerd: boolean
    documentDatum: Date | string
    documentNummer: string
    beginGeldigheid: Date | string
    tijdstipRegistratie: Date | string
    openbareRuimteId: string
    processingBatch?: string | null
    processed?: boolean
    error?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NummeraanduidingStagingUpdateManyMutationInput = {
    identificatie?: StringFieldUpdateOperationsInput | string
    huisnummer?: IntFieldUpdateOperationsInput | number
    huisletter?: NullableStringFieldUpdateOperationsInput | string | null
    huisnummertoevoeging?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    typeObject?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    geconstateerd?: BoolFieldUpdateOperationsInput | boolean
    documentDatum?: DateTimeFieldUpdateOperationsInput | Date | string
    documentNummer?: StringFieldUpdateOperationsInput | string
    beginGeldigheid?: DateTimeFieldUpdateOperationsInput | Date | string
    tijdstipRegistratie?: DateTimeFieldUpdateOperationsInput | Date | string
    openbareRuimteId?: StringFieldUpdateOperationsInput | string
    processingBatch?: NullableStringFieldUpdateOperationsInput | string | null
    processed?: BoolFieldUpdateOperationsInput | boolean
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NummeraanduidingStagingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    identificatie?: StringFieldUpdateOperationsInput | string
    huisnummer?: IntFieldUpdateOperationsInput | number
    huisletter?: NullableStringFieldUpdateOperationsInput | string | null
    huisnummertoevoeging?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    typeObject?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    geconstateerd?: BoolFieldUpdateOperationsInput | boolean
    documentDatum?: DateTimeFieldUpdateOperationsInput | Date | string
    documentNummer?: StringFieldUpdateOperationsInput | string
    beginGeldigheid?: DateTimeFieldUpdateOperationsInput | Date | string
    tijdstipRegistratie?: DateTimeFieldUpdateOperationsInput | Date | string
    openbareRuimteId?: StringFieldUpdateOperationsInput | string
    processingBatch?: NullableStringFieldUpdateOperationsInput | string | null
    processed?: BoolFieldUpdateOperationsInput | boolean
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LigplaatsCreateInput = {
    identificatie: string
    beginGeldigheid: Date | string
    eindGeldigheid?: Date | string | null
    geconstateerd?: boolean
    documentDatum: Date | string
    documentNummer: string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    nummeraanduiding: NummeraanduidingCreateNestedOneWithoutLigplaatsInput
  }

  export type LigplaatsUncheckedCreateInput = {
    identificatie: string
    beginGeldigheid: Date | string
    eindGeldigheid?: Date | string | null
    geconstateerd?: boolean
    documentDatum: Date | string
    documentNummer: string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    nummeraanduidingId: string
  }

  export type LigplaatsUpdateInput = {
    identificatie?: StringFieldUpdateOperationsInput | string
    beginGeldigheid?: DateTimeFieldUpdateOperationsInput | Date | string
    eindGeldigheid?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    geconstateerd?: BoolFieldUpdateOperationsInput | boolean
    documentDatum?: DateTimeFieldUpdateOperationsInput | Date | string
    documentNummer?: StringFieldUpdateOperationsInput | string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nummeraanduiding?: NummeraanduidingUpdateOneRequiredWithoutLigplaatsNestedInput
  }

  export type LigplaatsUncheckedUpdateInput = {
    identificatie?: StringFieldUpdateOperationsInput | string
    beginGeldigheid?: DateTimeFieldUpdateOperationsInput | Date | string
    eindGeldigheid?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    geconstateerd?: BoolFieldUpdateOperationsInput | boolean
    documentDatum?: DateTimeFieldUpdateOperationsInput | Date | string
    documentNummer?: StringFieldUpdateOperationsInput | string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nummeraanduidingId?: StringFieldUpdateOperationsInput | string
  }

  export type LigplaatsCreateManyInput = {
    identificatie: string
    beginGeldigheid: Date | string
    eindGeldigheid?: Date | string | null
    geconstateerd?: boolean
    documentDatum: Date | string
    documentNummer: string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    nummeraanduidingId: string
  }

  export type LigplaatsUpdateManyMutationInput = {
    identificatie?: StringFieldUpdateOperationsInput | string
    beginGeldigheid?: DateTimeFieldUpdateOperationsInput | Date | string
    eindGeldigheid?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    geconstateerd?: BoolFieldUpdateOperationsInput | boolean
    documentDatum?: DateTimeFieldUpdateOperationsInput | Date | string
    documentNummer?: StringFieldUpdateOperationsInput | string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LigplaatsUncheckedUpdateManyInput = {
    identificatie?: StringFieldUpdateOperationsInput | string
    beginGeldigheid?: DateTimeFieldUpdateOperationsInput | Date | string
    eindGeldigheid?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    geconstateerd?: BoolFieldUpdateOperationsInput | boolean
    documentDatum?: DateTimeFieldUpdateOperationsInput | Date | string
    documentNummer?: StringFieldUpdateOperationsInput | string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nummeraanduidingId?: StringFieldUpdateOperationsInput | string
  }

  export type StandplaatsCreateInput = {
    identificatie: string
    beginGeldigheid: Date | string
    eindGeldigheid?: Date | string | null
    geconstateerd?: boolean
    documentDatum: Date | string
    documentNummer: string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    nummeraanduiding: NummeraanduidingCreateNestedOneWithoutStandplaatsInput
  }

  export type StandplaatsUncheckedCreateInput = {
    identificatie: string
    beginGeldigheid: Date | string
    eindGeldigheid?: Date | string | null
    geconstateerd?: boolean
    documentDatum: Date | string
    documentNummer: string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    nummeraanduidingId: string
  }

  export type StandplaatsUpdateInput = {
    identificatie?: StringFieldUpdateOperationsInput | string
    beginGeldigheid?: DateTimeFieldUpdateOperationsInput | Date | string
    eindGeldigheid?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    geconstateerd?: BoolFieldUpdateOperationsInput | boolean
    documentDatum?: DateTimeFieldUpdateOperationsInput | Date | string
    documentNummer?: StringFieldUpdateOperationsInput | string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nummeraanduiding?: NummeraanduidingUpdateOneRequiredWithoutStandplaatsNestedInput
  }

  export type StandplaatsUncheckedUpdateInput = {
    identificatie?: StringFieldUpdateOperationsInput | string
    beginGeldigheid?: DateTimeFieldUpdateOperationsInput | Date | string
    eindGeldigheid?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    geconstateerd?: BoolFieldUpdateOperationsInput | boolean
    documentDatum?: DateTimeFieldUpdateOperationsInput | Date | string
    documentNummer?: StringFieldUpdateOperationsInput | string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nummeraanduidingId?: StringFieldUpdateOperationsInput | string
  }

  export type StandplaatsCreateManyInput = {
    identificatie: string
    beginGeldigheid: Date | string
    eindGeldigheid?: Date | string | null
    geconstateerd?: boolean
    documentDatum: Date | string
    documentNummer: string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    nummeraanduidingId: string
  }

  export type StandplaatsUpdateManyMutationInput = {
    identificatie?: StringFieldUpdateOperationsInput | string
    beginGeldigheid?: DateTimeFieldUpdateOperationsInput | Date | string
    eindGeldigheid?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    geconstateerd?: BoolFieldUpdateOperationsInput | boolean
    documentDatum?: DateTimeFieldUpdateOperationsInput | Date | string
    documentNummer?: StringFieldUpdateOperationsInput | string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StandplaatsUncheckedUpdateManyInput = {
    identificatie?: StringFieldUpdateOperationsInput | string
    beginGeldigheid?: DateTimeFieldUpdateOperationsInput | Date | string
    eindGeldigheid?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    geconstateerd?: BoolFieldUpdateOperationsInput | boolean
    documentDatum?: DateTimeFieldUpdateOperationsInput | Date | string
    documentNummer?: StringFieldUpdateOperationsInput | string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nummeraanduidingId?: StringFieldUpdateOperationsInput | string
  }

  export type StatisticsCacheCreateInput = {
    id?: string
    type: string
    filterHash: string
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type StatisticsCacheUncheckedCreateInput = {
    id?: string
    type: string
    filterHash: string
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type StatisticsCacheUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    filterHash?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StatisticsCacheUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    filterHash?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StatisticsCacheCreateManyInput = {
    id?: string
    type: string
    filterHash: string
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type StatisticsCacheUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    filterHash?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StatisticsCacheUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    filterHash?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressCacheCreateInput = {
    id?: string
    queryHash: string
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type AddressCacheUncheckedCreateInput = {
    id?: string
    queryHash: string
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type AddressCacheUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    queryHash?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressCacheUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    queryHash?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressCacheCreateManyInput = {
    id?: string
    queryHash: string
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type AddressCacheUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    queryHash?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressCacheUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    queryHash?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExportJobCreateInput = {
    id?: string
    status: string
    format: string
    count: number
    processedCount?: number | null
    percentComplete?: number | null
    filters: JsonNullValueInput | InputJsonValue
    blobUrl?: string | null
    error?: string | null
    createdAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    userId?: string | null
  }

  export type ExportJobUncheckedCreateInput = {
    id?: string
    status: string
    format: string
    count: number
    processedCount?: number | null
    percentComplete?: number | null
    filters: JsonNullValueInput | InputJsonValue
    blobUrl?: string | null
    error?: string | null
    createdAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    userId?: string | null
  }

  export type ExportJobUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    processedCount?: NullableIntFieldUpdateOperationsInput | number | null
    percentComplete?: NullableIntFieldUpdateOperationsInput | number | null
    filters?: JsonNullValueInput | InputJsonValue
    blobUrl?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExportJobUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    processedCount?: NullableIntFieldUpdateOperationsInput | number | null
    percentComplete?: NullableIntFieldUpdateOperationsInput | number | null
    filters?: JsonNullValueInput | InputJsonValue
    blobUrl?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExportJobCreateManyInput = {
    id?: string
    status: string
    format: string
    count: number
    processedCount?: number | null
    percentComplete?: number | null
    filters: JsonNullValueInput | InputJsonValue
    blobUrl?: string | null
    error?: string | null
    createdAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    userId?: string | null
  }

  export type ExportJobUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    processedCount?: NullableIntFieldUpdateOperationsInput | number | null
    percentComplete?: NullableIntFieldUpdateOperationsInput | number | null
    filters?: JsonNullValueInput | InputJsonValue
    blobUrl?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExportJobUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    processedCount?: NullableIntFieldUpdateOperationsInput | number | null
    percentComplete?: NullableIntFieldUpdateOperationsInput | number | null
    filters?: JsonNullValueInput | InputJsonValue
    blobUrl?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type OpenbareRuimteListRelationFilter = {
    every?: OpenbareRuimteWhereInput
    some?: OpenbareRuimteWhereInput
    none?: OpenbareRuimteWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type OpenbareRuimteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WoonplaatsCountOrderByAggregateInput = {
    identificatie?: SortOrder
    beginGeldigheid?: SortOrder
    eindGeldigheid?: SortOrder
    geconstateerd?: SortOrder
    documentDatum?: SortOrder
    documentNummer?: SortOrder
    geometry?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    naam?: SortOrder
  }

  export type WoonplaatsMaxOrderByAggregateInput = {
    identificatie?: SortOrder
    beginGeldigheid?: SortOrder
    eindGeldigheid?: SortOrder
    geconstateerd?: SortOrder
    documentDatum?: SortOrder
    documentNummer?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    naam?: SortOrder
  }

  export type WoonplaatsMinOrderByAggregateInput = {
    identificatie?: SortOrder
    beginGeldigheid?: SortOrder
    eindGeldigheid?: SortOrder
    geconstateerd?: SortOrder
    documentDatum?: SortOrder
    documentNummer?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    naam?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type NummeraanduidingListRelationFilter = {
    every?: NummeraanduidingWhereInput
    some?: NummeraanduidingWhereInput
    none?: NummeraanduidingWhereInput
  }

  export type WoonplaatsRelationFilter = {
    is?: WoonplaatsWhereInput
    isNot?: WoonplaatsWhereInput
  }

  export type NummeraanduidingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OpenbareRuimteCountOrderByAggregateInput = {
    identificatie?: SortOrder
    beginGeldigheid?: SortOrder
    eindGeldigheid?: SortOrder
    geconstateerd?: SortOrder
    documentDatum?: SortOrder
    documentNummer?: SortOrder
    geometry?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    naam?: SortOrder
    type?: SortOrder
    woonplaatsId?: SortOrder
  }

  export type OpenbareRuimteMaxOrderByAggregateInput = {
    identificatie?: SortOrder
    beginGeldigheid?: SortOrder
    eindGeldigheid?: SortOrder
    geconstateerd?: SortOrder
    documentDatum?: SortOrder
    documentNummer?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    naam?: SortOrder
    type?: SortOrder
    woonplaatsId?: SortOrder
  }

  export type OpenbareRuimteMinOrderByAggregateInput = {
    identificatie?: SortOrder
    beginGeldigheid?: SortOrder
    eindGeldigheid?: SortOrder
    geconstateerd?: SortOrder
    documentDatum?: SortOrder
    documentNummer?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    naam?: SortOrder
    type?: SortOrder
    woonplaatsId?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type VerblijfsobjectListRelationFilter = {
    every?: VerblijfsobjectWhereInput
    some?: VerblijfsobjectWhereInput
    none?: VerblijfsobjectWhereInput
  }

  export type VerblijfsobjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PandCountOrderByAggregateInput = {
    identificatie?: SortOrder
    beginGeldigheid?: SortOrder
    eindGeldigheid?: SortOrder
    geconstateerd?: SortOrder
    documentDatum?: SortOrder
    documentNummer?: SortOrder
    geometry?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    oorspronkelijkBouwjaar?: SortOrder
  }

  export type PandAvgOrderByAggregateInput = {
    oorspronkelijkBouwjaar?: SortOrder
  }

  export type PandMaxOrderByAggregateInput = {
    identificatie?: SortOrder
    beginGeldigheid?: SortOrder
    eindGeldigheid?: SortOrder
    geconstateerd?: SortOrder
    documentDatum?: SortOrder
    documentNummer?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    oorspronkelijkBouwjaar?: SortOrder
  }

  export type PandMinOrderByAggregateInput = {
    identificatie?: SortOrder
    beginGeldigheid?: SortOrder
    eindGeldigheid?: SortOrder
    geconstateerd?: SortOrder
    documentDatum?: SortOrder
    documentNummer?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    oorspronkelijkBouwjaar?: SortOrder
  }

  export type PandSumOrderByAggregateInput = {
    oorspronkelijkBouwjaar?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type OpenbareRuimteRelationFilter = {
    is?: OpenbareRuimteWhereInput
    isNot?: OpenbareRuimteWhereInput
  }

  export type VerblijfsobjectNullableRelationFilter = {
    is?: VerblijfsobjectWhereInput | null
    isNot?: VerblijfsobjectWhereInput | null
  }

  export type LigplaatsNullableRelationFilter = {
    is?: LigplaatsWhereInput | null
    isNot?: LigplaatsWhereInput | null
  }

  export type StandplaatsNullableRelationFilter = {
    is?: StandplaatsWhereInput | null
    isNot?: StandplaatsWhereInput | null
  }

  export type NummeraanduidingCountOrderByAggregateInput = {
    identificatie?: SortOrder
    beginGeldigheid?: SortOrder
    eindGeldigheid?: SortOrder
    geconstateerd?: SortOrder
    documentDatum?: SortOrder
    documentNummer?: SortOrder
    geometry?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    huisnummer?: SortOrder
    huisletter?: SortOrder
    huisnummertoevoeging?: SortOrder
    postcode?: SortOrder
    type?: SortOrder
    openbareRuimteId?: SortOrder
  }

  export type NummeraanduidingAvgOrderByAggregateInput = {
    huisnummer?: SortOrder
  }

  export type NummeraanduidingMaxOrderByAggregateInput = {
    identificatie?: SortOrder
    beginGeldigheid?: SortOrder
    eindGeldigheid?: SortOrder
    geconstateerd?: SortOrder
    documentDatum?: SortOrder
    documentNummer?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    huisnummer?: SortOrder
    huisletter?: SortOrder
    huisnummertoevoeging?: SortOrder
    postcode?: SortOrder
    type?: SortOrder
    openbareRuimteId?: SortOrder
  }

  export type NummeraanduidingMinOrderByAggregateInput = {
    identificatie?: SortOrder
    beginGeldigheid?: SortOrder
    eindGeldigheid?: SortOrder
    geconstateerd?: SortOrder
    documentDatum?: SortOrder
    documentNummer?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    huisnummer?: SortOrder
    huisletter?: SortOrder
    huisnummertoevoeging?: SortOrder
    postcode?: SortOrder
    type?: SortOrder
    openbareRuimteId?: SortOrder
  }

  export type NummeraanduidingSumOrderByAggregateInput = {
    huisnummer?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type NummeraanduidingRelationFilter = {
    is?: NummeraanduidingWhereInput
    isNot?: NummeraanduidingWhereInput
  }

  export type PandRelationFilter = {
    is?: PandWhereInput
    isNot?: PandWhereInput
  }

  export type VerblijfsobjectCountOrderByAggregateInput = {
    identificatie?: SortOrder
    beginGeldigheid?: SortOrder
    eindGeldigheid?: SortOrder
    geconstateerd?: SortOrder
    documentDatum?: SortOrder
    documentNummer?: SortOrder
    geometry?: SortOrder
    rd_x?: SortOrder
    rd_y?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    gebruiksdoel?: SortOrder
    oppervlakte?: SortOrder
    nummeraanduidingId?: SortOrder
    pandId?: SortOrder
  }

  export type VerblijfsobjectAvgOrderByAggregateInput = {
    rd_x?: SortOrder
    rd_y?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    oppervlakte?: SortOrder
  }

  export type VerblijfsobjectMaxOrderByAggregateInput = {
    identificatie?: SortOrder
    beginGeldigheid?: SortOrder
    eindGeldigheid?: SortOrder
    geconstateerd?: SortOrder
    documentDatum?: SortOrder
    documentNummer?: SortOrder
    rd_x?: SortOrder
    rd_y?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    oppervlakte?: SortOrder
    nummeraanduidingId?: SortOrder
    pandId?: SortOrder
  }

  export type VerblijfsobjectMinOrderByAggregateInput = {
    identificatie?: SortOrder
    beginGeldigheid?: SortOrder
    eindGeldigheid?: SortOrder
    geconstateerd?: SortOrder
    documentDatum?: SortOrder
    documentNummer?: SortOrder
    rd_x?: SortOrder
    rd_y?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    oppervlakte?: SortOrder
    nummeraanduidingId?: SortOrder
    pandId?: SortOrder
  }

  export type VerblijfsobjectSumOrderByAggregateInput = {
    rd_x?: SortOrder
    rd_y?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    oppervlakte?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type spatial_ref_sysCountOrderByAggregateInput = {
    srid?: SortOrder
    auth_name?: SortOrder
    auth_srid?: SortOrder
    srtext?: SortOrder
    proj4text?: SortOrder
  }

  export type spatial_ref_sysAvgOrderByAggregateInput = {
    srid?: SortOrder
    auth_srid?: SortOrder
  }

  export type spatial_ref_sysMaxOrderByAggregateInput = {
    srid?: SortOrder
    auth_name?: SortOrder
    auth_srid?: SortOrder
    srtext?: SortOrder
    proj4text?: SortOrder
  }

  export type spatial_ref_sysMinOrderByAggregateInput = {
    srid?: SortOrder
    auth_name?: SortOrder
    auth_srid?: SortOrder
    srtext?: SortOrder
    proj4text?: SortOrder
  }

  export type spatial_ref_sysSumOrderByAggregateInput = {
    srid?: SortOrder
    auth_srid?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type ImportJobCountOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    filePath?: SortOrder
    status?: SortOrder
    attempts?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type ImportJobAvgOrderByAggregateInput = {
    attempts?: SortOrder
  }

  export type ImportJobMaxOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    filePath?: SortOrder
    status?: SortOrder
    attempts?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type ImportJobMinOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    filePath?: SortOrder
    status?: SortOrder
    attempts?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type ImportJobSumOrderByAggregateInput = {
    attempts?: SortOrder
  }

  export type NummeraanduidingStagingCountOrderByAggregateInput = {
    id?: SortOrder
    identificatie?: SortOrder
    huisnummer?: SortOrder
    huisletter?: SortOrder
    huisnummertoevoeging?: SortOrder
    postcode?: SortOrder
    typeObject?: SortOrder
    status?: SortOrder
    geconstateerd?: SortOrder
    documentDatum?: SortOrder
    documentNummer?: SortOrder
    beginGeldigheid?: SortOrder
    tijdstipRegistratie?: SortOrder
    openbareRuimteId?: SortOrder
    processingBatch?: SortOrder
    processed?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NummeraanduidingStagingAvgOrderByAggregateInput = {
    id?: SortOrder
    huisnummer?: SortOrder
  }

  export type NummeraanduidingStagingMaxOrderByAggregateInput = {
    id?: SortOrder
    identificatie?: SortOrder
    huisnummer?: SortOrder
    huisletter?: SortOrder
    huisnummertoevoeging?: SortOrder
    postcode?: SortOrder
    typeObject?: SortOrder
    status?: SortOrder
    geconstateerd?: SortOrder
    documentDatum?: SortOrder
    documentNummer?: SortOrder
    beginGeldigheid?: SortOrder
    tijdstipRegistratie?: SortOrder
    openbareRuimteId?: SortOrder
    processingBatch?: SortOrder
    processed?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NummeraanduidingStagingMinOrderByAggregateInput = {
    id?: SortOrder
    identificatie?: SortOrder
    huisnummer?: SortOrder
    huisletter?: SortOrder
    huisnummertoevoeging?: SortOrder
    postcode?: SortOrder
    typeObject?: SortOrder
    status?: SortOrder
    geconstateerd?: SortOrder
    documentDatum?: SortOrder
    documentNummer?: SortOrder
    beginGeldigheid?: SortOrder
    tijdstipRegistratie?: SortOrder
    openbareRuimteId?: SortOrder
    processingBatch?: SortOrder
    processed?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NummeraanduidingStagingSumOrderByAggregateInput = {
    id?: SortOrder
    huisnummer?: SortOrder
  }

  export type LigplaatsCountOrderByAggregateInput = {
    identificatie?: SortOrder
    beginGeldigheid?: SortOrder
    eindGeldigheid?: SortOrder
    geconstateerd?: SortOrder
    documentDatum?: SortOrder
    documentNummer?: SortOrder
    geometry?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nummeraanduidingId?: SortOrder
  }

  export type LigplaatsMaxOrderByAggregateInput = {
    identificatie?: SortOrder
    beginGeldigheid?: SortOrder
    eindGeldigheid?: SortOrder
    geconstateerd?: SortOrder
    documentDatum?: SortOrder
    documentNummer?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nummeraanduidingId?: SortOrder
  }

  export type LigplaatsMinOrderByAggregateInput = {
    identificatie?: SortOrder
    beginGeldigheid?: SortOrder
    eindGeldigheid?: SortOrder
    geconstateerd?: SortOrder
    documentDatum?: SortOrder
    documentNummer?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nummeraanduidingId?: SortOrder
  }

  export type StandplaatsCountOrderByAggregateInput = {
    identificatie?: SortOrder
    beginGeldigheid?: SortOrder
    eindGeldigheid?: SortOrder
    geconstateerd?: SortOrder
    documentDatum?: SortOrder
    documentNummer?: SortOrder
    geometry?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nummeraanduidingId?: SortOrder
  }

  export type StandplaatsMaxOrderByAggregateInput = {
    identificatie?: SortOrder
    beginGeldigheid?: SortOrder
    eindGeldigheid?: SortOrder
    geconstateerd?: SortOrder
    documentDatum?: SortOrder
    documentNummer?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nummeraanduidingId?: SortOrder
  }

  export type StandplaatsMinOrderByAggregateInput = {
    identificatie?: SortOrder
    beginGeldigheid?: SortOrder
    eindGeldigheid?: SortOrder
    geconstateerd?: SortOrder
    documentDatum?: SortOrder
    documentNummer?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nummeraanduidingId?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type StatisticsCacheCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    filterHash?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type StatisticsCacheMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    filterHash?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type StatisticsCacheMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    filterHash?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type AddressCacheCountOrderByAggregateInput = {
    id?: SortOrder
    queryHash?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type AddressCacheMaxOrderByAggregateInput = {
    id?: SortOrder
    queryHash?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type AddressCacheMinOrderByAggregateInput = {
    id?: SortOrder
    queryHash?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type ExportJobCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    format?: SortOrder
    count?: SortOrder
    processedCount?: SortOrder
    percentComplete?: SortOrder
    filters?: SortOrder
    blobUrl?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    userId?: SortOrder
  }

  export type ExportJobAvgOrderByAggregateInput = {
    count?: SortOrder
    processedCount?: SortOrder
    percentComplete?: SortOrder
  }

  export type ExportJobMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    format?: SortOrder
    count?: SortOrder
    processedCount?: SortOrder
    percentComplete?: SortOrder
    blobUrl?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    userId?: SortOrder
  }

  export type ExportJobMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    format?: SortOrder
    count?: SortOrder
    processedCount?: SortOrder
    percentComplete?: SortOrder
    blobUrl?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    userId?: SortOrder
  }

  export type ExportJobSumOrderByAggregateInput = {
    count?: SortOrder
    processedCount?: SortOrder
    percentComplete?: SortOrder
  }

  export type OpenbareRuimteCreateNestedManyWithoutWoonplaatsInput = {
    create?: XOR<OpenbareRuimteCreateWithoutWoonplaatsInput, OpenbareRuimteUncheckedCreateWithoutWoonplaatsInput> | OpenbareRuimteCreateWithoutWoonplaatsInput[] | OpenbareRuimteUncheckedCreateWithoutWoonplaatsInput[]
    connectOrCreate?: OpenbareRuimteCreateOrConnectWithoutWoonplaatsInput | OpenbareRuimteCreateOrConnectWithoutWoonplaatsInput[]
    createMany?: OpenbareRuimteCreateManyWoonplaatsInputEnvelope
    connect?: OpenbareRuimteWhereUniqueInput | OpenbareRuimteWhereUniqueInput[]
  }

  export type OpenbareRuimteUncheckedCreateNestedManyWithoutWoonplaatsInput = {
    create?: XOR<OpenbareRuimteCreateWithoutWoonplaatsInput, OpenbareRuimteUncheckedCreateWithoutWoonplaatsInput> | OpenbareRuimteCreateWithoutWoonplaatsInput[] | OpenbareRuimteUncheckedCreateWithoutWoonplaatsInput[]
    connectOrCreate?: OpenbareRuimteCreateOrConnectWithoutWoonplaatsInput | OpenbareRuimteCreateOrConnectWithoutWoonplaatsInput[]
    createMany?: OpenbareRuimteCreateManyWoonplaatsInputEnvelope
    connect?: OpenbareRuimteWhereUniqueInput | OpenbareRuimteWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type OpenbareRuimteUpdateManyWithoutWoonplaatsNestedInput = {
    create?: XOR<OpenbareRuimteCreateWithoutWoonplaatsInput, OpenbareRuimteUncheckedCreateWithoutWoonplaatsInput> | OpenbareRuimteCreateWithoutWoonplaatsInput[] | OpenbareRuimteUncheckedCreateWithoutWoonplaatsInput[]
    connectOrCreate?: OpenbareRuimteCreateOrConnectWithoutWoonplaatsInput | OpenbareRuimteCreateOrConnectWithoutWoonplaatsInput[]
    upsert?: OpenbareRuimteUpsertWithWhereUniqueWithoutWoonplaatsInput | OpenbareRuimteUpsertWithWhereUniqueWithoutWoonplaatsInput[]
    createMany?: OpenbareRuimteCreateManyWoonplaatsInputEnvelope
    set?: OpenbareRuimteWhereUniqueInput | OpenbareRuimteWhereUniqueInput[]
    disconnect?: OpenbareRuimteWhereUniqueInput | OpenbareRuimteWhereUniqueInput[]
    delete?: OpenbareRuimteWhereUniqueInput | OpenbareRuimteWhereUniqueInput[]
    connect?: OpenbareRuimteWhereUniqueInput | OpenbareRuimteWhereUniqueInput[]
    update?: OpenbareRuimteUpdateWithWhereUniqueWithoutWoonplaatsInput | OpenbareRuimteUpdateWithWhereUniqueWithoutWoonplaatsInput[]
    updateMany?: OpenbareRuimteUpdateManyWithWhereWithoutWoonplaatsInput | OpenbareRuimteUpdateManyWithWhereWithoutWoonplaatsInput[]
    deleteMany?: OpenbareRuimteScalarWhereInput | OpenbareRuimteScalarWhereInput[]
  }

  export type OpenbareRuimteUncheckedUpdateManyWithoutWoonplaatsNestedInput = {
    create?: XOR<OpenbareRuimteCreateWithoutWoonplaatsInput, OpenbareRuimteUncheckedCreateWithoutWoonplaatsInput> | OpenbareRuimteCreateWithoutWoonplaatsInput[] | OpenbareRuimteUncheckedCreateWithoutWoonplaatsInput[]
    connectOrCreate?: OpenbareRuimteCreateOrConnectWithoutWoonplaatsInput | OpenbareRuimteCreateOrConnectWithoutWoonplaatsInput[]
    upsert?: OpenbareRuimteUpsertWithWhereUniqueWithoutWoonplaatsInput | OpenbareRuimteUpsertWithWhereUniqueWithoutWoonplaatsInput[]
    createMany?: OpenbareRuimteCreateManyWoonplaatsInputEnvelope
    set?: OpenbareRuimteWhereUniqueInput | OpenbareRuimteWhereUniqueInput[]
    disconnect?: OpenbareRuimteWhereUniqueInput | OpenbareRuimteWhereUniqueInput[]
    delete?: OpenbareRuimteWhereUniqueInput | OpenbareRuimteWhereUniqueInput[]
    connect?: OpenbareRuimteWhereUniqueInput | OpenbareRuimteWhereUniqueInput[]
    update?: OpenbareRuimteUpdateWithWhereUniqueWithoutWoonplaatsInput | OpenbareRuimteUpdateWithWhereUniqueWithoutWoonplaatsInput[]
    updateMany?: OpenbareRuimteUpdateManyWithWhereWithoutWoonplaatsInput | OpenbareRuimteUpdateManyWithWhereWithoutWoonplaatsInput[]
    deleteMany?: OpenbareRuimteScalarWhereInput | OpenbareRuimteScalarWhereInput[]
  }

  export type NummeraanduidingCreateNestedManyWithoutOpenbareRuimteInput = {
    create?: XOR<NummeraanduidingCreateWithoutOpenbareRuimteInput, NummeraanduidingUncheckedCreateWithoutOpenbareRuimteInput> | NummeraanduidingCreateWithoutOpenbareRuimteInput[] | NummeraanduidingUncheckedCreateWithoutOpenbareRuimteInput[]
    connectOrCreate?: NummeraanduidingCreateOrConnectWithoutOpenbareRuimteInput | NummeraanduidingCreateOrConnectWithoutOpenbareRuimteInput[]
    createMany?: NummeraanduidingCreateManyOpenbareRuimteInputEnvelope
    connect?: NummeraanduidingWhereUniqueInput | NummeraanduidingWhereUniqueInput[]
  }

  export type WoonplaatsCreateNestedOneWithoutOpenbareRuimtesInput = {
    create?: XOR<WoonplaatsCreateWithoutOpenbareRuimtesInput, WoonplaatsUncheckedCreateWithoutOpenbareRuimtesInput>
    connectOrCreate?: WoonplaatsCreateOrConnectWithoutOpenbareRuimtesInput
    connect?: WoonplaatsWhereUniqueInput
  }

  export type NummeraanduidingUncheckedCreateNestedManyWithoutOpenbareRuimteInput = {
    create?: XOR<NummeraanduidingCreateWithoutOpenbareRuimteInput, NummeraanduidingUncheckedCreateWithoutOpenbareRuimteInput> | NummeraanduidingCreateWithoutOpenbareRuimteInput[] | NummeraanduidingUncheckedCreateWithoutOpenbareRuimteInput[]
    connectOrCreate?: NummeraanduidingCreateOrConnectWithoutOpenbareRuimteInput | NummeraanduidingCreateOrConnectWithoutOpenbareRuimteInput[]
    createMany?: NummeraanduidingCreateManyOpenbareRuimteInputEnvelope
    connect?: NummeraanduidingWhereUniqueInput | NummeraanduidingWhereUniqueInput[]
  }

  export type NummeraanduidingUpdateManyWithoutOpenbareRuimteNestedInput = {
    create?: XOR<NummeraanduidingCreateWithoutOpenbareRuimteInput, NummeraanduidingUncheckedCreateWithoutOpenbareRuimteInput> | NummeraanduidingCreateWithoutOpenbareRuimteInput[] | NummeraanduidingUncheckedCreateWithoutOpenbareRuimteInput[]
    connectOrCreate?: NummeraanduidingCreateOrConnectWithoutOpenbareRuimteInput | NummeraanduidingCreateOrConnectWithoutOpenbareRuimteInput[]
    upsert?: NummeraanduidingUpsertWithWhereUniqueWithoutOpenbareRuimteInput | NummeraanduidingUpsertWithWhereUniqueWithoutOpenbareRuimteInput[]
    createMany?: NummeraanduidingCreateManyOpenbareRuimteInputEnvelope
    set?: NummeraanduidingWhereUniqueInput | NummeraanduidingWhereUniqueInput[]
    disconnect?: NummeraanduidingWhereUniqueInput | NummeraanduidingWhereUniqueInput[]
    delete?: NummeraanduidingWhereUniqueInput | NummeraanduidingWhereUniqueInput[]
    connect?: NummeraanduidingWhereUniqueInput | NummeraanduidingWhereUniqueInput[]
    update?: NummeraanduidingUpdateWithWhereUniqueWithoutOpenbareRuimteInput | NummeraanduidingUpdateWithWhereUniqueWithoutOpenbareRuimteInput[]
    updateMany?: NummeraanduidingUpdateManyWithWhereWithoutOpenbareRuimteInput | NummeraanduidingUpdateManyWithWhereWithoutOpenbareRuimteInput[]
    deleteMany?: NummeraanduidingScalarWhereInput | NummeraanduidingScalarWhereInput[]
  }

  export type WoonplaatsUpdateOneRequiredWithoutOpenbareRuimtesNestedInput = {
    create?: XOR<WoonplaatsCreateWithoutOpenbareRuimtesInput, WoonplaatsUncheckedCreateWithoutOpenbareRuimtesInput>
    connectOrCreate?: WoonplaatsCreateOrConnectWithoutOpenbareRuimtesInput
    upsert?: WoonplaatsUpsertWithoutOpenbareRuimtesInput
    connect?: WoonplaatsWhereUniqueInput
    update?: XOR<XOR<WoonplaatsUpdateToOneWithWhereWithoutOpenbareRuimtesInput, WoonplaatsUpdateWithoutOpenbareRuimtesInput>, WoonplaatsUncheckedUpdateWithoutOpenbareRuimtesInput>
  }

  export type NummeraanduidingUncheckedUpdateManyWithoutOpenbareRuimteNestedInput = {
    create?: XOR<NummeraanduidingCreateWithoutOpenbareRuimteInput, NummeraanduidingUncheckedCreateWithoutOpenbareRuimteInput> | NummeraanduidingCreateWithoutOpenbareRuimteInput[] | NummeraanduidingUncheckedCreateWithoutOpenbareRuimteInput[]
    connectOrCreate?: NummeraanduidingCreateOrConnectWithoutOpenbareRuimteInput | NummeraanduidingCreateOrConnectWithoutOpenbareRuimteInput[]
    upsert?: NummeraanduidingUpsertWithWhereUniqueWithoutOpenbareRuimteInput | NummeraanduidingUpsertWithWhereUniqueWithoutOpenbareRuimteInput[]
    createMany?: NummeraanduidingCreateManyOpenbareRuimteInputEnvelope
    set?: NummeraanduidingWhereUniqueInput | NummeraanduidingWhereUniqueInput[]
    disconnect?: NummeraanduidingWhereUniqueInput | NummeraanduidingWhereUniqueInput[]
    delete?: NummeraanduidingWhereUniqueInput | NummeraanduidingWhereUniqueInput[]
    connect?: NummeraanduidingWhereUniqueInput | NummeraanduidingWhereUniqueInput[]
    update?: NummeraanduidingUpdateWithWhereUniqueWithoutOpenbareRuimteInput | NummeraanduidingUpdateWithWhereUniqueWithoutOpenbareRuimteInput[]
    updateMany?: NummeraanduidingUpdateManyWithWhereWithoutOpenbareRuimteInput | NummeraanduidingUpdateManyWithWhereWithoutOpenbareRuimteInput[]
    deleteMany?: NummeraanduidingScalarWhereInput | NummeraanduidingScalarWhereInput[]
  }

  export type VerblijfsobjectCreateNestedManyWithoutPandInput = {
    create?: XOR<VerblijfsobjectCreateWithoutPandInput, VerblijfsobjectUncheckedCreateWithoutPandInput> | VerblijfsobjectCreateWithoutPandInput[] | VerblijfsobjectUncheckedCreateWithoutPandInput[]
    connectOrCreate?: VerblijfsobjectCreateOrConnectWithoutPandInput | VerblijfsobjectCreateOrConnectWithoutPandInput[]
    createMany?: VerblijfsobjectCreateManyPandInputEnvelope
    connect?: VerblijfsobjectWhereUniqueInput | VerblijfsobjectWhereUniqueInput[]
  }

  export type VerblijfsobjectUncheckedCreateNestedManyWithoutPandInput = {
    create?: XOR<VerblijfsobjectCreateWithoutPandInput, VerblijfsobjectUncheckedCreateWithoutPandInput> | VerblijfsobjectCreateWithoutPandInput[] | VerblijfsobjectUncheckedCreateWithoutPandInput[]
    connectOrCreate?: VerblijfsobjectCreateOrConnectWithoutPandInput | VerblijfsobjectCreateOrConnectWithoutPandInput[]
    createMany?: VerblijfsobjectCreateManyPandInputEnvelope
    connect?: VerblijfsobjectWhereUniqueInput | VerblijfsobjectWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type VerblijfsobjectUpdateManyWithoutPandNestedInput = {
    create?: XOR<VerblijfsobjectCreateWithoutPandInput, VerblijfsobjectUncheckedCreateWithoutPandInput> | VerblijfsobjectCreateWithoutPandInput[] | VerblijfsobjectUncheckedCreateWithoutPandInput[]
    connectOrCreate?: VerblijfsobjectCreateOrConnectWithoutPandInput | VerblijfsobjectCreateOrConnectWithoutPandInput[]
    upsert?: VerblijfsobjectUpsertWithWhereUniqueWithoutPandInput | VerblijfsobjectUpsertWithWhereUniqueWithoutPandInput[]
    createMany?: VerblijfsobjectCreateManyPandInputEnvelope
    set?: VerblijfsobjectWhereUniqueInput | VerblijfsobjectWhereUniqueInput[]
    disconnect?: VerblijfsobjectWhereUniqueInput | VerblijfsobjectWhereUniqueInput[]
    delete?: VerblijfsobjectWhereUniqueInput | VerblijfsobjectWhereUniqueInput[]
    connect?: VerblijfsobjectWhereUniqueInput | VerblijfsobjectWhereUniqueInput[]
    update?: VerblijfsobjectUpdateWithWhereUniqueWithoutPandInput | VerblijfsobjectUpdateWithWhereUniqueWithoutPandInput[]
    updateMany?: VerblijfsobjectUpdateManyWithWhereWithoutPandInput | VerblijfsobjectUpdateManyWithWhereWithoutPandInput[]
    deleteMany?: VerblijfsobjectScalarWhereInput | VerblijfsobjectScalarWhereInput[]
  }

  export type VerblijfsobjectUncheckedUpdateManyWithoutPandNestedInput = {
    create?: XOR<VerblijfsobjectCreateWithoutPandInput, VerblijfsobjectUncheckedCreateWithoutPandInput> | VerblijfsobjectCreateWithoutPandInput[] | VerblijfsobjectUncheckedCreateWithoutPandInput[]
    connectOrCreate?: VerblijfsobjectCreateOrConnectWithoutPandInput | VerblijfsobjectCreateOrConnectWithoutPandInput[]
    upsert?: VerblijfsobjectUpsertWithWhereUniqueWithoutPandInput | VerblijfsobjectUpsertWithWhereUniqueWithoutPandInput[]
    createMany?: VerblijfsobjectCreateManyPandInputEnvelope
    set?: VerblijfsobjectWhereUniqueInput | VerblijfsobjectWhereUniqueInput[]
    disconnect?: VerblijfsobjectWhereUniqueInput | VerblijfsobjectWhereUniqueInput[]
    delete?: VerblijfsobjectWhereUniqueInput | VerblijfsobjectWhereUniqueInput[]
    connect?: VerblijfsobjectWhereUniqueInput | VerblijfsobjectWhereUniqueInput[]
    update?: VerblijfsobjectUpdateWithWhereUniqueWithoutPandInput | VerblijfsobjectUpdateWithWhereUniqueWithoutPandInput[]
    updateMany?: VerblijfsobjectUpdateManyWithWhereWithoutPandInput | VerblijfsobjectUpdateManyWithWhereWithoutPandInput[]
    deleteMany?: VerblijfsobjectScalarWhereInput | VerblijfsobjectScalarWhereInput[]
  }

  export type OpenbareRuimteCreateNestedOneWithoutNummeraanduidingenInput = {
    create?: XOR<OpenbareRuimteCreateWithoutNummeraanduidingenInput, OpenbareRuimteUncheckedCreateWithoutNummeraanduidingenInput>
    connectOrCreate?: OpenbareRuimteCreateOrConnectWithoutNummeraanduidingenInput
    connect?: OpenbareRuimteWhereUniqueInput
  }

  export type VerblijfsobjectCreateNestedOneWithoutNummeraanduidingInput = {
    create?: XOR<VerblijfsobjectCreateWithoutNummeraanduidingInput, VerblijfsobjectUncheckedCreateWithoutNummeraanduidingInput>
    connectOrCreate?: VerblijfsobjectCreateOrConnectWithoutNummeraanduidingInput
    connect?: VerblijfsobjectWhereUniqueInput
  }

  export type LigplaatsCreateNestedOneWithoutNummeraanduidingInput = {
    create?: XOR<LigplaatsCreateWithoutNummeraanduidingInput, LigplaatsUncheckedCreateWithoutNummeraanduidingInput>
    connectOrCreate?: LigplaatsCreateOrConnectWithoutNummeraanduidingInput
    connect?: LigplaatsWhereUniqueInput
  }

  export type StandplaatsCreateNestedOneWithoutNummeraanduidingInput = {
    create?: XOR<StandplaatsCreateWithoutNummeraanduidingInput, StandplaatsUncheckedCreateWithoutNummeraanduidingInput>
    connectOrCreate?: StandplaatsCreateOrConnectWithoutNummeraanduidingInput
    connect?: StandplaatsWhereUniqueInput
  }

  export type VerblijfsobjectUncheckedCreateNestedOneWithoutNummeraanduidingInput = {
    create?: XOR<VerblijfsobjectCreateWithoutNummeraanduidingInput, VerblijfsobjectUncheckedCreateWithoutNummeraanduidingInput>
    connectOrCreate?: VerblijfsobjectCreateOrConnectWithoutNummeraanduidingInput
    connect?: VerblijfsobjectWhereUniqueInput
  }

  export type LigplaatsUncheckedCreateNestedOneWithoutNummeraanduidingInput = {
    create?: XOR<LigplaatsCreateWithoutNummeraanduidingInput, LigplaatsUncheckedCreateWithoutNummeraanduidingInput>
    connectOrCreate?: LigplaatsCreateOrConnectWithoutNummeraanduidingInput
    connect?: LigplaatsWhereUniqueInput
  }

  export type StandplaatsUncheckedCreateNestedOneWithoutNummeraanduidingInput = {
    create?: XOR<StandplaatsCreateWithoutNummeraanduidingInput, StandplaatsUncheckedCreateWithoutNummeraanduidingInput>
    connectOrCreate?: StandplaatsCreateOrConnectWithoutNummeraanduidingInput
    connect?: StandplaatsWhereUniqueInput
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type OpenbareRuimteUpdateOneRequiredWithoutNummeraanduidingenNestedInput = {
    create?: XOR<OpenbareRuimteCreateWithoutNummeraanduidingenInput, OpenbareRuimteUncheckedCreateWithoutNummeraanduidingenInput>
    connectOrCreate?: OpenbareRuimteCreateOrConnectWithoutNummeraanduidingenInput
    upsert?: OpenbareRuimteUpsertWithoutNummeraanduidingenInput
    connect?: OpenbareRuimteWhereUniqueInput
    update?: XOR<XOR<OpenbareRuimteUpdateToOneWithWhereWithoutNummeraanduidingenInput, OpenbareRuimteUpdateWithoutNummeraanduidingenInput>, OpenbareRuimteUncheckedUpdateWithoutNummeraanduidingenInput>
  }

  export type VerblijfsobjectUpdateOneWithoutNummeraanduidingNestedInput = {
    create?: XOR<VerblijfsobjectCreateWithoutNummeraanduidingInput, VerblijfsobjectUncheckedCreateWithoutNummeraanduidingInput>
    connectOrCreate?: VerblijfsobjectCreateOrConnectWithoutNummeraanduidingInput
    upsert?: VerblijfsobjectUpsertWithoutNummeraanduidingInput
    disconnect?: VerblijfsobjectWhereInput | boolean
    delete?: VerblijfsobjectWhereInput | boolean
    connect?: VerblijfsobjectWhereUniqueInput
    update?: XOR<XOR<VerblijfsobjectUpdateToOneWithWhereWithoutNummeraanduidingInput, VerblijfsobjectUpdateWithoutNummeraanduidingInput>, VerblijfsobjectUncheckedUpdateWithoutNummeraanduidingInput>
  }

  export type LigplaatsUpdateOneWithoutNummeraanduidingNestedInput = {
    create?: XOR<LigplaatsCreateWithoutNummeraanduidingInput, LigplaatsUncheckedCreateWithoutNummeraanduidingInput>
    connectOrCreate?: LigplaatsCreateOrConnectWithoutNummeraanduidingInput
    upsert?: LigplaatsUpsertWithoutNummeraanduidingInput
    disconnect?: LigplaatsWhereInput | boolean
    delete?: LigplaatsWhereInput | boolean
    connect?: LigplaatsWhereUniqueInput
    update?: XOR<XOR<LigplaatsUpdateToOneWithWhereWithoutNummeraanduidingInput, LigplaatsUpdateWithoutNummeraanduidingInput>, LigplaatsUncheckedUpdateWithoutNummeraanduidingInput>
  }

  export type StandplaatsUpdateOneWithoutNummeraanduidingNestedInput = {
    create?: XOR<StandplaatsCreateWithoutNummeraanduidingInput, StandplaatsUncheckedCreateWithoutNummeraanduidingInput>
    connectOrCreate?: StandplaatsCreateOrConnectWithoutNummeraanduidingInput
    upsert?: StandplaatsUpsertWithoutNummeraanduidingInput
    disconnect?: StandplaatsWhereInput | boolean
    delete?: StandplaatsWhereInput | boolean
    connect?: StandplaatsWhereUniqueInput
    update?: XOR<XOR<StandplaatsUpdateToOneWithWhereWithoutNummeraanduidingInput, StandplaatsUpdateWithoutNummeraanduidingInput>, StandplaatsUncheckedUpdateWithoutNummeraanduidingInput>
  }

  export type VerblijfsobjectUncheckedUpdateOneWithoutNummeraanduidingNestedInput = {
    create?: XOR<VerblijfsobjectCreateWithoutNummeraanduidingInput, VerblijfsobjectUncheckedCreateWithoutNummeraanduidingInput>
    connectOrCreate?: VerblijfsobjectCreateOrConnectWithoutNummeraanduidingInput
    upsert?: VerblijfsobjectUpsertWithoutNummeraanduidingInput
    disconnect?: VerblijfsobjectWhereInput | boolean
    delete?: VerblijfsobjectWhereInput | boolean
    connect?: VerblijfsobjectWhereUniqueInput
    update?: XOR<XOR<VerblijfsobjectUpdateToOneWithWhereWithoutNummeraanduidingInput, VerblijfsobjectUpdateWithoutNummeraanduidingInput>, VerblijfsobjectUncheckedUpdateWithoutNummeraanduidingInput>
  }

  export type LigplaatsUncheckedUpdateOneWithoutNummeraanduidingNestedInput = {
    create?: XOR<LigplaatsCreateWithoutNummeraanduidingInput, LigplaatsUncheckedCreateWithoutNummeraanduidingInput>
    connectOrCreate?: LigplaatsCreateOrConnectWithoutNummeraanduidingInput
    upsert?: LigplaatsUpsertWithoutNummeraanduidingInput
    disconnect?: LigplaatsWhereInput | boolean
    delete?: LigplaatsWhereInput | boolean
    connect?: LigplaatsWhereUniqueInput
    update?: XOR<XOR<LigplaatsUpdateToOneWithWhereWithoutNummeraanduidingInput, LigplaatsUpdateWithoutNummeraanduidingInput>, LigplaatsUncheckedUpdateWithoutNummeraanduidingInput>
  }

  export type StandplaatsUncheckedUpdateOneWithoutNummeraanduidingNestedInput = {
    create?: XOR<StandplaatsCreateWithoutNummeraanduidingInput, StandplaatsUncheckedCreateWithoutNummeraanduidingInput>
    connectOrCreate?: StandplaatsCreateOrConnectWithoutNummeraanduidingInput
    upsert?: StandplaatsUpsertWithoutNummeraanduidingInput
    disconnect?: StandplaatsWhereInput | boolean
    delete?: StandplaatsWhereInput | boolean
    connect?: StandplaatsWhereUniqueInput
    update?: XOR<XOR<StandplaatsUpdateToOneWithWhereWithoutNummeraanduidingInput, StandplaatsUpdateWithoutNummeraanduidingInput>, StandplaatsUncheckedUpdateWithoutNummeraanduidingInput>
  }

  export type VerblijfsobjectCreategebruiksdoelInput = {
    set: string[]
  }

  export type NummeraanduidingCreateNestedOneWithoutVerblijfsobjectInput = {
    create?: XOR<NummeraanduidingCreateWithoutVerblijfsobjectInput, NummeraanduidingUncheckedCreateWithoutVerblijfsobjectInput>
    connectOrCreate?: NummeraanduidingCreateOrConnectWithoutVerblijfsobjectInput
    connect?: NummeraanduidingWhereUniqueInput
  }

  export type PandCreateNestedOneWithoutVerblijfsobjectenInput = {
    create?: XOR<PandCreateWithoutVerblijfsobjectenInput, PandUncheckedCreateWithoutVerblijfsobjectenInput>
    connectOrCreate?: PandCreateOrConnectWithoutVerblijfsobjectenInput
    connect?: PandWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type VerblijfsobjectUpdategebruiksdoelInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NummeraanduidingUpdateOneRequiredWithoutVerblijfsobjectNestedInput = {
    create?: XOR<NummeraanduidingCreateWithoutVerblijfsobjectInput, NummeraanduidingUncheckedCreateWithoutVerblijfsobjectInput>
    connectOrCreate?: NummeraanduidingCreateOrConnectWithoutVerblijfsobjectInput
    upsert?: NummeraanduidingUpsertWithoutVerblijfsobjectInput
    connect?: NummeraanduidingWhereUniqueInput
    update?: XOR<XOR<NummeraanduidingUpdateToOneWithWhereWithoutVerblijfsobjectInput, NummeraanduidingUpdateWithoutVerblijfsobjectInput>, NummeraanduidingUncheckedUpdateWithoutVerblijfsobjectInput>
  }

  export type PandUpdateOneRequiredWithoutVerblijfsobjectenNestedInput = {
    create?: XOR<PandCreateWithoutVerblijfsobjectenInput, PandUncheckedCreateWithoutVerblijfsobjectenInput>
    connectOrCreate?: PandCreateOrConnectWithoutVerblijfsobjectenInput
    upsert?: PandUpsertWithoutVerblijfsobjectenInput
    connect?: PandWhereUniqueInput
    update?: XOR<XOR<PandUpdateToOneWithWhereWithoutVerblijfsobjectenInput, PandUpdateWithoutVerblijfsobjectenInput>, PandUncheckedUpdateWithoutVerblijfsobjectenInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NummeraanduidingCreateNestedOneWithoutLigplaatsInput = {
    create?: XOR<NummeraanduidingCreateWithoutLigplaatsInput, NummeraanduidingUncheckedCreateWithoutLigplaatsInput>
    connectOrCreate?: NummeraanduidingCreateOrConnectWithoutLigplaatsInput
    connect?: NummeraanduidingWhereUniqueInput
  }

  export type NummeraanduidingUpdateOneRequiredWithoutLigplaatsNestedInput = {
    create?: XOR<NummeraanduidingCreateWithoutLigplaatsInput, NummeraanduidingUncheckedCreateWithoutLigplaatsInput>
    connectOrCreate?: NummeraanduidingCreateOrConnectWithoutLigplaatsInput
    upsert?: NummeraanduidingUpsertWithoutLigplaatsInput
    connect?: NummeraanduidingWhereUniqueInput
    update?: XOR<XOR<NummeraanduidingUpdateToOneWithWhereWithoutLigplaatsInput, NummeraanduidingUpdateWithoutLigplaatsInput>, NummeraanduidingUncheckedUpdateWithoutLigplaatsInput>
  }

  export type NummeraanduidingCreateNestedOneWithoutStandplaatsInput = {
    create?: XOR<NummeraanduidingCreateWithoutStandplaatsInput, NummeraanduidingUncheckedCreateWithoutStandplaatsInput>
    connectOrCreate?: NummeraanduidingCreateOrConnectWithoutStandplaatsInput
    connect?: NummeraanduidingWhereUniqueInput
  }

  export type NummeraanduidingUpdateOneRequiredWithoutStandplaatsNestedInput = {
    create?: XOR<NummeraanduidingCreateWithoutStandplaatsInput, NummeraanduidingUncheckedCreateWithoutStandplaatsInput>
    connectOrCreate?: NummeraanduidingCreateOrConnectWithoutStandplaatsInput
    upsert?: NummeraanduidingUpsertWithoutStandplaatsInput
    connect?: NummeraanduidingWhereUniqueInput
    update?: XOR<XOR<NummeraanduidingUpdateToOneWithWhereWithoutStandplaatsInput, NummeraanduidingUpdateWithoutStandplaatsInput>, NummeraanduidingUncheckedUpdateWithoutStandplaatsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type OpenbareRuimteCreateWithoutWoonplaatsInput = {
    identificatie: string
    beginGeldigheid: Date | string
    eindGeldigheid?: Date | string | null
    geconstateerd?: boolean
    documentDatum: Date | string
    documentNummer: string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    naam: string
    type: string
    nummeraanduidingen?: NummeraanduidingCreateNestedManyWithoutOpenbareRuimteInput
  }

  export type OpenbareRuimteUncheckedCreateWithoutWoonplaatsInput = {
    identificatie: string
    beginGeldigheid: Date | string
    eindGeldigheid?: Date | string | null
    geconstateerd?: boolean
    documentDatum: Date | string
    documentNummer: string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    naam: string
    type: string
    nummeraanduidingen?: NummeraanduidingUncheckedCreateNestedManyWithoutOpenbareRuimteInput
  }

  export type OpenbareRuimteCreateOrConnectWithoutWoonplaatsInput = {
    where: OpenbareRuimteWhereUniqueInput
    create: XOR<OpenbareRuimteCreateWithoutWoonplaatsInput, OpenbareRuimteUncheckedCreateWithoutWoonplaatsInput>
  }

  export type OpenbareRuimteCreateManyWoonplaatsInputEnvelope = {
    data: OpenbareRuimteCreateManyWoonplaatsInput | OpenbareRuimteCreateManyWoonplaatsInput[]
    skipDuplicates?: boolean
  }

  export type OpenbareRuimteUpsertWithWhereUniqueWithoutWoonplaatsInput = {
    where: OpenbareRuimteWhereUniqueInput
    update: XOR<OpenbareRuimteUpdateWithoutWoonplaatsInput, OpenbareRuimteUncheckedUpdateWithoutWoonplaatsInput>
    create: XOR<OpenbareRuimteCreateWithoutWoonplaatsInput, OpenbareRuimteUncheckedCreateWithoutWoonplaatsInput>
  }

  export type OpenbareRuimteUpdateWithWhereUniqueWithoutWoonplaatsInput = {
    where: OpenbareRuimteWhereUniqueInput
    data: XOR<OpenbareRuimteUpdateWithoutWoonplaatsInput, OpenbareRuimteUncheckedUpdateWithoutWoonplaatsInput>
  }

  export type OpenbareRuimteUpdateManyWithWhereWithoutWoonplaatsInput = {
    where: OpenbareRuimteScalarWhereInput
    data: XOR<OpenbareRuimteUpdateManyMutationInput, OpenbareRuimteUncheckedUpdateManyWithoutWoonplaatsInput>
  }

  export type OpenbareRuimteScalarWhereInput = {
    AND?: OpenbareRuimteScalarWhereInput | OpenbareRuimteScalarWhereInput[]
    OR?: OpenbareRuimteScalarWhereInput[]
    NOT?: OpenbareRuimteScalarWhereInput | OpenbareRuimteScalarWhereInput[]
    identificatie?: StringFilter<"OpenbareRuimte"> | string
    beginGeldigheid?: DateTimeFilter<"OpenbareRuimte"> | Date | string
    eindGeldigheid?: DateTimeNullableFilter<"OpenbareRuimte"> | Date | string | null
    geconstateerd?: BoolFilter<"OpenbareRuimte"> | boolean
    documentDatum?: DateTimeFilter<"OpenbareRuimte"> | Date | string
    documentNummer?: StringFilter<"OpenbareRuimte"> | string
    geometry?: JsonNullableFilter<"OpenbareRuimte">
    status?: StringFilter<"OpenbareRuimte"> | string
    createdAt?: DateTimeFilter<"OpenbareRuimte"> | Date | string
    updatedAt?: DateTimeFilter<"OpenbareRuimte"> | Date | string
    naam?: StringFilter<"OpenbareRuimte"> | string
    type?: StringFilter<"OpenbareRuimte"> | string
    woonplaatsId?: StringFilter<"OpenbareRuimte"> | string
  }

  export type NummeraanduidingCreateWithoutOpenbareRuimteInput = {
    identificatie: string
    beginGeldigheid: Date | string
    eindGeldigheid?: Date | string | null
    geconstateerd?: boolean
    documentDatum: Date | string
    documentNummer: string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    huisnummer: number
    huisletter?: string | null
    huisnummertoevoeging?: string | null
    postcode?: string | null
    type: string
    verblijfsobject?: VerblijfsobjectCreateNestedOneWithoutNummeraanduidingInput
    ligplaats?: LigplaatsCreateNestedOneWithoutNummeraanduidingInput
    standplaats?: StandplaatsCreateNestedOneWithoutNummeraanduidingInput
  }

  export type NummeraanduidingUncheckedCreateWithoutOpenbareRuimteInput = {
    identificatie: string
    beginGeldigheid: Date | string
    eindGeldigheid?: Date | string | null
    geconstateerd?: boolean
    documentDatum: Date | string
    documentNummer: string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    huisnummer: number
    huisletter?: string | null
    huisnummertoevoeging?: string | null
    postcode?: string | null
    type: string
    verblijfsobject?: VerblijfsobjectUncheckedCreateNestedOneWithoutNummeraanduidingInput
    ligplaats?: LigplaatsUncheckedCreateNestedOneWithoutNummeraanduidingInput
    standplaats?: StandplaatsUncheckedCreateNestedOneWithoutNummeraanduidingInput
  }

  export type NummeraanduidingCreateOrConnectWithoutOpenbareRuimteInput = {
    where: NummeraanduidingWhereUniqueInput
    create: XOR<NummeraanduidingCreateWithoutOpenbareRuimteInput, NummeraanduidingUncheckedCreateWithoutOpenbareRuimteInput>
  }

  export type NummeraanduidingCreateManyOpenbareRuimteInputEnvelope = {
    data: NummeraanduidingCreateManyOpenbareRuimteInput | NummeraanduidingCreateManyOpenbareRuimteInput[]
    skipDuplicates?: boolean
  }

  export type WoonplaatsCreateWithoutOpenbareRuimtesInput = {
    identificatie: string
    beginGeldigheid: Date | string
    eindGeldigheid?: Date | string | null
    geconstateerd?: boolean
    documentDatum: Date | string
    documentNummer: string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    naam: string
  }

  export type WoonplaatsUncheckedCreateWithoutOpenbareRuimtesInput = {
    identificatie: string
    beginGeldigheid: Date | string
    eindGeldigheid?: Date | string | null
    geconstateerd?: boolean
    documentDatum: Date | string
    documentNummer: string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    naam: string
  }

  export type WoonplaatsCreateOrConnectWithoutOpenbareRuimtesInput = {
    where: WoonplaatsWhereUniqueInput
    create: XOR<WoonplaatsCreateWithoutOpenbareRuimtesInput, WoonplaatsUncheckedCreateWithoutOpenbareRuimtesInput>
  }

  export type NummeraanduidingUpsertWithWhereUniqueWithoutOpenbareRuimteInput = {
    where: NummeraanduidingWhereUniqueInput
    update: XOR<NummeraanduidingUpdateWithoutOpenbareRuimteInput, NummeraanduidingUncheckedUpdateWithoutOpenbareRuimteInput>
    create: XOR<NummeraanduidingCreateWithoutOpenbareRuimteInput, NummeraanduidingUncheckedCreateWithoutOpenbareRuimteInput>
  }

  export type NummeraanduidingUpdateWithWhereUniqueWithoutOpenbareRuimteInput = {
    where: NummeraanduidingWhereUniqueInput
    data: XOR<NummeraanduidingUpdateWithoutOpenbareRuimteInput, NummeraanduidingUncheckedUpdateWithoutOpenbareRuimteInput>
  }

  export type NummeraanduidingUpdateManyWithWhereWithoutOpenbareRuimteInput = {
    where: NummeraanduidingScalarWhereInput
    data: XOR<NummeraanduidingUpdateManyMutationInput, NummeraanduidingUncheckedUpdateManyWithoutOpenbareRuimteInput>
  }

  export type NummeraanduidingScalarWhereInput = {
    AND?: NummeraanduidingScalarWhereInput | NummeraanduidingScalarWhereInput[]
    OR?: NummeraanduidingScalarWhereInput[]
    NOT?: NummeraanduidingScalarWhereInput | NummeraanduidingScalarWhereInput[]
    identificatie?: StringFilter<"Nummeraanduiding"> | string
    beginGeldigheid?: DateTimeFilter<"Nummeraanduiding"> | Date | string
    eindGeldigheid?: DateTimeNullableFilter<"Nummeraanduiding"> | Date | string | null
    geconstateerd?: BoolFilter<"Nummeraanduiding"> | boolean
    documentDatum?: DateTimeFilter<"Nummeraanduiding"> | Date | string
    documentNummer?: StringFilter<"Nummeraanduiding"> | string
    geometry?: JsonNullableFilter<"Nummeraanduiding">
    status?: StringFilter<"Nummeraanduiding"> | string
    createdAt?: DateTimeFilter<"Nummeraanduiding"> | Date | string
    updatedAt?: DateTimeFilter<"Nummeraanduiding"> | Date | string
    huisnummer?: IntFilter<"Nummeraanduiding"> | number
    huisletter?: StringNullableFilter<"Nummeraanduiding"> | string | null
    huisnummertoevoeging?: StringNullableFilter<"Nummeraanduiding"> | string | null
    postcode?: StringNullableFilter<"Nummeraanduiding"> | string | null
    type?: StringFilter<"Nummeraanduiding"> | string
    openbareRuimteId?: StringFilter<"Nummeraanduiding"> | string
  }

  export type WoonplaatsUpsertWithoutOpenbareRuimtesInput = {
    update: XOR<WoonplaatsUpdateWithoutOpenbareRuimtesInput, WoonplaatsUncheckedUpdateWithoutOpenbareRuimtesInput>
    create: XOR<WoonplaatsCreateWithoutOpenbareRuimtesInput, WoonplaatsUncheckedCreateWithoutOpenbareRuimtesInput>
    where?: WoonplaatsWhereInput
  }

  export type WoonplaatsUpdateToOneWithWhereWithoutOpenbareRuimtesInput = {
    where?: WoonplaatsWhereInput
    data: XOR<WoonplaatsUpdateWithoutOpenbareRuimtesInput, WoonplaatsUncheckedUpdateWithoutOpenbareRuimtesInput>
  }

  export type WoonplaatsUpdateWithoutOpenbareRuimtesInput = {
    identificatie?: StringFieldUpdateOperationsInput | string
    beginGeldigheid?: DateTimeFieldUpdateOperationsInput | Date | string
    eindGeldigheid?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    geconstateerd?: BoolFieldUpdateOperationsInput | boolean
    documentDatum?: DateTimeFieldUpdateOperationsInput | Date | string
    documentNummer?: StringFieldUpdateOperationsInput | string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    naam?: StringFieldUpdateOperationsInput | string
  }

  export type WoonplaatsUncheckedUpdateWithoutOpenbareRuimtesInput = {
    identificatie?: StringFieldUpdateOperationsInput | string
    beginGeldigheid?: DateTimeFieldUpdateOperationsInput | Date | string
    eindGeldigheid?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    geconstateerd?: BoolFieldUpdateOperationsInput | boolean
    documentDatum?: DateTimeFieldUpdateOperationsInput | Date | string
    documentNummer?: StringFieldUpdateOperationsInput | string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    naam?: StringFieldUpdateOperationsInput | string
  }

  export type VerblijfsobjectCreateWithoutPandInput = {
    identificatie: string
    beginGeldigheid: Date | string
    eindGeldigheid?: Date | string | null
    geconstateerd?: boolean
    documentDatum: Date | string
    documentNummer: string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    rd_x?: number | null
    rd_y?: number | null
    longitude?: number | null
    latitude?: number | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    gebruiksdoel?: VerblijfsobjectCreategebruiksdoelInput | string[]
    oppervlakte: number
    nummeraanduiding: NummeraanduidingCreateNestedOneWithoutVerblijfsobjectInput
  }

  export type VerblijfsobjectUncheckedCreateWithoutPandInput = {
    identificatie: string
    beginGeldigheid: Date | string
    eindGeldigheid?: Date | string | null
    geconstateerd?: boolean
    documentDatum: Date | string
    documentNummer: string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    rd_x?: number | null
    rd_y?: number | null
    longitude?: number | null
    latitude?: number | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    gebruiksdoel?: VerblijfsobjectCreategebruiksdoelInput | string[]
    oppervlakte: number
    nummeraanduidingId: string
  }

  export type VerblijfsobjectCreateOrConnectWithoutPandInput = {
    where: VerblijfsobjectWhereUniqueInput
    create: XOR<VerblijfsobjectCreateWithoutPandInput, VerblijfsobjectUncheckedCreateWithoutPandInput>
  }

  export type VerblijfsobjectCreateManyPandInputEnvelope = {
    data: VerblijfsobjectCreateManyPandInput | VerblijfsobjectCreateManyPandInput[]
    skipDuplicates?: boolean
  }

  export type VerblijfsobjectUpsertWithWhereUniqueWithoutPandInput = {
    where: VerblijfsobjectWhereUniqueInput
    update: XOR<VerblijfsobjectUpdateWithoutPandInput, VerblijfsobjectUncheckedUpdateWithoutPandInput>
    create: XOR<VerblijfsobjectCreateWithoutPandInput, VerblijfsobjectUncheckedCreateWithoutPandInput>
  }

  export type VerblijfsobjectUpdateWithWhereUniqueWithoutPandInput = {
    where: VerblijfsobjectWhereUniqueInput
    data: XOR<VerblijfsobjectUpdateWithoutPandInput, VerblijfsobjectUncheckedUpdateWithoutPandInput>
  }

  export type VerblijfsobjectUpdateManyWithWhereWithoutPandInput = {
    where: VerblijfsobjectScalarWhereInput
    data: XOR<VerblijfsobjectUpdateManyMutationInput, VerblijfsobjectUncheckedUpdateManyWithoutPandInput>
  }

  export type VerblijfsobjectScalarWhereInput = {
    AND?: VerblijfsobjectScalarWhereInput | VerblijfsobjectScalarWhereInput[]
    OR?: VerblijfsobjectScalarWhereInput[]
    NOT?: VerblijfsobjectScalarWhereInput | VerblijfsobjectScalarWhereInput[]
    identificatie?: StringFilter<"Verblijfsobject"> | string
    beginGeldigheid?: DateTimeFilter<"Verblijfsobject"> | Date | string
    eindGeldigheid?: DateTimeNullableFilter<"Verblijfsobject"> | Date | string | null
    geconstateerd?: BoolFilter<"Verblijfsobject"> | boolean
    documentDatum?: DateTimeFilter<"Verblijfsobject"> | Date | string
    documentNummer?: StringFilter<"Verblijfsobject"> | string
    geometry?: JsonNullableFilter<"Verblijfsobject">
    rd_x?: FloatNullableFilter<"Verblijfsobject"> | number | null
    rd_y?: FloatNullableFilter<"Verblijfsobject"> | number | null
    longitude?: FloatNullableFilter<"Verblijfsobject"> | number | null
    latitude?: FloatNullableFilter<"Verblijfsobject"> | number | null
    status?: StringFilter<"Verblijfsobject"> | string
    createdAt?: DateTimeFilter<"Verblijfsobject"> | Date | string
    updatedAt?: DateTimeFilter<"Verblijfsobject"> | Date | string
    gebruiksdoel?: StringNullableListFilter<"Verblijfsobject">
    oppervlakte?: IntFilter<"Verblijfsobject"> | number
    nummeraanduidingId?: StringFilter<"Verblijfsobject"> | string
    pandId?: StringFilter<"Verblijfsobject"> | string
  }

  export type OpenbareRuimteCreateWithoutNummeraanduidingenInput = {
    identificatie: string
    beginGeldigheid: Date | string
    eindGeldigheid?: Date | string | null
    geconstateerd?: boolean
    documentDatum: Date | string
    documentNummer: string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    naam: string
    type: string
    woonplaats: WoonplaatsCreateNestedOneWithoutOpenbareRuimtesInput
  }

  export type OpenbareRuimteUncheckedCreateWithoutNummeraanduidingenInput = {
    identificatie: string
    beginGeldigheid: Date | string
    eindGeldigheid?: Date | string | null
    geconstateerd?: boolean
    documentDatum: Date | string
    documentNummer: string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    naam: string
    type: string
    woonplaatsId: string
  }

  export type OpenbareRuimteCreateOrConnectWithoutNummeraanduidingenInput = {
    where: OpenbareRuimteWhereUniqueInput
    create: XOR<OpenbareRuimteCreateWithoutNummeraanduidingenInput, OpenbareRuimteUncheckedCreateWithoutNummeraanduidingenInput>
  }

  export type VerblijfsobjectCreateWithoutNummeraanduidingInput = {
    identificatie: string
    beginGeldigheid: Date | string
    eindGeldigheid?: Date | string | null
    geconstateerd?: boolean
    documentDatum: Date | string
    documentNummer: string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    rd_x?: number | null
    rd_y?: number | null
    longitude?: number | null
    latitude?: number | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    gebruiksdoel?: VerblijfsobjectCreategebruiksdoelInput | string[]
    oppervlakte: number
    pand: PandCreateNestedOneWithoutVerblijfsobjectenInput
  }

  export type VerblijfsobjectUncheckedCreateWithoutNummeraanduidingInput = {
    identificatie: string
    beginGeldigheid: Date | string
    eindGeldigheid?: Date | string | null
    geconstateerd?: boolean
    documentDatum: Date | string
    documentNummer: string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    rd_x?: number | null
    rd_y?: number | null
    longitude?: number | null
    latitude?: number | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    gebruiksdoel?: VerblijfsobjectCreategebruiksdoelInput | string[]
    oppervlakte: number
    pandId: string
  }

  export type VerblijfsobjectCreateOrConnectWithoutNummeraanduidingInput = {
    where: VerblijfsobjectWhereUniqueInput
    create: XOR<VerblijfsobjectCreateWithoutNummeraanduidingInput, VerblijfsobjectUncheckedCreateWithoutNummeraanduidingInput>
  }

  export type LigplaatsCreateWithoutNummeraanduidingInput = {
    identificatie: string
    beginGeldigheid: Date | string
    eindGeldigheid?: Date | string | null
    geconstateerd?: boolean
    documentDatum: Date | string
    documentNummer: string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LigplaatsUncheckedCreateWithoutNummeraanduidingInput = {
    identificatie: string
    beginGeldigheid: Date | string
    eindGeldigheid?: Date | string | null
    geconstateerd?: boolean
    documentDatum: Date | string
    documentNummer: string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LigplaatsCreateOrConnectWithoutNummeraanduidingInput = {
    where: LigplaatsWhereUniqueInput
    create: XOR<LigplaatsCreateWithoutNummeraanduidingInput, LigplaatsUncheckedCreateWithoutNummeraanduidingInput>
  }

  export type StandplaatsCreateWithoutNummeraanduidingInput = {
    identificatie: string
    beginGeldigheid: Date | string
    eindGeldigheid?: Date | string | null
    geconstateerd?: boolean
    documentDatum: Date | string
    documentNummer: string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StandplaatsUncheckedCreateWithoutNummeraanduidingInput = {
    identificatie: string
    beginGeldigheid: Date | string
    eindGeldigheid?: Date | string | null
    geconstateerd?: boolean
    documentDatum: Date | string
    documentNummer: string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StandplaatsCreateOrConnectWithoutNummeraanduidingInput = {
    where: StandplaatsWhereUniqueInput
    create: XOR<StandplaatsCreateWithoutNummeraanduidingInput, StandplaatsUncheckedCreateWithoutNummeraanduidingInput>
  }

  export type OpenbareRuimteUpsertWithoutNummeraanduidingenInput = {
    update: XOR<OpenbareRuimteUpdateWithoutNummeraanduidingenInput, OpenbareRuimteUncheckedUpdateWithoutNummeraanduidingenInput>
    create: XOR<OpenbareRuimteCreateWithoutNummeraanduidingenInput, OpenbareRuimteUncheckedCreateWithoutNummeraanduidingenInput>
    where?: OpenbareRuimteWhereInput
  }

  export type OpenbareRuimteUpdateToOneWithWhereWithoutNummeraanduidingenInput = {
    where?: OpenbareRuimteWhereInput
    data: XOR<OpenbareRuimteUpdateWithoutNummeraanduidingenInput, OpenbareRuimteUncheckedUpdateWithoutNummeraanduidingenInput>
  }

  export type OpenbareRuimteUpdateWithoutNummeraanduidingenInput = {
    identificatie?: StringFieldUpdateOperationsInput | string
    beginGeldigheid?: DateTimeFieldUpdateOperationsInput | Date | string
    eindGeldigheid?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    geconstateerd?: BoolFieldUpdateOperationsInput | boolean
    documentDatum?: DateTimeFieldUpdateOperationsInput | Date | string
    documentNummer?: StringFieldUpdateOperationsInput | string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    naam?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    woonplaats?: WoonplaatsUpdateOneRequiredWithoutOpenbareRuimtesNestedInput
  }

  export type OpenbareRuimteUncheckedUpdateWithoutNummeraanduidingenInput = {
    identificatie?: StringFieldUpdateOperationsInput | string
    beginGeldigheid?: DateTimeFieldUpdateOperationsInput | Date | string
    eindGeldigheid?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    geconstateerd?: BoolFieldUpdateOperationsInput | boolean
    documentDatum?: DateTimeFieldUpdateOperationsInput | Date | string
    documentNummer?: StringFieldUpdateOperationsInput | string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    naam?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    woonplaatsId?: StringFieldUpdateOperationsInput | string
  }

  export type VerblijfsobjectUpsertWithoutNummeraanduidingInput = {
    update: XOR<VerblijfsobjectUpdateWithoutNummeraanduidingInput, VerblijfsobjectUncheckedUpdateWithoutNummeraanduidingInput>
    create: XOR<VerblijfsobjectCreateWithoutNummeraanduidingInput, VerblijfsobjectUncheckedCreateWithoutNummeraanduidingInput>
    where?: VerblijfsobjectWhereInput
  }

  export type VerblijfsobjectUpdateToOneWithWhereWithoutNummeraanduidingInput = {
    where?: VerblijfsobjectWhereInput
    data: XOR<VerblijfsobjectUpdateWithoutNummeraanduidingInput, VerblijfsobjectUncheckedUpdateWithoutNummeraanduidingInput>
  }

  export type VerblijfsobjectUpdateWithoutNummeraanduidingInput = {
    identificatie?: StringFieldUpdateOperationsInput | string
    beginGeldigheid?: DateTimeFieldUpdateOperationsInput | Date | string
    eindGeldigheid?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    geconstateerd?: BoolFieldUpdateOperationsInput | boolean
    documentDatum?: DateTimeFieldUpdateOperationsInput | Date | string
    documentNummer?: StringFieldUpdateOperationsInput | string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    rd_x?: NullableFloatFieldUpdateOperationsInput | number | null
    rd_y?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gebruiksdoel?: VerblijfsobjectUpdategebruiksdoelInput | string[]
    oppervlakte?: IntFieldUpdateOperationsInput | number
    pand?: PandUpdateOneRequiredWithoutVerblijfsobjectenNestedInput
  }

  export type VerblijfsobjectUncheckedUpdateWithoutNummeraanduidingInput = {
    identificatie?: StringFieldUpdateOperationsInput | string
    beginGeldigheid?: DateTimeFieldUpdateOperationsInput | Date | string
    eindGeldigheid?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    geconstateerd?: BoolFieldUpdateOperationsInput | boolean
    documentDatum?: DateTimeFieldUpdateOperationsInput | Date | string
    documentNummer?: StringFieldUpdateOperationsInput | string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    rd_x?: NullableFloatFieldUpdateOperationsInput | number | null
    rd_y?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gebruiksdoel?: VerblijfsobjectUpdategebruiksdoelInput | string[]
    oppervlakte?: IntFieldUpdateOperationsInput | number
    pandId?: StringFieldUpdateOperationsInput | string
  }

  export type LigplaatsUpsertWithoutNummeraanduidingInput = {
    update: XOR<LigplaatsUpdateWithoutNummeraanduidingInput, LigplaatsUncheckedUpdateWithoutNummeraanduidingInput>
    create: XOR<LigplaatsCreateWithoutNummeraanduidingInput, LigplaatsUncheckedCreateWithoutNummeraanduidingInput>
    where?: LigplaatsWhereInput
  }

  export type LigplaatsUpdateToOneWithWhereWithoutNummeraanduidingInput = {
    where?: LigplaatsWhereInput
    data: XOR<LigplaatsUpdateWithoutNummeraanduidingInput, LigplaatsUncheckedUpdateWithoutNummeraanduidingInput>
  }

  export type LigplaatsUpdateWithoutNummeraanduidingInput = {
    identificatie?: StringFieldUpdateOperationsInput | string
    beginGeldigheid?: DateTimeFieldUpdateOperationsInput | Date | string
    eindGeldigheid?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    geconstateerd?: BoolFieldUpdateOperationsInput | boolean
    documentDatum?: DateTimeFieldUpdateOperationsInput | Date | string
    documentNummer?: StringFieldUpdateOperationsInput | string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LigplaatsUncheckedUpdateWithoutNummeraanduidingInput = {
    identificatie?: StringFieldUpdateOperationsInput | string
    beginGeldigheid?: DateTimeFieldUpdateOperationsInput | Date | string
    eindGeldigheid?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    geconstateerd?: BoolFieldUpdateOperationsInput | boolean
    documentDatum?: DateTimeFieldUpdateOperationsInput | Date | string
    documentNummer?: StringFieldUpdateOperationsInput | string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StandplaatsUpsertWithoutNummeraanduidingInput = {
    update: XOR<StandplaatsUpdateWithoutNummeraanduidingInput, StandplaatsUncheckedUpdateWithoutNummeraanduidingInput>
    create: XOR<StandplaatsCreateWithoutNummeraanduidingInput, StandplaatsUncheckedCreateWithoutNummeraanduidingInput>
    where?: StandplaatsWhereInput
  }

  export type StandplaatsUpdateToOneWithWhereWithoutNummeraanduidingInput = {
    where?: StandplaatsWhereInput
    data: XOR<StandplaatsUpdateWithoutNummeraanduidingInput, StandplaatsUncheckedUpdateWithoutNummeraanduidingInput>
  }

  export type StandplaatsUpdateWithoutNummeraanduidingInput = {
    identificatie?: StringFieldUpdateOperationsInput | string
    beginGeldigheid?: DateTimeFieldUpdateOperationsInput | Date | string
    eindGeldigheid?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    geconstateerd?: BoolFieldUpdateOperationsInput | boolean
    documentDatum?: DateTimeFieldUpdateOperationsInput | Date | string
    documentNummer?: StringFieldUpdateOperationsInput | string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StandplaatsUncheckedUpdateWithoutNummeraanduidingInput = {
    identificatie?: StringFieldUpdateOperationsInput | string
    beginGeldigheid?: DateTimeFieldUpdateOperationsInput | Date | string
    eindGeldigheid?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    geconstateerd?: BoolFieldUpdateOperationsInput | boolean
    documentDatum?: DateTimeFieldUpdateOperationsInput | Date | string
    documentNummer?: StringFieldUpdateOperationsInput | string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NummeraanduidingCreateWithoutVerblijfsobjectInput = {
    identificatie: string
    beginGeldigheid: Date | string
    eindGeldigheid?: Date | string | null
    geconstateerd?: boolean
    documentDatum: Date | string
    documentNummer: string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    huisnummer: number
    huisletter?: string | null
    huisnummertoevoeging?: string | null
    postcode?: string | null
    type: string
    openbareRuimte: OpenbareRuimteCreateNestedOneWithoutNummeraanduidingenInput
    ligplaats?: LigplaatsCreateNestedOneWithoutNummeraanduidingInput
    standplaats?: StandplaatsCreateNestedOneWithoutNummeraanduidingInput
  }

  export type NummeraanduidingUncheckedCreateWithoutVerblijfsobjectInput = {
    identificatie: string
    beginGeldigheid: Date | string
    eindGeldigheid?: Date | string | null
    geconstateerd?: boolean
    documentDatum: Date | string
    documentNummer: string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    huisnummer: number
    huisletter?: string | null
    huisnummertoevoeging?: string | null
    postcode?: string | null
    type: string
    openbareRuimteId: string
    ligplaats?: LigplaatsUncheckedCreateNestedOneWithoutNummeraanduidingInput
    standplaats?: StandplaatsUncheckedCreateNestedOneWithoutNummeraanduidingInput
  }

  export type NummeraanduidingCreateOrConnectWithoutVerblijfsobjectInput = {
    where: NummeraanduidingWhereUniqueInput
    create: XOR<NummeraanduidingCreateWithoutVerblijfsobjectInput, NummeraanduidingUncheckedCreateWithoutVerblijfsobjectInput>
  }

  export type PandCreateWithoutVerblijfsobjectenInput = {
    identificatie: string
    beginGeldigheid: Date | string
    eindGeldigheid?: Date | string | null
    geconstateerd?: boolean
    documentDatum: Date | string
    documentNummer: string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    oorspronkelijkBouwjaar: number
  }

  export type PandUncheckedCreateWithoutVerblijfsobjectenInput = {
    identificatie: string
    beginGeldigheid: Date | string
    eindGeldigheid?: Date | string | null
    geconstateerd?: boolean
    documentDatum: Date | string
    documentNummer: string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    oorspronkelijkBouwjaar: number
  }

  export type PandCreateOrConnectWithoutVerblijfsobjectenInput = {
    where: PandWhereUniqueInput
    create: XOR<PandCreateWithoutVerblijfsobjectenInput, PandUncheckedCreateWithoutVerblijfsobjectenInput>
  }

  export type NummeraanduidingUpsertWithoutVerblijfsobjectInput = {
    update: XOR<NummeraanduidingUpdateWithoutVerblijfsobjectInput, NummeraanduidingUncheckedUpdateWithoutVerblijfsobjectInput>
    create: XOR<NummeraanduidingCreateWithoutVerblijfsobjectInput, NummeraanduidingUncheckedCreateWithoutVerblijfsobjectInput>
    where?: NummeraanduidingWhereInput
  }

  export type NummeraanduidingUpdateToOneWithWhereWithoutVerblijfsobjectInput = {
    where?: NummeraanduidingWhereInput
    data: XOR<NummeraanduidingUpdateWithoutVerblijfsobjectInput, NummeraanduidingUncheckedUpdateWithoutVerblijfsobjectInput>
  }

  export type NummeraanduidingUpdateWithoutVerblijfsobjectInput = {
    identificatie?: StringFieldUpdateOperationsInput | string
    beginGeldigheid?: DateTimeFieldUpdateOperationsInput | Date | string
    eindGeldigheid?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    geconstateerd?: BoolFieldUpdateOperationsInput | boolean
    documentDatum?: DateTimeFieldUpdateOperationsInput | Date | string
    documentNummer?: StringFieldUpdateOperationsInput | string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    huisnummer?: IntFieldUpdateOperationsInput | number
    huisletter?: NullableStringFieldUpdateOperationsInput | string | null
    huisnummertoevoeging?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    openbareRuimte?: OpenbareRuimteUpdateOneRequiredWithoutNummeraanduidingenNestedInput
    ligplaats?: LigplaatsUpdateOneWithoutNummeraanduidingNestedInput
    standplaats?: StandplaatsUpdateOneWithoutNummeraanduidingNestedInput
  }

  export type NummeraanduidingUncheckedUpdateWithoutVerblijfsobjectInput = {
    identificatie?: StringFieldUpdateOperationsInput | string
    beginGeldigheid?: DateTimeFieldUpdateOperationsInput | Date | string
    eindGeldigheid?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    geconstateerd?: BoolFieldUpdateOperationsInput | boolean
    documentDatum?: DateTimeFieldUpdateOperationsInput | Date | string
    documentNummer?: StringFieldUpdateOperationsInput | string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    huisnummer?: IntFieldUpdateOperationsInput | number
    huisletter?: NullableStringFieldUpdateOperationsInput | string | null
    huisnummertoevoeging?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    openbareRuimteId?: StringFieldUpdateOperationsInput | string
    ligplaats?: LigplaatsUncheckedUpdateOneWithoutNummeraanduidingNestedInput
    standplaats?: StandplaatsUncheckedUpdateOneWithoutNummeraanduidingNestedInput
  }

  export type PandUpsertWithoutVerblijfsobjectenInput = {
    update: XOR<PandUpdateWithoutVerblijfsobjectenInput, PandUncheckedUpdateWithoutVerblijfsobjectenInput>
    create: XOR<PandCreateWithoutVerblijfsobjectenInput, PandUncheckedCreateWithoutVerblijfsobjectenInput>
    where?: PandWhereInput
  }

  export type PandUpdateToOneWithWhereWithoutVerblijfsobjectenInput = {
    where?: PandWhereInput
    data: XOR<PandUpdateWithoutVerblijfsobjectenInput, PandUncheckedUpdateWithoutVerblijfsobjectenInput>
  }

  export type PandUpdateWithoutVerblijfsobjectenInput = {
    identificatie?: StringFieldUpdateOperationsInput | string
    beginGeldigheid?: DateTimeFieldUpdateOperationsInput | Date | string
    eindGeldigheid?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    geconstateerd?: BoolFieldUpdateOperationsInput | boolean
    documentDatum?: DateTimeFieldUpdateOperationsInput | Date | string
    documentNummer?: StringFieldUpdateOperationsInput | string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    oorspronkelijkBouwjaar?: IntFieldUpdateOperationsInput | number
  }

  export type PandUncheckedUpdateWithoutVerblijfsobjectenInput = {
    identificatie?: StringFieldUpdateOperationsInput | string
    beginGeldigheid?: DateTimeFieldUpdateOperationsInput | Date | string
    eindGeldigheid?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    geconstateerd?: BoolFieldUpdateOperationsInput | boolean
    documentDatum?: DateTimeFieldUpdateOperationsInput | Date | string
    documentNummer?: StringFieldUpdateOperationsInput | string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    oorspronkelijkBouwjaar?: IntFieldUpdateOperationsInput | number
  }

  export type NummeraanduidingCreateWithoutLigplaatsInput = {
    identificatie: string
    beginGeldigheid: Date | string
    eindGeldigheid?: Date | string | null
    geconstateerd?: boolean
    documentDatum: Date | string
    documentNummer: string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    huisnummer: number
    huisletter?: string | null
    huisnummertoevoeging?: string | null
    postcode?: string | null
    type: string
    openbareRuimte: OpenbareRuimteCreateNestedOneWithoutNummeraanduidingenInput
    verblijfsobject?: VerblijfsobjectCreateNestedOneWithoutNummeraanduidingInput
    standplaats?: StandplaatsCreateNestedOneWithoutNummeraanduidingInput
  }

  export type NummeraanduidingUncheckedCreateWithoutLigplaatsInput = {
    identificatie: string
    beginGeldigheid: Date | string
    eindGeldigheid?: Date | string | null
    geconstateerd?: boolean
    documentDatum: Date | string
    documentNummer: string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    huisnummer: number
    huisletter?: string | null
    huisnummertoevoeging?: string | null
    postcode?: string | null
    type: string
    openbareRuimteId: string
    verblijfsobject?: VerblijfsobjectUncheckedCreateNestedOneWithoutNummeraanduidingInput
    standplaats?: StandplaatsUncheckedCreateNestedOneWithoutNummeraanduidingInput
  }

  export type NummeraanduidingCreateOrConnectWithoutLigplaatsInput = {
    where: NummeraanduidingWhereUniqueInput
    create: XOR<NummeraanduidingCreateWithoutLigplaatsInput, NummeraanduidingUncheckedCreateWithoutLigplaatsInput>
  }

  export type NummeraanduidingUpsertWithoutLigplaatsInput = {
    update: XOR<NummeraanduidingUpdateWithoutLigplaatsInput, NummeraanduidingUncheckedUpdateWithoutLigplaatsInput>
    create: XOR<NummeraanduidingCreateWithoutLigplaatsInput, NummeraanduidingUncheckedCreateWithoutLigplaatsInput>
    where?: NummeraanduidingWhereInput
  }

  export type NummeraanduidingUpdateToOneWithWhereWithoutLigplaatsInput = {
    where?: NummeraanduidingWhereInput
    data: XOR<NummeraanduidingUpdateWithoutLigplaatsInput, NummeraanduidingUncheckedUpdateWithoutLigplaatsInput>
  }

  export type NummeraanduidingUpdateWithoutLigplaatsInput = {
    identificatie?: StringFieldUpdateOperationsInput | string
    beginGeldigheid?: DateTimeFieldUpdateOperationsInput | Date | string
    eindGeldigheid?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    geconstateerd?: BoolFieldUpdateOperationsInput | boolean
    documentDatum?: DateTimeFieldUpdateOperationsInput | Date | string
    documentNummer?: StringFieldUpdateOperationsInput | string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    huisnummer?: IntFieldUpdateOperationsInput | number
    huisletter?: NullableStringFieldUpdateOperationsInput | string | null
    huisnummertoevoeging?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    openbareRuimte?: OpenbareRuimteUpdateOneRequiredWithoutNummeraanduidingenNestedInput
    verblijfsobject?: VerblijfsobjectUpdateOneWithoutNummeraanduidingNestedInput
    standplaats?: StandplaatsUpdateOneWithoutNummeraanduidingNestedInput
  }

  export type NummeraanduidingUncheckedUpdateWithoutLigplaatsInput = {
    identificatie?: StringFieldUpdateOperationsInput | string
    beginGeldigheid?: DateTimeFieldUpdateOperationsInput | Date | string
    eindGeldigheid?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    geconstateerd?: BoolFieldUpdateOperationsInput | boolean
    documentDatum?: DateTimeFieldUpdateOperationsInput | Date | string
    documentNummer?: StringFieldUpdateOperationsInput | string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    huisnummer?: IntFieldUpdateOperationsInput | number
    huisletter?: NullableStringFieldUpdateOperationsInput | string | null
    huisnummertoevoeging?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    openbareRuimteId?: StringFieldUpdateOperationsInput | string
    verblijfsobject?: VerblijfsobjectUncheckedUpdateOneWithoutNummeraanduidingNestedInput
    standplaats?: StandplaatsUncheckedUpdateOneWithoutNummeraanduidingNestedInput
  }

  export type NummeraanduidingCreateWithoutStandplaatsInput = {
    identificatie: string
    beginGeldigheid: Date | string
    eindGeldigheid?: Date | string | null
    geconstateerd?: boolean
    documentDatum: Date | string
    documentNummer: string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    huisnummer: number
    huisletter?: string | null
    huisnummertoevoeging?: string | null
    postcode?: string | null
    type: string
    openbareRuimte: OpenbareRuimteCreateNestedOneWithoutNummeraanduidingenInput
    verblijfsobject?: VerblijfsobjectCreateNestedOneWithoutNummeraanduidingInput
    ligplaats?: LigplaatsCreateNestedOneWithoutNummeraanduidingInput
  }

  export type NummeraanduidingUncheckedCreateWithoutStandplaatsInput = {
    identificatie: string
    beginGeldigheid: Date | string
    eindGeldigheid?: Date | string | null
    geconstateerd?: boolean
    documentDatum: Date | string
    documentNummer: string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    huisnummer: number
    huisletter?: string | null
    huisnummertoevoeging?: string | null
    postcode?: string | null
    type: string
    openbareRuimteId: string
    verblijfsobject?: VerblijfsobjectUncheckedCreateNestedOneWithoutNummeraanduidingInput
    ligplaats?: LigplaatsUncheckedCreateNestedOneWithoutNummeraanduidingInput
  }

  export type NummeraanduidingCreateOrConnectWithoutStandplaatsInput = {
    where: NummeraanduidingWhereUniqueInput
    create: XOR<NummeraanduidingCreateWithoutStandplaatsInput, NummeraanduidingUncheckedCreateWithoutStandplaatsInput>
  }

  export type NummeraanduidingUpsertWithoutStandplaatsInput = {
    update: XOR<NummeraanduidingUpdateWithoutStandplaatsInput, NummeraanduidingUncheckedUpdateWithoutStandplaatsInput>
    create: XOR<NummeraanduidingCreateWithoutStandplaatsInput, NummeraanduidingUncheckedCreateWithoutStandplaatsInput>
    where?: NummeraanduidingWhereInput
  }

  export type NummeraanduidingUpdateToOneWithWhereWithoutStandplaatsInput = {
    where?: NummeraanduidingWhereInput
    data: XOR<NummeraanduidingUpdateWithoutStandplaatsInput, NummeraanduidingUncheckedUpdateWithoutStandplaatsInput>
  }

  export type NummeraanduidingUpdateWithoutStandplaatsInput = {
    identificatie?: StringFieldUpdateOperationsInput | string
    beginGeldigheid?: DateTimeFieldUpdateOperationsInput | Date | string
    eindGeldigheid?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    geconstateerd?: BoolFieldUpdateOperationsInput | boolean
    documentDatum?: DateTimeFieldUpdateOperationsInput | Date | string
    documentNummer?: StringFieldUpdateOperationsInput | string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    huisnummer?: IntFieldUpdateOperationsInput | number
    huisletter?: NullableStringFieldUpdateOperationsInput | string | null
    huisnummertoevoeging?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    openbareRuimte?: OpenbareRuimteUpdateOneRequiredWithoutNummeraanduidingenNestedInput
    verblijfsobject?: VerblijfsobjectUpdateOneWithoutNummeraanduidingNestedInput
    ligplaats?: LigplaatsUpdateOneWithoutNummeraanduidingNestedInput
  }

  export type NummeraanduidingUncheckedUpdateWithoutStandplaatsInput = {
    identificatie?: StringFieldUpdateOperationsInput | string
    beginGeldigheid?: DateTimeFieldUpdateOperationsInput | Date | string
    eindGeldigheid?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    geconstateerd?: BoolFieldUpdateOperationsInput | boolean
    documentDatum?: DateTimeFieldUpdateOperationsInput | Date | string
    documentNummer?: StringFieldUpdateOperationsInput | string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    huisnummer?: IntFieldUpdateOperationsInput | number
    huisletter?: NullableStringFieldUpdateOperationsInput | string | null
    huisnummertoevoeging?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    openbareRuimteId?: StringFieldUpdateOperationsInput | string
    verblijfsobject?: VerblijfsobjectUncheckedUpdateOneWithoutNummeraanduidingNestedInput
    ligplaats?: LigplaatsUncheckedUpdateOneWithoutNummeraanduidingNestedInput
  }

  export type OpenbareRuimteCreateManyWoonplaatsInput = {
    identificatie: string
    beginGeldigheid: Date | string
    eindGeldigheid?: Date | string | null
    geconstateerd?: boolean
    documentDatum: Date | string
    documentNummer: string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    naam: string
    type: string
  }

  export type OpenbareRuimteUpdateWithoutWoonplaatsInput = {
    identificatie?: StringFieldUpdateOperationsInput | string
    beginGeldigheid?: DateTimeFieldUpdateOperationsInput | Date | string
    eindGeldigheid?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    geconstateerd?: BoolFieldUpdateOperationsInput | boolean
    documentDatum?: DateTimeFieldUpdateOperationsInput | Date | string
    documentNummer?: StringFieldUpdateOperationsInput | string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    naam?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    nummeraanduidingen?: NummeraanduidingUpdateManyWithoutOpenbareRuimteNestedInput
  }

  export type OpenbareRuimteUncheckedUpdateWithoutWoonplaatsInput = {
    identificatie?: StringFieldUpdateOperationsInput | string
    beginGeldigheid?: DateTimeFieldUpdateOperationsInput | Date | string
    eindGeldigheid?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    geconstateerd?: BoolFieldUpdateOperationsInput | boolean
    documentDatum?: DateTimeFieldUpdateOperationsInput | Date | string
    documentNummer?: StringFieldUpdateOperationsInput | string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    naam?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    nummeraanduidingen?: NummeraanduidingUncheckedUpdateManyWithoutOpenbareRuimteNestedInput
  }

  export type OpenbareRuimteUncheckedUpdateManyWithoutWoonplaatsInput = {
    identificatie?: StringFieldUpdateOperationsInput | string
    beginGeldigheid?: DateTimeFieldUpdateOperationsInput | Date | string
    eindGeldigheid?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    geconstateerd?: BoolFieldUpdateOperationsInput | boolean
    documentDatum?: DateTimeFieldUpdateOperationsInput | Date | string
    documentNummer?: StringFieldUpdateOperationsInput | string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    naam?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type NummeraanduidingCreateManyOpenbareRuimteInput = {
    identificatie: string
    beginGeldigheid: Date | string
    eindGeldigheid?: Date | string | null
    geconstateerd?: boolean
    documentDatum: Date | string
    documentNummer: string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    huisnummer: number
    huisletter?: string | null
    huisnummertoevoeging?: string | null
    postcode?: string | null
    type: string
  }

  export type NummeraanduidingUpdateWithoutOpenbareRuimteInput = {
    identificatie?: StringFieldUpdateOperationsInput | string
    beginGeldigheid?: DateTimeFieldUpdateOperationsInput | Date | string
    eindGeldigheid?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    geconstateerd?: BoolFieldUpdateOperationsInput | boolean
    documentDatum?: DateTimeFieldUpdateOperationsInput | Date | string
    documentNummer?: StringFieldUpdateOperationsInput | string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    huisnummer?: IntFieldUpdateOperationsInput | number
    huisletter?: NullableStringFieldUpdateOperationsInput | string | null
    huisnummertoevoeging?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    verblijfsobject?: VerblijfsobjectUpdateOneWithoutNummeraanduidingNestedInput
    ligplaats?: LigplaatsUpdateOneWithoutNummeraanduidingNestedInput
    standplaats?: StandplaatsUpdateOneWithoutNummeraanduidingNestedInput
  }

  export type NummeraanduidingUncheckedUpdateWithoutOpenbareRuimteInput = {
    identificatie?: StringFieldUpdateOperationsInput | string
    beginGeldigheid?: DateTimeFieldUpdateOperationsInput | Date | string
    eindGeldigheid?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    geconstateerd?: BoolFieldUpdateOperationsInput | boolean
    documentDatum?: DateTimeFieldUpdateOperationsInput | Date | string
    documentNummer?: StringFieldUpdateOperationsInput | string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    huisnummer?: IntFieldUpdateOperationsInput | number
    huisletter?: NullableStringFieldUpdateOperationsInput | string | null
    huisnummertoevoeging?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    verblijfsobject?: VerblijfsobjectUncheckedUpdateOneWithoutNummeraanduidingNestedInput
    ligplaats?: LigplaatsUncheckedUpdateOneWithoutNummeraanduidingNestedInput
    standplaats?: StandplaatsUncheckedUpdateOneWithoutNummeraanduidingNestedInput
  }

  export type NummeraanduidingUncheckedUpdateManyWithoutOpenbareRuimteInput = {
    identificatie?: StringFieldUpdateOperationsInput | string
    beginGeldigheid?: DateTimeFieldUpdateOperationsInput | Date | string
    eindGeldigheid?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    geconstateerd?: BoolFieldUpdateOperationsInput | boolean
    documentDatum?: DateTimeFieldUpdateOperationsInput | Date | string
    documentNummer?: StringFieldUpdateOperationsInput | string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    huisnummer?: IntFieldUpdateOperationsInput | number
    huisletter?: NullableStringFieldUpdateOperationsInput | string | null
    huisnummertoevoeging?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
  }

  export type VerblijfsobjectCreateManyPandInput = {
    identificatie: string
    beginGeldigheid: Date | string
    eindGeldigheid?: Date | string | null
    geconstateerd?: boolean
    documentDatum: Date | string
    documentNummer: string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    rd_x?: number | null
    rd_y?: number | null
    longitude?: number | null
    latitude?: number | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    gebruiksdoel?: VerblijfsobjectCreategebruiksdoelInput | string[]
    oppervlakte: number
    nummeraanduidingId: string
  }

  export type VerblijfsobjectUpdateWithoutPandInput = {
    identificatie?: StringFieldUpdateOperationsInput | string
    beginGeldigheid?: DateTimeFieldUpdateOperationsInput | Date | string
    eindGeldigheid?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    geconstateerd?: BoolFieldUpdateOperationsInput | boolean
    documentDatum?: DateTimeFieldUpdateOperationsInput | Date | string
    documentNummer?: StringFieldUpdateOperationsInput | string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    rd_x?: NullableFloatFieldUpdateOperationsInput | number | null
    rd_y?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gebruiksdoel?: VerblijfsobjectUpdategebruiksdoelInput | string[]
    oppervlakte?: IntFieldUpdateOperationsInput | number
    nummeraanduiding?: NummeraanduidingUpdateOneRequiredWithoutVerblijfsobjectNestedInput
  }

  export type VerblijfsobjectUncheckedUpdateWithoutPandInput = {
    identificatie?: StringFieldUpdateOperationsInput | string
    beginGeldigheid?: DateTimeFieldUpdateOperationsInput | Date | string
    eindGeldigheid?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    geconstateerd?: BoolFieldUpdateOperationsInput | boolean
    documentDatum?: DateTimeFieldUpdateOperationsInput | Date | string
    documentNummer?: StringFieldUpdateOperationsInput | string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    rd_x?: NullableFloatFieldUpdateOperationsInput | number | null
    rd_y?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gebruiksdoel?: VerblijfsobjectUpdategebruiksdoelInput | string[]
    oppervlakte?: IntFieldUpdateOperationsInput | number
    nummeraanduidingId?: StringFieldUpdateOperationsInput | string
  }

  export type VerblijfsobjectUncheckedUpdateManyWithoutPandInput = {
    identificatie?: StringFieldUpdateOperationsInput | string
    beginGeldigheid?: DateTimeFieldUpdateOperationsInput | Date | string
    eindGeldigheid?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    geconstateerd?: BoolFieldUpdateOperationsInput | boolean
    documentDatum?: DateTimeFieldUpdateOperationsInput | Date | string
    documentNummer?: StringFieldUpdateOperationsInput | string
    geometry?: NullableJsonNullValueInput | InputJsonValue
    rd_x?: NullableFloatFieldUpdateOperationsInput | number | null
    rd_y?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gebruiksdoel?: VerblijfsobjectUpdategebruiksdoelInput | string[]
    oppervlakte?: IntFieldUpdateOperationsInput | number
    nummeraanduidingId?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use WoonplaatsCountOutputTypeDefaultArgs instead
     */
    export type WoonplaatsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WoonplaatsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OpenbareRuimteCountOutputTypeDefaultArgs instead
     */
    export type OpenbareRuimteCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OpenbareRuimteCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PandCountOutputTypeDefaultArgs instead
     */
    export type PandCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PandCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WoonplaatsDefaultArgs instead
     */
    export type WoonplaatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WoonplaatsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OpenbareRuimteDefaultArgs instead
     */
    export type OpenbareRuimteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OpenbareRuimteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PandDefaultArgs instead
     */
    export type PandArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PandDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NummeraanduidingDefaultArgs instead
     */
    export type NummeraanduidingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NummeraanduidingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VerblijfsobjectDefaultArgs instead
     */
    export type VerblijfsobjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VerblijfsobjectDefaultArgs<ExtArgs>
    /**
     * @deprecated Use spatial_ref_sysDefaultArgs instead
     */
    export type spatial_ref_sysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = spatial_ref_sysDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ImportJobDefaultArgs instead
     */
    export type ImportJobArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ImportJobDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NummeraanduidingStagingDefaultArgs instead
     */
    export type NummeraanduidingStagingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NummeraanduidingStagingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LigplaatsDefaultArgs instead
     */
    export type LigplaatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LigplaatsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StandplaatsDefaultArgs instead
     */
    export type StandplaatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StandplaatsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StatisticsCacheDefaultArgs instead
     */
    export type StatisticsCacheArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StatisticsCacheDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AddressCacheDefaultArgs instead
     */
    export type AddressCacheArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AddressCacheDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExportJobDefaultArgs instead
     */
    export type ExportJobArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExportJobDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}